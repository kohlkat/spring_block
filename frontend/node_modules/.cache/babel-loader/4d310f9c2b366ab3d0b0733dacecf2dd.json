{"ast":null,"code":"/**\r\n * Functionality for any series-based elements, like Line Series (graphs),\r\n * Pie slice lists, etc.\r\n */\nimport * as tslib_1 from \"tslib\";\n/**\r\n * ============================================================================\r\n * IMPORTS\r\n * ============================================================================\r\n * @hidden\r\n */\n\nimport { Component } from \"../../core/Component\";\nimport { Sprite } from \"../../core/Sprite\";\nimport { List, ListTemplate, ListDisposer } from \"../../core/utils/List\";\nimport { Dictionary, DictionaryDisposer } from \"../../core/utils/Dictionary\";\nimport { DataItem } from \"../../core/DataItem\";\nimport { Container } from \"../../core/Container\";\nimport { Tooltip } from \"../../core/elements/Tooltip\";\nimport { Bullet } from \"../elements/Bullet\";\nimport { LegendSettings } from \"../Legend\";\nimport { options } from \"../../core/Options\";\nimport { Color } from \"../../core/utils/Color\";\nimport { registry } from \"../../core/Registry\";\nimport * as $iter from \"../../core/utils/Iterator\";\nimport * as $math from \"../../core/utils/Math\";\nimport * as $ease from \"../../core/utils/Ease\";\nimport * as $utils from \"../../core/utils/Utils\";\nimport * as $object from \"../../core/utils/Object\";\nimport * as $type from \"../../core/utils/Type\";\nimport * as $array from \"../../core/utils/Array\";\nimport * as $colors from \"../../core/utils/Colors\";\n/**\r\n * ============================================================================\r\n * DATA ITEM\r\n * ============================================================================\r\n * @hidden\r\n */\n\n/**\r\n * Defines a [[DataItem]] for [[Series]].\r\n *\r\n * @see {@link DataItem}\r\n */\n\nvar SeriesDataItem =\n/** @class */\nfunction (_super) {\n  tslib_1.__extends(SeriesDataItem, _super);\n  /**\r\n   * Constructor\r\n   */\n\n\n  function SeriesDataItem() {\n    var _this = _super.call(this) || this;\n\n    _this.className = \"SeriesDataItem\"; //@todo Should we make `bullets` list disposable?\n    //this._disposers.push(new DictionaryDisposer(this.bullets));\n\n    _this.values.value = {};\n    _this.values.value = {};\n\n    _this.applyTheme();\n\n    return _this;\n  }\n\n  Object.defineProperty(SeriesDataItem.prototype, \"bullets\", {\n    /**\r\n     * A dictionary of data items bullets, where key is uid of a bullet template.\r\n     */\n    get: function () {\n      if (!this._bullets) {\n        this._bullets = new Dictionary();\n\n        this._disposers.push(new DictionaryDisposer(this._bullets));\n      }\n\n      return this._bullets;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\r\n   * Destroys this object and all related data.\r\n   */\n\n  SeriesDataItem.prototype.dispose = function () {\n    this.bullets.clear();\n\n    _super.prototype.dispose.call(this);\n  };\n\n  Object.defineProperty(SeriesDataItem.prototype, \"value\", {\n    /**\r\n     * @return Value\r\n     */\n    get: function () {\n      return this.values.value.value;\n    },\n\n    /**\r\n     * data items's numeric value.\r\n     *\r\n     * @param value  Value\r\n     */\n    set: function (value) {\n      this.setValue(\"value\", value);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  return SeriesDataItem;\n}(DataItem);\n\nexport { SeriesDataItem };\n/**\r\n * ============================================================================\r\n * MAIN CLASS\r\n * ============================================================================\r\n * @hidden\r\n */\n\n/**\r\n * Defines base class for any kind of serial data.\r\n *\r\n * @see {@link ISeriesEvents} for a list of available Events\r\n * @see {@link ISeriesAdapters} for a list of available Adapters\r\n * @todo Separate axis-related stuff to some other class so that MapSeries would not have unrelated stuff\r\n */\n\nvar Series =\n/** @class */\nfunction (_super) {\n  tslib_1.__extends(Series, _super);\n  /**\r\n   * Constructor\r\n   */\n\n\n  function Series() {\n    var _this = _super.call(this) || this;\n    /**\r\n     * Should this series excluded from the axis scale calculations?\r\n     *\r\n     * @default false\r\n     */\n\n\n    _this._ignoreMinMax = false;\n    /**\r\n     * Should series' bullets?\r\n     *\r\n     * @default true\r\n     */\n\n    _this._showBullets = true;\n    /**\r\n     * Settings for the appearance of the related legend items.\r\n     */\n\n    _this.legendSettings = new LegendSettings();\n    /**\r\n     * Lowest overal values by type.\r\n     */\n\n    _this._tmin = new Dictionary();\n    /**\r\n     * Highest overal values by type.\r\n     */\n\n    _this._tmax = new Dictionary();\n    /**\r\n     * Lowest values in current selection by type.\r\n     */\n\n    _this._smin = new Dictionary();\n    /**\r\n     * Highest values in current selection by type.\r\n     */\n\n    _this._smax = new Dictionary();\n    /**\r\n     * [dataItemsByAxis description]\r\n     *\r\n     * Both by category and date.\r\n     *\r\n     * @ignore Exclude from docs\r\n     * @todo Description\r\n     */\n\n    _this.dataItemsByAxis = new Dictionary();\n    /**\r\n     * Normally series items are focusable using keyboard, so that people can\r\n     * select them with a TAB key. However, if there are a lot of data points on\r\n     * screen it might be long and useless to tab through all o fthem.\r\n     *\r\n     * This is where `skipFocusThreshold` comes in. If there are more items than\r\n     * the value set here, we will not make those focusable and rather let screen\r\n     * reader software rely on the series summary, or authors provide alternative\r\n     * detailed information display, such as HTML table.\r\n     *\r\n     * Different series might have different threshold defaults.\r\n     */\n\n    _this.skipFocusThreshold = 20;\n    /**\r\n     * Used to indicate if `itemReaderText` was changed \"from the outside\".\r\n     */\n\n    _this._itemReaderTextChanged = false;\n    /**\r\n     * Most of the series use absolute values. However sometimes various\r\n     * calculated percent values are need, e.g. item's percent representation\r\n     * across all values in series, etc.\r\n     *\r\n     * It's a resource-intensive operation, so it is disabled by default.\r\n     *\r\n     * If you need percents to be calculated, e.g. for showing them in tooltips,\r\n     * or creating 100% stacks, this setting needs to be set to `true`.\r\n     *\r\n     * NOTE: `PieChart`, which relies on slice percentages, has this\r\n     * automatically set to `true`.\r\n     *\r\n     * @default false\r\n     */\n\n    _this.calculatePercent = false;\n    /**\r\n     * Specifies if series should be automatically disposed when removing from\r\n     * chart's `series` list.\r\n     *\r\n     * @default true\r\n     */\n\n    _this.autoDispose = true;\n    /**\r\n     * When chart/series' data is processed, all kinds of derivative values are\r\n     * calculated. E.g. sum, min, max, change, etc. This is a potentially\r\n     * time-consuming operation, especially prominent in data-heavy charts.\r\n     *\r\n     * If your chart does not need those values, and you have a lot of data,\r\n     * setting this to `true` might give a dramatic increase in initial chart\r\n     * load speed.\r\n     *\r\n     * Please note, regular column and line series usage scenarios do not\r\n     * require derivative values. Those come into play only when you do advanced\r\n     * functionality like coloring segments of charts in different colors\r\n     * depending on change between open and close values, have stacked series, or\r\n     * display any of the derived values, like percent, in tooltips or bullets.\r\n     *\r\n     * @default false\r\n     */\n\n    _this.simplifiedProcessing = false;\n\n    if (_this.constructor === Series) {\n      throw new Error(\"'Series' cannot be instantiated directly. Please use a specific series type.\");\n    }\n\n    _this.className = \"Series\";\n    _this.isMeasured = false;\n    _this.layout = \"none\";\n    _this.shouldClone = false;\n\n    _this.setPropertyValue(\"hidden\", false);\n\n    _this.axisRanges = new List();\n\n    _this.axisRanges.events.on(\"inserted\", _this.processAxisRange, _this, false);\n\n    _this.minBulletDistance = 0; // otherwise we'll have a lot of cases when people won't see bullets and think it's a bug\n\n    _this.mainContainer = _this.createChild(Container);\n    _this.mainContainer.shouldClone = false;\n    _this.mainContainer.mask = _this.createChild(Sprite);\n\n    _this._disposers.push(_this.mainContainer); // all bullets should go on top of lines/fills. So we add a separate container for bullets and later set it's parent to chart.bulletsContainer\n\n\n    var bulletsContainer = _this.mainContainer.createChild(Container);\n\n    _this._shouldBeReady.push(bulletsContainer);\n\n    bulletsContainer.shouldClone = false;\n    bulletsContainer.layout = \"none\";\n    bulletsContainer.virtualParent = _this;\n\n    _this._disposers.push(bulletsContainer);\n\n    _this.bulletsContainer = bulletsContainer;\n    _this.tooltip = new Tooltip();\n    _this.tooltip.virtualParent = _this;\n\n    _this._disposers.push(_this.tooltip);\n\n    _this.hiddenState.transitionEasing = $ease.cubicIn; // this data item holds sums, averages, etc\n\n    _this.dataItem = _this.createDataItem();\n\n    _this._disposers.push(_this.dataItem);\n\n    _this.dataItem.component = _this; // Apply accessibility\n\n    _this.role = \"group\";\n\n    _this.applyTheme();\n\n    return _this;\n  }\n  /**\r\n   * We need this here so that class names can be applied to bullets container.\r\n   *\r\n   * @ignore Exclude from docs\r\n   */\n\n\n  Series.prototype.applyTheme = function () {\n    _super.prototype.applyTheme.call(this);\n\n    if (options.autoSetClassName && this.bulletsContainer) {\n      this.bulletsContainer.className = this.className + \"-bullets\";\n      this.bulletsContainer.setClassName();\n    }\n  };\n  /**\r\n   * Sets defaults that instantiate some objects that rely on parent, so they\r\n   * cannot be set in constructor.\r\n   */\n\n\n  Series.prototype.applyInternalDefaults = function () {\n    _super.prototype.applyInternalDefaults.call(this);\n\n    if (!$type.hasValue(this.readerTitle)) {\n      this.readerTitle = this.language.translate(\"Series\");\n    }\n  };\n  /**\r\n   * Returns a new/empty DataItem of the type appropriate for this object.\r\n   *\r\n   * @see {@link DataItem}\r\n   * @return Data Item\r\n   */\n\n\n  Series.prototype.createDataItem = function () {\n    return new SeriesDataItem();\n  };\n\n  Object.defineProperty(Series.prototype, \"chart\", {\n    /**\r\n     * @return Chart\r\n     */\n    get: function () {\n      return this._chart;\n    },\n\n    /**\r\n     * Chart series is used on.\r\n     *\r\n     * @param value  Chart\r\n     */\n    set: function (value) {\n      this._chart = value;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\r\n   * Positions bullet.\r\n   *\r\n   * @param bullet  Sprite\r\n   */\n\n  Series.prototype.positionBullet = function (bullet) {// Placeholder method for extending classes to override.\n  };\n  /**\r\n   * Decorates newly created bullet after it has been instert into the list.\r\n   *\r\n   * @param event  List event\r\n   * @todo investigate why itemReaderText is undefined\r\n   */\n\n\n  Series.prototype.processBullet = function (event) {\n    var _this = this;\n\n    var bullet = event.newValue;\n    bullet.isTemplate = true; // Add accessibility options to bullet\n    // If there are relatively few bullets, make them focusable\n\n    this.events.once(\"datavalidated\", function (ev) {\n      if (_this.itemsFocusable()) {\n        bullet.focusable = true;\n      }\n    });\n  };\n  /**\r\n   * removes bullets\r\n   *\r\n   * @param event  List event\r\n   */\n\n\n  Series.prototype.removeBullet = function (event) {\n    var bullet = event.oldValue;\n    this.dataItems.each(function (dataItem) {\n      var eachBullet = dataItem.bullets.getKey(bullet.uid);\n\n      if (eachBullet) {\n        eachBullet.dispose();\n      }\n    });\n    this.invalidate();\n  };\n  /**\r\n   * Validates data items.\r\n   *\r\n   * @ignore Exclude from docs\r\n   */\n\n\n  Series.prototype.validateDataItems = function () {\n    _super.prototype.validateDataItems.call(this);\n\n    this.processValues(false);\n  };\n  /**\r\n   * Returns first value for the specific key in the series.\r\n   *\r\n   * @param key  Key\r\n   * @return Value\r\n   * @todo Description\r\n   * @todo Convert to propert object property iterator\r\n   */\n\n\n  Series.prototype.getFirstValue = function (key, startIndex) {\n    // find first\n\n    /*\r\n    return $iter.findMap(this.dataItems.iterator(), (dataItem) => {\r\n        for (let key in dataItem.values) {\r\n            if ($object.hasKey(dataItem.values, key)) {\r\n                let value: number = dataItem.values[key].workingValue;\r\n                if ($type.isNumber(value)) {\r\n                    return value;\r\n                }\r\n            }\r\n        }\r\n          return null;\r\n    });*/\n    if (startIndex > 0 && startIndex < this.dataItems.length - 1) {\n      startIndex++;\n    }\n\n    for (var i = startIndex; i >= 0; i--) {\n      var dataItem = this.dataItems.getIndex(i);\n      var value = dataItem.getActualWorkingValue(key);\n\n      if ($type.isNumber(value)) {\n        return value;\n      }\n    }\n\n    return null;\n  };\n  /**\r\n   * Returns first value for the specific key in the series.\r\n   *\r\n   * @param key  Key\r\n   * @return Value\r\n   * @todo Description\r\n   * @todo Convert to propert object property iterator\r\n   */\n\n\n  Series.prototype.getAbsoluteFirstValue = function (key) {\n    for (var i = 0; i < this.dataItems.length; i++) {\n      var dataItem = this.dataItems.getIndex(i);\n      var value = dataItem.values[key].value;\n\n      if ($type.isNumber(value)) {\n        return value;\n      }\n    }\n\n    return null;\n  };\n  /**\r\n   * [rangeChangeUpdate description]\r\n   *\r\n   * @todo Description\r\n   */\n\n\n  Series.prototype.rangeChangeUpdate = function () {\n    _super.prototype.rangeChangeUpdate.call(this);\n\n    this.processValues(true);\n  };\n  /**\r\n   * [processValues description]\r\n   *\r\n   * @todo Description\r\n   * @todo Convert to propert object property iterator\r\n   * @param dataItems [description]\r\n   */\n\n\n  Series.prototype.processValues = function (working) {\n    var _this = this;\n\n    if (!this.simplifiedProcessing) {\n      var dataItems = this.dataItems;\n      var count_1 = {};\n      var sum_1 = {};\n      var low_1 = {};\n      var high_1 = {};\n      var open_1 = {};\n      var close_1 = {};\n      var previous_1 = {};\n      var first_1 = {};\n      var absoluteFirst_1 = {}; //let duration: number = 0; // todo: check if series uses selection.change or selection.change.percent and set duration to interpolationduration\n\n      var startIndex_1 = $math.max(0, this._workingStartIndex);\n      startIndex_1 = $math.min(startIndex_1, this.dataItems.length);\n      var endIndex = $math.min(this._workingEndIndex, this.dataItems.length);\n\n      if (!$type.isNumber(startIndex_1)) {\n        startIndex_1 = 0;\n      }\n\n      if (!$type.isNumber(endIndex)) {\n        endIndex = this.dataItems.length;\n      }\n\n      if (startIndex_1 > 0) {\n        var dataItem_1 = dataItems.getIndex(startIndex_1 - 1);\n        $object.each(dataItem_1.values, function (key, values) {\n          var value = dataItem_1.getActualWorkingValue(key);\n\n          if ($type.isNumber(value)) {\n            // save previous\n            previous_1[key] = value;\n          }\n        });\n      }\n\n      var _loop_1 = function (i) {\n        var dataItem_2 = dataItems.getIndex(i);\n        $object.each(dataItem_2.values, function (key, values) {\n          var value = dataItem_2.getActualWorkingValue(key); //if (i >= startIndex && i <= endIndex) { // do not add to count, sum etc if it is not within start/end index\n\n          if ($type.isNumber(value)) {\n            // count values\n            if (!$type.isNumber(count_1[key])) {\n              count_1[key] = 0;\n            }\n\n            count_1[key]++; // sum values\n\n            if (!$type.isNumber(sum_1[key])) {\n              sum_1[key] = 0;\n            }\n\n            sum_1[key] += value; // open\n\n            if (!$type.isNumber(open_1[key])) {\n              open_1[key] = value;\n            } // close\n\n\n            close_1[key] = value; // low\n\n            if (!$type.isNumber(low_1[key])) {\n              low_1[key] = value;\n            } else {\n              if (low_1[key] > value) {\n                low_1[key] = value;\n              }\n            } // high\n\n\n            if (!$type.isNumber(high_1[key])) {\n              high_1[key] = value;\n            } else {\n              if (high_1[key] < value) {\n                high_1[key] = value;\n              }\n            }\n\n            if (!$type.isNumber(first_1[key])) {\n              first_1[key] = _this.getFirstValue(key, startIndex_1);\n            }\n\n            if (!$type.isNumber(absoluteFirst_1[key])) {\n              absoluteFirst_1[key] = _this.getAbsoluteFirstValue(key);\n            } // change\n\n\n            dataItem_2.setCalculatedValue(key, value - first_1[key], \"change\"); // change from start percent\n            // will fail if first value is 0\n\n            dataItem_2.setCalculatedValue(key, (value - first_1[key]) / first_1[key] * 100, \"changePercent\");\n            dataItem_2.setCalculatedValue(key, value - absoluteFirst_1[key], \"startChange\");\n            dataItem_2.setCalculatedValue(key, (value - absoluteFirst_1[key]) / absoluteFirst_1[key] * 100, \"startChangePercent\"); // previous change\n\n            var prevValue = previous_1[key];\n\n            if (!$type.isNumber(prevValue)) {\n              prevValue = value;\n            }\n\n            dataItem_2.setCalculatedValue(key, value - prevValue, \"previousChange\"); // previous change percent\n\n            dataItem_2.setCalculatedValue(key, (value - prevValue) / prevValue * 100, \"previousChangePercent\"); // save previous\n\n            previous_1[key] = value;\n          }\n        });\n      };\n\n      for (var i = startIndex_1; i < endIndex; i++) {\n        _loop_1(i);\n      }\n\n      if (this.calculatePercent) {\n        var _loop_2 = function (i) {\n          var dataItem_3 = dataItems.getIndex(i);\n          $object.each(dataItem_3.values, function (key) {\n            var ksum = sum_1[key];\n            var value = dataItem_3.getActualWorkingValue(key);\n\n            if ($type.isNumber(value)) {\n              if (ksum > 0) {\n                // this hack is made in order to make it possible to animate single slice to 0\n                // if there is only one slice left, percent value is always 100%, so it won't animate\n                // so we use real value of a slice instead of current value\n                if (value == ksum) {\n                  ksum = dataItem_3.values[key].value;\n                }\n\n                var percent = value / ksum * 100;\n                dataItem_3.setCalculatedValue(key, percent, \"percent\");\n              } else {\n                dataItem_3.setCalculatedValue(key, 0, \"percent\");\n              }\n            }\n          });\n        };\n\n        for (var i = startIndex_1; i < endIndex; i++) {\n          _loop_2(i);\n        }\n      } // calculate one before first (cant do that in cycle, as we don't know open yet\n      // when drawing line chart we should draw line to the invisible data point to the left, otherwise the line will always look like it starts from the selected point\n      // so we do startIndex - 1\n\n\n      if (startIndex_1 > 0) {\n        var zeroItem_1 = dataItems.getIndex(startIndex_1 - 1);\n        $object.each(zeroItem_1.values, function (key) {\n          var value = zeroItem_1.values[key].value; // change\n\n          zeroItem_1.setCalculatedValue(key, value - open_1[key], \"change\"); // change percent\n\n          zeroItem_1.setCalculatedValue(key, (value - open_1[key]) / open_1[key] * 100, \"changePercent\");\n        });\n      } // we save various data like sum, average to dataPoint of the series\n\n\n      var dataItem_4 = this.dataItem;\n      $object.each(dataItem_4.values, function (key) {\n        dataItem_4.setCalculatedValue(key, sum_1[key], \"sum\");\n        dataItem_4.setCalculatedValue(key, sum_1[key] / count_1[key], \"average\");\n        dataItem_4.setCalculatedValue(key, open_1[key], \"open\");\n        dataItem_4.setCalculatedValue(key, close_1[key], \"close\");\n        dataItem_4.setCalculatedValue(key, low_1[key], \"low\");\n        dataItem_4.setCalculatedValue(key, high_1[key], \"high\");\n        dataItem_4.setCalculatedValue(key, count_1[key], \"count\");\n      });\n    }\n  };\n  /**\r\n   * (Re)validates the whole series, effectively causing it to redraw.\r\n   *\r\n   * @ignore Exclude from docs\r\n   */\n\n\n  Series.prototype.validate = function () {\n    $iter.each(this.axisRanges.iterator(), function (axisRange) {\n      //axisRange.contents.disposeChildren(); // not good for columns, as they are reused\n      //\t\t\taxisRange.appendChildren();\n      axisRange.validate();\n    });\n\n    _super.prototype.validate.call(this);\n\n    var bulletsContainer = this.bulletsContainer;\n    bulletsContainer.fill = this.fill;\n    bulletsContainer.stroke = this.stroke;\n    bulletsContainer.x = this.pixelX;\n    bulletsContainer.y = this.pixelY;\n\n    if (this.bulletsContainer.children.length > 0) {\n      if (this._showBullets) {\n        for (var i = 0; i < this.startIndex; i++) {\n          var dataItem = this.dataItems.getIndex(i);\n\n          if (dataItem) {\n            dataItem.bullets.each(function (key, bullet) {\n              bullet.__disabled = true;\n            });\n          }\n        }\n\n        for (var i = this.dataItems.length - 1; i > this.endIndex; i--) {\n          var dataItem = this.dataItems.getIndex(i);\n\n          if (dataItem) {\n            dataItem.bullets.each(function (key, bullet) {\n              bullet.__disabled = true;\n            });\n          }\n        }\n      } else {\n        this.bulletsContainer.children.each(function (bullet) {\n          bullet.__disabled = true;\n        });\n      }\n    }\n\n    this.updateTooltipBounds();\n  };\n  /**\r\n   * @ignore\r\n   */\n\n\n  Series.prototype.updateTooltipBounds = function () {\n    if (this.topParent) {\n      this.tooltip.setBounds({\n        x: 0,\n        y: 0,\n        width: this.topParent.maxWidth,\n        height: this.topParent.maxHeight\n      });\n    }\n  };\n\n  Series.prototype.shouldCreateBullet = function (dataItem, bulletTemplate) {\n    return true;\n  };\n  /**\r\n   * Validates data item's element, effectively redrawing it.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param dataItem  Data item\r\n   */\n\n\n  Series.prototype.validateDataElement = function (dataItem) {\n    var _this = this;\n\n    _super.prototype.validateDataElement.call(this, dataItem);\n\n    if (this._showBullets) {\n      if (!this.isHidden) {\n        this.bulletsContainer.visible = true;\n      }\n\n      this.bullets.each(function (bulletTemplate) {\n        // always better to use the same, this helps to avoid redrawing\n        var bullet = dataItem.bullets.getKey(bulletTemplate.uid);\n\n        if (_this.shouldCreateBullet(dataItem, bulletTemplate)) {\n          if (!bullet) {\n            var disabledField = bulletTemplate.propertyFields.disabled;\n            var dataContext = dataItem.dataContext;\n\n            if (disabledField && dataContext && dataContext[disabledField] === false) {\n              bulletTemplate.applyOnClones = false;\n              bulletTemplate.disabled = false;\n              bullet = bulletTemplate.clone();\n              bulletTemplate.disabled = true;\n              bulletTemplate.applyOnClones = true;\n            } else {\n              bullet = bulletTemplate.clone();\n            }\n\n            bullet.shouldClone = false;\n            dataItem.addSprite(bullet);\n\n            if (!_this.visible || _this.isHiding) {\n              bullet.hide(0);\n            }\n          }\n\n          var currentDataItem = bullet.dataItem;\n\n          if (currentDataItem != dataItem) {\n            // set to undefined in order not to reuse\n            if (currentDataItem) {\n              currentDataItem.bullets.setKey(bulletTemplate.uid, undefined);\n            }\n\n            var readerText_1 = _this.itemReaderText;\n\n            if (bullet instanceof Bullet) {\n              if (!readerText_1) {\n                readerText_1 = \"{\" + bullet.xField + \"}: {\" + bullet.yField + \"}\";\n              }\n\n              if (bullet.isDynamic) {\n                dataItem.events.on(\"workingvaluechanged\", bullet.deepInvalidate, bullet, false); //dataItem.events.on(\"calculatedvaluechanged\", bullet.deepInvalidate, bullet, false);\n\n                _this.dataItem.events.on(\"workingvaluechanged\", bullet.deepInvalidate, bullet, false);\n              }\n\n              bullet.deepInvalidate();\n            } // Add accessibility to bullet\n\n\n            if (bullet.focusable) {\n              bullet.events.on(\"focus\", function (ev) {\n                bullet.readerTitle = _this.populateString(readerText_1, bullet.dataItem);\n              }, undefined, false);\n              bullet.events.on(\"blur\", function (ev) {\n                bullet.readerTitle = \"\";\n              }, undefined, false);\n            }\n\n            if (bullet.hoverable) {\n              bullet.events.on(\"over\", function (ev) {\n                bullet.readerTitle = _this.populateString(readerText_1, bullet.dataItem);\n              }, undefined, false);\n              bullet.events.on(\"out\", function (ev) {\n                bullet.readerTitle = \"\";\n              }, undefined, false);\n            }\n          }\n\n          bullet.parent = _this.bulletsContainer;\n          dataItem.bullets.setKey(bulletTemplate.uid, bullet); // pass max w/h so we'd know if we should show/hide somethings\n\n          bullet.maxWidth = dataItem.itemWidth;\n          bullet.maxHeight = dataItem.itemHeight;\n          bullet.__disabled = false;\n\n          _this.positionBullet(bullet);\n        }\n      });\n    } else {\n      this.bulletsContainer.visible = false;\n    }\n  };\n  /**\r\n   * [handleDataItemWorkingValueChange description]\r\n   *\r\n   * @ignore Exclude from docs\r\n   */\n\n\n  Series.prototype.handleDataItemWorkingValueChange = function (dataItem, name) {\n    if (!this.dataRangeInvalid) {\n      this.invalidateProcessedData();\n    }\n  };\n\n  Object.defineProperty(Series.prototype, \"ignoreMinMax\", {\n    /**\r\n     * @return Exclude from calculations?\r\n     */\n    get: function () {\n      return this._ignoreMinMax;\n    },\n\n    /**\r\n     * Should this series excluded from the axis scale calculations?\r\n     *\r\n     * @default false\r\n     * @param value  Exclude from calculations?\r\n     */\n    set: function (value) {\n      this._ignoreMinMax = value;\n      this.invalidateDataItems();\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\r\n   * Create a mask for the series.\r\n   *\r\n   * @ignore Exclude from docs\r\n   */\n\n  Series.prototype.createMask = function () {// A placeholder method for extending classes to override.\n  };\n  /**\r\n   * Process axis range after it has been added to the list.\r\n   *\r\n   * @param event  Event\r\n   */\n\n\n  Series.prototype.processAxisRange = function (event) {\n    // create container if not existing\n    if (!this.rangesContainer) {\n      this.rangesContainer = this.createChild(Container);\n      this.rangesContainer.shouldClone = false;\n      this.rangesContainer.isMeasured = false;\n    }\n\n    var axisRange = event.newValue;\n\n    if (axisRange) {\n      axisRange.contents.parent = this.rangesContainer;\n      axisRange.isRange = true;\n      axisRange.events.on(\"valuechanged\", this.invalidateDataItems, this, false);\n    }\n  };\n  /**\r\n   * [getAxisField description]\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @todo Description\r\n   * @param axis  [description]\r\n   * @return [description]\r\n   */\n\n\n  Series.prototype.getAxisField = function (axis) {\n    return;\n  };\n  /**\r\n   * Shows the tooltip at specific position.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param xPosition  X\r\n   * @param yPosition  Y\r\n   */\n\n\n  Series.prototype.showTooltipAtPosition = function (xPosition, yPosition) {// Placeholder method for extending classes to override.\n  };\n\n  Object.defineProperty(Series.prototype, \"minBulletDistance\", {\n    /**\r\n     * @return Distance (px)\r\n     */\n    get: function () {\n      return this.getPropertyValue(\"minBulletDistance\");\n    },\n\n    /**\r\n     * Minimal distance between data points in pixels.\r\n     *\r\n     * If distance gets smaller than this, bullets are turned off to avoid\r\n     * overlapping.\r\n     *\r\n     * `0` (zero) disables this behavior.\r\n     *\r\n     * IMPORTANT: This setting will work only when Series' base axis\r\n     * is [[CategoryAxis]] or [[DateAxis]]. If base axis is [[ValueAxis]] the\r\n     * setting will be ignored, because it would be a huge overhead to measure\r\n     * distance between each and every bullet.\r\n     *\r\n     * @default 0\r\n     * @param value  Distance (px)\r\n     */\n    set: function (value) {\n      this.setPropertyValue(\"minBulletDistance\", value, true);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Series.prototype, \"bullets\", {\n    /**\r\n     * A list of bullets that will be added to each and every items in the\r\n     * series.\r\n     *\r\n     * You can push any object that is a descendant of a [[Sprite]] here. All\r\n     * items added to this list will be copied and used as a bullet on all data\r\n     * items, including their properties, events, etc.\r\n     *\r\n     * @see {@link https://www.amcharts.com/docs/v4/concepts/bullets/} for more info about the concept of Bullets\r\n     * @return List of bullets.\r\n     */\n    get: function () {\n      if (!this._bullets) {\n        this._bullets = new ListTemplate(new Bullet());\n        this._bullets.template.virtualParent = this;\n\n        this._bullets.events.on(\"inserted\", this.processBullet, this, false);\n\n        this._bullets.events.on(\"removed\", this.removeBullet, this, false);\n\n        this._disposers.push(new ListDisposer(this._bullets));\n\n        this._disposers.push(this._bullets.template);\n      }\n\n      return this._bullets;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\r\n   * Binds related legend data item's visual settings to this series' visual\r\n   * settings.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param marker  Legend item container\r\n   */\n\n  Series.prototype.createLegendMarker = function (marker) {// This is a placeholder method for extending classes to override.\n  };\n\n  Object.defineProperty(Series.prototype, \"hiddenInLegend\", {\n    /**\r\n     * @return Hidden in legend?\r\n     */\n    get: function () {\n      return this.getPropertyValue(\"hiddenInLegend\");\n    },\n\n    /**\r\n     * Should the series be hidden in legend?\r\n     *\r\n     * @param value Hidden in legend?\r\n     */\n    set: function (value) {\n      if (this.setPropertyValue(\"hiddenInLegend\", value)) {\n        if (this.chart) {\n          this.chart.feedLegend();\n        }\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Series.prototype, \"name\", {\n    /**\r\n     * @return Name\r\n     */\n    get: function () {\n      return this.getPropertyValue(\"name\");\n    },\n\n    /**\r\n     * Series' name.\r\n     *\r\n     * @param value  Name\r\n     */\n    set: function (value) {\n      this.setPropertyValue(\"name\", value);\n      var legendDataItem = this.legendDataItem;\n\n      if (legendDataItem) {\n        legendDataItem.component.invalidate();\n        legendDataItem.component.invalidateRawData();\n      }\n\n      this.readerTitle = value;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Series.prototype, \"itemReaderText\", {\n    /**\r\n     * @return Screen reader text template\r\n     */\n    get: function () {\n      // Get explicitly set reader text\n      var readerText = this._itemReaderText; // Not set? Let's try something else\n\n      if (!readerText) {\n        // Tooltip text?\n        if (this.tooltipText) {\n          readerText = $utils.plainText(this.tooltipText);\n        } else if (this.tooltipHTML) {\n          readerText = $utils.plainText(this.tooltipHTML);\n        }\n      }\n\n      if (!this._adapterO) {\n        return readerText;\n      } else {\n        return this._adapterO.apply(\"itemReaderText\", readerText);\n      }\n    },\n\n    /**\r\n     * Screen reader text to be applied to each individual data item, such\r\n     * as bullets, columns or slices.\r\n     *\r\n     * The template can contain field reference meta codes, i.e. `{dateX}`,\r\n     * `{valueY}`, etc.\r\n     *\r\n     * Any text formatting options, e.g. `[bold]` will be ignored.\r\n     *\r\n     * @param value Screen reader text template\r\n     */\n    set: function (value) {\n      this._itemReaderText = value;\n      this._itemReaderTextChanged = true;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\r\n   * Returns if number of data items in the series are beyond non-focusable\r\n   * count and should not be available for TAB-through.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @return Items focusable?\r\n   */\n\n  Series.prototype.itemsFocusable = function () {\n    return this.dataItems.length >= this.skipFocusThreshold ? false : true;\n  };\n\n  Object.defineProperty(Series.prototype, \"legendDataItem\", {\n    /**\r\n     * @return Data item\r\n     */\n    get: function () {\n      return this._legendDataItem;\n    },\n\n    /**\r\n     * Legend data item that corresponds to this series.\r\n     *\r\n     * @param value  Data item\r\n     */\n    set: function (value) {\n      this._legendDataItem = value;\n\n      this._legendDataItem.itemContainer.deepInvalidate();\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\r\n   * Updates corresponding legend data item with current values.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param dataItem  Data item\r\n   */\n\n  Series.prototype.updateLegendValue = function (dataItem, notRange) {\n    // if this series has legend item\n    if (this.legendDataItem) {\n      var legendSettings = this.legendSettings;\n      var legendDataItem = this.legendDataItem;\n      var label = legendDataItem.label;\n      var valueLabel = legendDataItem.valueLabel; // update legend\n\n      if (dataItem || notRange) {\n        if (valueLabel) {\n          if (legendSettings.itemValueText) {\n            valueLabel.text = legendSettings.itemValueText;\n          }\n\n          valueLabel.dataItem = dataItem;\n        }\n\n        if (label) {\n          if (legendSettings.itemLabelText) {\n            label.text = legendSettings.itemLabelText;\n          }\n\n          label.dataItem = dataItem;\n        }\n      } else {\n        if (label) {\n          // if itemLabelText is set, means we have to reset label even if labelText is not set\n          if (legendSettings.labelText || legendSettings.itemLabelText != undefined) {\n            label.text = legendSettings.labelText;\n          }\n\n          label.dataItem = this.dataItem;\n        }\n\n        if (valueLabel) {\n          if (legendSettings.valueText || legendSettings.itemValueText != undefined) {\n            valueLabel.text = legendSettings.valueText;\n          }\n\n          valueLabel.dataItem = this.dataItem;\n        }\n      }\n    }\n  };\n  /**\r\n   * Copies all properties from another instance of [[Series]].\r\n   *\r\n   * @param source  Source series\r\n   */\n\n\n  Series.prototype.copyFrom = function (source) {\n    this.bullets.copyFrom(source.bullets);\n    this.bulletsContainer.copyFrom(source.bulletsContainer);\n    this.calculatePercent = source.calculatePercent;\n    this.simplifiedProcessing = source.simplifiedProcessing;\n\n    _super.prototype.copyFrom.call(this, source);\n  };\n  /**\r\n   * Displays a modal or console message with error, and halts any further\r\n   * processing of this element.\r\n   *\r\n   * @param e Error\r\n   */\n\n\n  Series.prototype.raiseCriticalError = function (e) {\n    if (this._chart && this._chart.modal) {\n      this._chart.modal.content = this._chart.adapter.apply(\"criticalError\", e).message;\n      this._chart.modal.closable = false;\n\n      this._chart.modal.open();\n\n      this._chart.disabled = true;\n    }\n\n    if (options.verbose) {\n      console.log(e);\n    }\n  };\n  /**\r\n   * Applies filters to the element.\r\n   *\r\n   * @ignore Exclude from docs\r\n   */\n\n\n  Series.prototype.applyFilters = function () {\n    var _this = this;\n\n    _super.prototype.applyFilters.call(this);\n\n    this.bulletsContainer.filters.clear(); // copyFrom of a list copies, does not clone\n\n    $iter.each(this.filters.iterator(), function (filter) {\n      _this.bulletsContainer.filters.push(filter.clone());\n    });\n  };\n\n  Object.defineProperty(Series.prototype, \"heatRules\", {\n    /**\r\n     * A list of heat rules to apply to series' elements based on the value\r\n     * of the data item.\r\n     *\r\n     * Heat rules can be any \"numeric\" (including `Color`) property, and can also\r\n     * be applied to child objects of series, like columns, bullets, etc.\r\n     *\r\n     * E.g.:\r\n     *\r\n     * ```TypeScript\r\n     * series.heatRules.push({\r\n     *  \"target\": series.columns.template,\r\n     *  \"property\": \"fill\",\r\n     *  \"min\": am4core.color(\"#F5DBCB\"),\r\n     *  \"max\": am4core.color(\"#ED7B84\"),\r\n     *  \"dataField\": \"valueY\"\r\n     *});\r\n     *```\r\n     * ```Javacript\r\n     * series.heatRules.push({\r\n     *  \"target\": series.columns.template,\r\n     *  \"property\": \"fill\",\r\n     *  \"min\": am4core.color(\"#F5DBCB\"),\r\n     *  \"max\": am4core.color(\"#ED7B84\"),\r\n     *  \"dataField\": \"valueY\"\r\n     *});\r\n     *```\r\n     *```JSON\r\n     *{\r\n     *  // ...\r\n     *  \"series\": [{\r\n     *    \"type\": \"ColumnSeries\",\r\n     *    \"heatRules\": [{\r\n     *      \"target\": \"columns.template\",\r\n     *      \"property\": \"fill\",\r\n     *      \"min\": \"#F5DBCB\",\r\n     *      \"max\": \"#ED7B84\",\r\n     *      \"dataField\": \"valueY\"\r\n     *    }]\r\n     *  }]\r\n     *}\r\n     *```\r\n     *\r\n     * @see {@link https://www.amcharts.com/docs/v4/concepts/series/#Heat_maps} for more about heat rules\r\n     * @return  Heat rules\r\n     */\n    get: function () {\n      var _this = this;\n\n      if (!this._heatRules) {\n        this._heatRules = new List();\n\n        this._heatRules.events.on(\"inserted\", function (event) {\n          var heatRule = event.newValue;\n          var target = heatRule.target;\n\n          if (target) {\n            var dataField_1 = heatRule.dataField;\n\n            if (!$type.hasValue(dataField_1)) {\n              dataField_1 = \"value\";\n            }\n\n            var min_1 = heatRule.min;\n            var max_1 = heatRule.max;\n            var seriesDataItem_1 = _this.dataItem;\n            var property_1 = heatRule.property;\n            var minValue = $type.toNumber(heatRule.minValue);\n            var maxValue = $type.toNumber(heatRule.maxValue);\n\n            if (!$type.isNumber(minValue) && !$type.isNumber(maxValue)) {\n              _this.dataItem.events.on(\"calculatedvaluechanged\", function (event) {\n                if (event.property == dataField_1) {\n                  $iter.each(_this.dataItems.iterator(), function (dataItem) {\n                    var foundSprite = false;\n                    $array.each(dataItem.sprites, function (sprite) {\n                      if (sprite.clonedFrom == target) {\n                        var anySprite = sprite;\n                        anySprite[property_1] = anySprite[property_1];\n                        foundSprite = true;\n                      }\n                    });\n\n                    if (!foundSprite) {\n                      $array.each(dataItem.sprites, function (sprite) {\n                        if (sprite instanceof Container) {\n                          $iter.each(sprite.children.iterator(), function (child) {\n                            if (child.className == target.className) {\n                              var anyChild = child;\n                              anyChild[property_1] = anyChild[property_1];\n                            } // giveup here\n                            else if (child instanceof Container) {\n                                child.deepInvalidate();\n                              }\n                          });\n                        }\n                      });\n                    }\n                  });\n                }\n              });\n            }\n\n            _this.dataItems.template.events.on(\"workingvaluechanged\", function (event) {\n              if (event.property == dataField_1) {\n                var dataItem = event.target;\n                var foundSprite_1 = false;\n                $array.each(dataItem.sprites, function (sprite) {\n                  if (sprite.clonedFrom == target) {\n                    var anySprite = sprite;\n                    anySprite[property_1] = anySprite[property_1];\n                    foundSprite_1 = true;\n                  }\n                });\n\n                if (!foundSprite_1) {\n                  $array.each(dataItem.sprites, function (sprite) {\n                    if (sprite instanceof Container) {\n                      $iter.each(sprite.children.iterator(), function (child) {\n                        if (child.className == target.className) {\n                          var anyChild = child;\n                          anyChild[property_1] = anyChild[property_1];\n                        } // givup here\n                        else if (child instanceof Container) {\n                            child.deepInvalidate();\n                          }\n                      });\n                    }\n                  });\n                }\n              }\n            });\n\n            target.adapter.add(property_1, function (value, ruleTarget, property) {\n              var minValue = $type.toNumber(heatRule.minValue);\n              var maxValue = $type.toNumber(heatRule.maxValue);\n\n              if (ruleTarget instanceof Sprite) {\n                var anySprite = ruleTarget;\n                var propertyField = anySprite.propertyFields[property];\n\n                if (propertyField && ruleTarget.dataItem) {\n                  var dataContext = ruleTarget.dataItem.dataContext;\n\n                  if (dataContext && $type.hasValue(dataContext[propertyField])) {\n                    return value;\n                  }\n                }\n              }\n\n              var dataItem = ruleTarget.dataItem;\n\n              if (!$type.isNumber(minValue)) {\n                minValue = seriesDataItem_1.values[dataField_1].low;\n              }\n\n              if (!$type.isNumber(maxValue)) {\n                maxValue = seriesDataItem_1.values[dataField_1].high;\n              }\n\n              if (dataItem) {\n                var fieldValues = dataItem.values[dataField_1];\n\n                if (fieldValues) {\n                  var workingValue = dataItem.getActualWorkingValue(dataField_1);\n\n                  if ($type.hasValue(min_1) && $type.hasValue(max_1) && $type.isNumber(minValue) && $type.isNumber(maxValue) && $type.isNumber(workingValue)) {\n                    var percent = (workingValue - minValue) / (maxValue - minValue);\n\n                    if ($type.isNumber(workingValue) && !$type.isNumber(percent)) {\n                      percent = 0.5;\n                    } // fixes problems if all values are the same\n\n\n                    if ($type.isNumber(min_1)) {\n                      return min_1 + (max_1 - min_1) * percent;\n                    } else if (min_1 instanceof Color) {\n                      return new Color($colors.interpolate(min_1.rgb, max_1.rgb, percent));\n                    }\n                  }\n                }\n              }\n\n              return value;\n            });\n          }\n        });\n      }\n\n      return this._heatRules;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\r\n   * Processes JSON-based config before it is applied to the object.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param config  Config\r\n   */\n\n  Series.prototype.processConfig = function (config) {\n    var heatRules;\n\n    if (config) {\n      // Set up bullets\n      if ($type.hasValue(config.bullets) && $type.isArray(config.bullets)) {\n        for (var i = 0, len = config.bullets.length; i < len; i++) {\n          var bullets = config.bullets[i];\n\n          if (!$type.hasValue(bullets.type)) {\n            bullets.type = \"Bullet\";\n          }\n        }\n      } // Let's take heatRules out of the config, so that we can process\n      // them later, when bullets are already there\n\n\n      if ($type.hasValue(config.heatRules) && $type.isArray(config.heatRules)) {\n        heatRules = config.heatRules;\n        delete config.heatRules;\n      }\n    }\n\n    _super.prototype.processConfig.call(this, config); // Process heat rules again, when all other elements are ready\n\n\n    if (heatRules) {\n      for (var i = 0, len = heatRules.length; i < len; i++) {\n        var rule = heatRules[i]; // Resolve target\n\n        var target = this;\n\n        if ($type.hasValue(rule.target) && $type.isString(rule.target)) {\n          // Check if we can find this element by id\n          if (this.map.hasKey(rule.target)) {\n            target = this.map.getKey(rule.target);\n          } else {\n            var parts = rule.target.split(\".\");\n\n            for (var x = 0; x < parts.length; x++) {\n              if (target instanceof List) {\n                var listitem = target.getIndex($type.toNumber(parts[x]));\n\n                if (!listitem) {\n                  target = target[parts[x]];\n                } else {\n                  target = listitem;\n                }\n              } else {\n                target = target[parts[x]];\n              }\n            }\n          }\n        }\n\n        rule.target = target; // Resolve colors and percents\n\n        if ($type.hasValue(rule.min)) {\n          rule.min = this.maybeColorOrPercent(rule.min);\n        }\n\n        if ($type.hasValue(rule.max)) {\n          rule.max = this.maybeColorOrPercent(rule.max);\n        }\n      }\n\n      _super.prototype.processConfig.call(this, {\n        heatRules: heatRules\n      });\n    }\n  };\n  /**\r\n   * Returns visibility value\r\n   * @ignore\r\n   */\n\n  /*\r\n      protected getVisibility(): boolean {\r\n          let hidden = this.getPropertyValue(\"hidden\");\r\n          if (hidden) {\r\n              return false;\r\n          }\r\n          else {\r\n              return super.getVisibility();\r\n          }\r\n      }*/\n\n  /**\r\n   * This function is used to sort element's JSON config properties, so that\r\n   * some properties that absolutely need to be processed last, can be put at\r\n   * the end.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param a  Element 1\r\n   * @param b  Element 2\r\n   * @return Sorting number\r\n   */\n\n\n  Series.prototype.configOrder = function (a, b) {\n    if (a == b) {\n      return 0;\n    } // Must come last\n    else if (a == \"heatRules\") {\n        return 1;\n      } else if (b == \"heatRules\") {\n        return -1;\n      } else {\n        return _super.prototype.configOrder.call(this, a, b);\n      }\n  };\n  /**\r\n   * Sets `visibility` property:\r\n   *\r\n   * * `true` - visible\r\n   * * `false` - hidden\r\n   *\r\n   * @param value  true - visible, false - hidden\r\n   * @return Current visibility\r\n   */\n\n\n  Series.prototype.setVisibility = function (value) {\n    _super.prototype.setVisibility.call(this, value);\n\n    this.bulletsContainer.visible = value;\n  };\n\n  return Series;\n}(Component);\n\nexport { Series };\n/**\r\n * Register class, so that it can be instantiated using its name from\r\n * anywhere.\r\n *\r\n * @ignore\r\n */\n\nregistry.registeredClasses[\"Series\"] = Series;\nregistry.registeredClasses[\"SeriesDataItem\"] = SeriesDataItem;","map":null,"metadata":{},"sourceType":"module"}