{"ast":null,"code":"/**\r\n * Module, defining Axis Renderer for vertical axes.\r\n */\nimport * as tslib_1 from \"tslib\";\n/**\r\n * ============================================================================\r\n * IMPORTS\r\n * ============================================================================\r\n * @hidden\r\n */\n\nimport { AxisRenderer } from \"./AxisRenderer\";\nimport { WavedLine } from \"../../core/elements/WavedLine\";\nimport { WavedRectangle } from \"../../core/elements/WavedRectangle\";\nimport { registry } from \"../../core/Registry\";\nimport { percent, Percent } from \"../../core/utils/Percent\";\nimport * as $math from \"../../core/utils/Math\";\nimport * as $path from \"../../core/rendering/Path\";\nimport * as $utils from \"../../core/utils/Utils\";\nimport * as $type from \"../../core/utils/Type\";\nimport { defaultRules, ResponsiveBreakpoints } from \"../../core/utils/Responsive\";\nimport { AxisBullet } from \"./AxisBullet\";\n/**\r\n * ============================================================================\r\n * MAIN CLASS\r\n * ============================================================================\r\n * @hidden\r\n */\n\n/**\r\n * A renderer for vertical axis.\r\n *\r\n * @see {@link IAxisRendererYEvents} for a list of available events\r\n * @see {@link IAxisRendererYAdapters} for a list of available Adapters\r\n */\n\nvar AxisRendererY =\n/** @class */\nfunction (_super) {\n  tslib_1.__extends(AxisRendererY, _super);\n  /**\r\n   * Constructor.\r\n   *\r\n   * @param axis Related axis\r\n   */\n\n\n  function AxisRendererY() {\n    var _this = _super.call(this) || this;\n\n    _this.className = \"AxisRendererY\";\n    _this.minGridDistance = 40;\n    _this.opposite = false;\n    _this.height = percent(100);\n    _this.labels.template.verticalCenter = \"middle\";\n\n    _this.applyTheme();\n\n    return _this;\n  }\n  /**\r\n  * @ignore\r\n  */\n\n\n  AxisRendererY.prototype.setAxis = function (axis) {\n    _super.prototype.setAxis.call(this, axis);\n\n    axis.layout = \"horizontal\";\n  };\n  /**\r\n   * @ignore\r\n   */\n\n\n  AxisRendererY.prototype.updateGridContainer = function () {\n    var axis = this.axis;\n\n    if (axis) {\n      var gridContainer = this.gridContainer;\n      gridContainer.y = axis.pixelY;\n      gridContainer.height = axis.axisLength;\n    }\n  };\n  /**\r\n   * @ignore\r\n   */\n\n\n  AxisRendererY.prototype.toAxisPosition = function (value) {\n    var axis = this.axis;\n\n    if (axis) {\n      var inversedPosition = 1 - value;\n      var relativePositionSprite = axis.relativePositionSprite;\n      var y = axis.pixelY;\n\n      if (relativePositionSprite) {\n        y = $utils.spritePointToSprite({\n          x: 0,\n          y: this.pixelY\n        }, this.parent, relativePositionSprite).y;\n      } else {\n        relativePositionSprite = axis.parent;\n      }\n\n      if (relativePositionSprite) {\n        var relativeY = y / relativePositionSprite.innerHeight;\n        var relativeHeight = axis.axisLength / relativePositionSprite.innerHeight;\n        return 1 - (inversedPosition - relativeY) / relativeHeight;\n      }\n    }\n\n    return value;\n  };\n  /**\r\n   * Called when rendered is attached to an Axis, as well as a property of\r\n   * Axis that might affect the appearance is updated.\r\n   *\r\n   * E.g. `axis.opposite`, `axis.inside`, etc.\r\n   *\r\n   * This method is called **before** draw, so that any related setting\r\n   * changed in this method can be changed.\r\n   *\r\n   * @todo Description (review)\r\n   * @ignore Exclude from docs\r\n   */\n\n\n  AxisRendererY.prototype.processRenderer = function () {\n    _super.prototype.processRenderer.call(this);\n\n    var axis = this.axis;\n\n    if (axis) {\n      var title = axis.title;\n      title.valign = \"middle\";\n\n      if (!(axis.height instanceof Percent)) {\n        axis.height = percent(100);\n      }\n\n      if (this.opposite) {\n        title.rotation = 90;\n        this.line.toBack();\n        title.toFront();\n      } else {\n        title.rotation = -90;\n        title.toBack();\n        this.line.toFront();\n      }\n    }\n  };\n  /**\r\n   * Updates some of the Axis tooltip's visual properties, related to\r\n   * rendering of the Axis.\r\n   *\r\n   * @todo Description (review)\r\n   * @ignore Exclude from docs\r\n   */\n\n\n  AxisRendererY.prototype.updateTooltip = function () {\n    var axis = this.axis;\n\n    if (axis) {\n      var bigNum = 2000;\n      var bbx = 0;\n      var bby = 0;\n      var bbw = bigNum;\n      var bbh = this.axisLength; // right\n\n      if (this.opposite) {\n        if (this.inside) {\n          bbx = -bigNum;\n          bbw = bigNum;\n        }\n      } // left\n      else {\n          if (!this.inside) {\n            bbx = -bigNum;\n            bbw = bigNum;\n          }\n        }\n\n      this.axis.updateTooltip(\"horizontal\", {\n        x: bbx,\n        y: bby,\n        width: bbw,\n        height: bbh\n      });\n    }\n  };\n\n  Object.defineProperty(AxisRendererY.prototype, \"axisLength\", {\n    /**\r\n     * Returns actual length of the Axis, in pixels.\r\n     *\r\n     * @return Length (px)\r\n     */\n    get: function () {\n      var axis = this.axis;\n      return axis.measuredHeight - axis.pixelPaddingTop - axis.pixelPaddingBottom || 0;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\r\n   * Converts relative position on axis to point coordinates.\r\n   *\r\n   * @param position  Position (0-1)\r\n   * @param position2  Position (0-1) Position on the second axis\r\n   * @return Point\r\n   */\n\n  AxisRendererY.prototype.positionToPoint = function (position, position2) {\n    return {\n      x: 0,\n      y: this.positionToCoordinate(position)\n    };\n  };\n  /**\r\n   * Converts a point at specific coordinates to a relative position (0-1)\r\n   * on the axis.\r\n   *\r\n   * @param point  Point\r\n   * @return Position (0-1)\r\n   */\n\n\n  AxisRendererY.prototype.pointToPosition = function (point) {\n    return this.coordinateToPosition(point.y, point.x);\n  };\n  /**\r\n   * [getPositionRangePath description]\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @todo Description\r\n   * @param startPosition  Starting position\r\n   * @param endPosition    End position\r\n   * @return SVG path\r\n   */\n\n\n  AxisRendererY.prototype.getPositionRangePath = function (startPosition, endPosition) {\n    var y1 = $math.fitToRange(this.positionToCoordinate(startPosition), 0, this.axisLength);\n    var y2 = $math.fitToRange(this.positionToCoordinate(endPosition), 0, this.axisLength);\n    var h = Math.abs(y2 - y1);\n    var w = this.getWidth();\n    var y = Math.min(y1, y2);\n    var x = 0;\n    return $path.rectToPath({\n      x: x,\n      y: y,\n      width: w,\n      height: h\n    }, true);\n  };\n  /**\r\n   * Updates and positions a grid element.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param grid         Grid element\r\n   * @param position     Starting position\r\n   * @param endPosition  End position\r\n   */\n\n\n  AxisRendererY.prototype.updateGridElement = function (grid, position, endPosition) {\n    position = position + (endPosition - position) * grid.location;\n    var point = this.positionToPoint(position); //\tpoint.y = $utils.spritePointToSprite({ x: 0, y: point.y }, this, this.gridContainer).y;\n\n    grid.path = $path.moveTo({\n      x: 0,\n      y: 0\n    }) + $path.lineTo({\n      x: this.getWidth(),\n      y: 0\n    });\n    this.positionItem(grid, point);\n    this.toggleVisibility(grid, position, 0, 1);\n  };\n  /**\r\n   * Updates and positions a tick element.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param tick         Tick element\r\n   * @param position     Starting position\r\n   * @param endPosition  End position\r\n   */\n\n\n  AxisRendererY.prototype.updateTickElement = function (tick, position, endPosition) {\n    position = position + (endPosition - position) * tick.location;\n    var point = this.positionToPoint(position);\n    var tickLength = tick.length;\n\n    try {\n      $utils.used(this.axis.title.measuredWidth);\n    } catch (_a) {// void\n    }\n\n    point.x = $utils.spritePointToSprite({\n      x: this.line.pixelX,\n      y: 0\n    }, this.line.parent, this.gridContainer).x;\n\n    if (!this.opposite) {\n      tickLength *= tick.inside ? 1 : -1;\n    } else {\n      tickLength *= tick.inside ? -1 : 1;\n    }\n\n    tick.path = $path.moveTo({\n      x: 0,\n      y: 0\n    }) + $path.lineTo({\n      x: tickLength,\n      y: 0\n    });\n    this.positionItem(tick, point);\n    this.toggleVisibility(tick, position, 0, 1);\n  };\n  /**\r\n   * Updates and positions the axis line element.\r\n   *\r\n   * @ignore Exclude from docs\r\n   */\n\n\n  AxisRendererY.prototype.updateAxisLine = function () {\n    this.line.path = $path.moveTo({\n      x: 0,\n      y: 0\n    }) + $path.lineTo({\n      x: 0,\n      y: this.axisLength\n    });\n  };\n  /**\r\n   * Updates and positions the base grid element.\r\n   *\r\n   * @ignore Exclude from docs\r\n   */\n\n\n  AxisRendererY.prototype.updateBaseGridElement = function () {\n    _super.prototype.updateBaseGridElement.call(this);\n\n    var axis = this.axis;\n    var w = this.getWidth();\n    var h = this.axisLength;\n    var y = axis.basePoint.y;\n    var baseGrid = this.baseGrid;\n\n    if (y < -0.2 || y > h + 0.2) {\n      baseGrid.hide(0);\n    } else {\n      var x = $utils.spritePointToSprite({\n        x: 0,\n        y: 0\n      }, this.gridContainer, baseGrid.parent).x;\n      baseGrid.path = $path.moveTo({\n        x: 0,\n        y: 0\n      }) + $path.lineTo({\n        x: w,\n        y: 0\n      });\n      baseGrid.moveTo({\n        x: x,\n        y: y\n      });\n      baseGrid.show(0);\n    }\n  };\n  /**\r\n   * Updates and positions a label element.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param label        Label element\r\n   * @param position     Starting position\r\n   * @param endPosition  Ending position\r\n   */\n\n\n  AxisRendererY.prototype.updateLabelElement = function (label, position, endPosition, location) {\n    if (!$type.hasValue(location)) {\n      location = label.location;\n    }\n\n    position = position + (endPosition - position) * location;\n    label.isMeasured = !label.inside;\n    var point = this.positionToPoint(position);\n    var horizontalCenter;\n    var deltaX = 0;\n    var maxWidth = this.gridContainer.maxWidth;\n\n    if (this.opposite) {\n      if (label.inside) {\n        horizontalCenter = \"right\";\n\n        if (label.align == \"left\") {\n          deltaX = -maxWidth;\n          horizontalCenter = \"left\";\n        }\n\n        if (label.align == \"center\") {\n          deltaX = -maxWidth / 2;\n          horizontalCenter = \"middle\";\n        }\n      } else {\n        horizontalCenter = \"left\";\n      }\n\n      point.x = 0 + deltaX;\n    } else {\n      if (label.inside) {\n        horizontalCenter = \"left\";\n\n        if (label.align == \"right\") {\n          deltaX = maxWidth;\n          horizontalCenter = \"right\";\n        }\n\n        if (label.align == \"center\") {\n          deltaX = maxWidth / 2;\n          horizontalCenter = \"middle\";\n        }\n      } else {\n        horizontalCenter = \"right\";\n      }\n\n      point.x = this.measuredWidth + deltaX;\n    }\n\n    if (label.rotation == 0) {\n      // Apply fuzzy logic to verticalCenter only if labels are not rotated\n      label.horizontalCenter = horizontalCenter;\n    }\n\n    this.positionItem(label, point);\n    this.toggleVisibility(label, position, this.minLabelPosition, this.maxLabelPosition);\n  };\n  /**\r\n   * Updates and positions an axis break element.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param axisBreak Break element\r\n   */\n\n\n  AxisRendererY.prototype.updateBreakElement = function (axisBreak) {\n    _super.prototype.updateBreakElement.call(this, axisBreak);\n\n    var startLine = axisBreak.startLine;\n    var endLine = axisBreak.endLine;\n    var fillShape = axisBreak.fillShape;\n    var startPoint = axisBreak.startPoint;\n    var endPoint = axisBreak.endPoint;\n    var x1 = axisBreak.pixelMarginLeft;\n    var x2 = this.getWidth() - axisBreak.pixelMarginLeft - axisBreak.pixelMarginRight;\n    startPoint.y = $math.fitToRange(startPoint.y, -1, this.axisLength + 1);\n    endPoint.y = $math.fitToRange(endPoint.y, -1, this.axisLength + 1);\n\n    if (startPoint.y == endPoint.y && (startPoint.y < 0 || startPoint.y > this.axisLength)) {\n      axisBreak.fillShape.__disabled = true;\n    } else {\n      axisBreak.fillShape.__disabled = false;\n    }\n\n    var w = Math.abs(x2 - x1);\n    startLine.x = x1;\n    startLine.height = 0;\n    startLine.width = w;\n    endLine.x = x1;\n    endLine.height = 0;\n    endLine.width = w;\n    fillShape.width = w;\n    fillShape.height = Math.abs(endPoint.y - startPoint.y);\n    fillShape.x = x1;\n    fillShape.y = endPoint.y;\n  };\n  /**\r\n   * Creates visual elements for and axis break.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param axisBreak Axis break\r\n   */\n\n\n  AxisRendererY.prototype.createBreakSprites = function (axisBreak) {\n    axisBreak.startLine = new WavedLine();\n    axisBreak.endLine = new WavedLine();\n    var wavedRectangle = new WavedRectangle();\n    wavedRectangle.setWavedSides(true, false, true, false);\n    axisBreak.fillShape = wavedRectangle;\n  };\n  /**\r\n   * Converts a position on the axis to a coordinate in pixels.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param position  Position (0-1)\r\n   * @return Coordinate (px)\r\n   */\n\n\n  AxisRendererY.prototype.positionToCoordinate = function (position) {\n    var coordinate;\n    var axis = this.axis;\n    var axisFullLength = axis.axisFullLength;\n\n    if (!axis.renderer.inversed) {\n      coordinate = (axis.end - position) * axisFullLength;\n    } else {\n      coordinate = (position - axis.start) * axisFullLength;\n    }\n\n    return $math.round(coordinate, 1);\n  };\n  /**\r\n   * Updates and positions axis bullets.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param bullet       AxisBullet element\r\n   * @param position     Starting position\r\n   * @param endPosition  End position\r\n   */\n\n\n  AxisRendererY.prototype.updateBullet = function (bullet, position, endPosition) {\n    var location = 0.5;\n\n    if (bullet instanceof AxisBullet) {\n      location = bullet.location;\n    }\n\n    position = position + (endPosition - position) * location;\n    var point = this.positionToPoint(position);\n    point.x = $utils.spritePointToSprite({\n      x: this.line.pixelX,\n      y: 0\n    }, this.line.parent, this.gridContainer).x;\n    this.positionItem(bullet, point);\n    this.toggleVisibility(bullet, position, 0, 1);\n  };\n\n  return AxisRendererY;\n}(AxisRenderer);\n\nexport { AxisRendererY };\n/**\r\n * Register class in system, so that it can be instantiated using its name from\r\n * anywhere.\r\n *\r\n * @ignore\r\n */\n\nregistry.registeredClasses[\"AxisRendererY\"] = AxisRendererY;\n/**\r\n * Add default responsive rules\r\n */\n\n/**\r\n * Put labels inside plot area.\r\n * Disable first and last labels.\r\n */\n\ndefaultRules.push({\n  relevant: ResponsiveBreakpoints.widthS,\n  state: function (target, stateId) {\n    if (target instanceof AxisRendererY) {\n      var state = target.states.create(stateId);\n      state.properties.inside = true;\n      state.properties.maxLabelPosition = 0.9;\n      state.properties.minLabelPosition = 0.1;\n      return state;\n    }\n\n    return null;\n  }\n});\n/**\r\n * Disable labels altogather on very small charts\r\n */\n\ndefaultRules.push({\n  relevant: ResponsiveBreakpoints.widthXS,\n  state: function (target, stateId) {\n    if (target instanceof AxisRendererY) {\n      var state = target.states.create(stateId);\n      state.properties.disabled = true;\n      return state;\n    }\n\n    return null;\n  }\n});","map":null,"metadata":{},"sourceType":"module"}