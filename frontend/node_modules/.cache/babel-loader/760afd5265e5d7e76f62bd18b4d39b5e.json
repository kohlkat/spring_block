{"ast":null,"code":"/**\r\n * Base functionality\r\n*/\nimport * as tslib_1 from \"tslib\";\nimport { List, ListTemplate } from \"./utils/List\";\nimport { OrderedListTemplate, SortedListTemplate } from \"./utils/SortedList\";\nimport { Dictionary, DictionaryTemplate } from \"./utils/Dictionary\";\nimport { Disposer } from \"./utils/Disposer\";\nimport { EventDispatcher } from \"./utils/EventDispatcher\";\nimport { Adapter } from \"./utils/Adapter\";\nimport { Color, color } from \"./utils/Color\";\nimport { Percent, percent } from \"./utils/Percent\";\nimport { registry } from \"./Registry\";\nimport { cache } from \"./utils/Cache\";\nimport * as $array from \"./utils/Array\";\nimport * as $object from \"./utils/Object\";\nimport * as $type from \"./utils/Type\"; //import * as $debug from \"./utils/Debug\";\n\n/**\r\n * Provides base functionality for all derivative objects, like generating ids,\r\n * handling cache, etc.\r\n */\n\nvar BaseObject =\n/** @class */\nfunction () {\n  //protected _classes: { [index: string]: any } = {};\n\n  /**\r\n   * Constructor\r\n   * * Sets class name\r\n   */\n  function BaseObject() {\n    /**\r\n     * Indicates if this object has already been deleted. Any\r\n     * destruction/disposal code should take this into account when deciding\r\n     * wheter to run potentially costly disposal operations if they already have\r\n     * been run.\r\n     *\r\n     * @ignore Exclude from docs\r\n     */\n    this._disposed = false;\n    /**\r\n     * List of IDisposer which will be disposed when the BaseObject is disposed.\r\n     *\r\n     * @ignore Exclude from docs\r\n     */\n\n    this._disposers = [];\n    this.className = \"BaseObject\"; //this.debug();\n  }\n\n  BaseObject.prototype.debug = function () {//$debug.debug(this);\n  };\n\n  Object.defineProperty(BaseObject.prototype, \"uid\", {\n    /**\r\n     * Returns object's internal unique ID.\r\n     *\r\n     * @return Unique ID\r\n     */\n    get: function () {\n      if (!this._uid) {\n        this._uid = registry.getUniqueId();\n        registry.map.setKey(this._uid, this);\n      }\n\n      return this._uid;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(BaseObject.prototype, \"id\", {\n    /**\r\n     * @return Id\r\n     */\n    get: function () {\n      return this._id;\n    },\n\n    /**\r\n     * Sets the user-defined id of the element.\r\n     *\r\n     * @param value Id\r\n     */\n    set: function (value) {\n      //registry.map.setKey(value, this); // registry.map only stores by uid\n      this._id = value;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(BaseObject.prototype, \"map\", {\n    /**\r\n     * Returns a universal collection for mapping ids with objects.\r\n     *\r\n     * @ignore Exclude from docs\r\n     * @return Map collection\r\n     */\n    get: function () {\n      if (!this._map) {\n        this._map = new Dictionary();\n      }\n\n      return this._map;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\r\n   * Applies properties from all assigned themes.\r\n   *\r\n   * @ignore Exclude from docs\r\n   */\n\n  BaseObject.prototype.applyTheme = function () {\n    var _this = this; // TODO is this needed ?\n\n\n    if (registry) {\n      var themes = this.getCurrentThemes(); // TODO is this needed ?\n\n      if (themes) {\n        $array.each(themes, function (theme, index) {\n          theme(_this);\n        });\n      }\n    }\n  };\n\n  Object.defineProperty(BaseObject.prototype, \"themes\", {\n    /**\r\n     * @ignore Exclude from docs\r\n     * @return An array of themes\r\n     */\n    get: function () {\n      return this._themes;\n    },\n\n    /**\r\n     * A list of themes to be used for this element.\r\n     *\r\n     * @ignore Exclude from docs\r\n     * @param value An array of themes\r\n     */\n    set: function (value) {\n      this._themes = value;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\r\n   * Returns a list of themes that should be applied to this element. It could\r\n   * either be a list of themes set explicitly on this element, or system-wide.\r\n   *\r\n   * @return List of themes\r\n   */\n\n  BaseObject.prototype.getCurrentThemes = function () {\n    return this.themes || registry.themes;\n  };\n  /**\r\n   * Returns if this object has been already been disposed.\r\n   *\r\n   * @return Is disposed?\r\n   */\n\n\n  BaseObject.prototype.isDisposed = function () {\n    return this._disposed;\n  };\n  /**\r\n   * Destroys this object and all related data.\r\n   */\n\n\n  BaseObject.prototype.dispose = function () {\n    if (!this._disposed) {\n      this._disposed = true;\n      var a = this._disposers;\n      this._disposers = null;\n\n      while (a.length !== 0) {\n        var disposer = a.shift();\n        disposer.dispose();\n      } // Clear cache\n\n\n      this.clearCache(); // remove from clones list\n\n      if (this.clonedFrom) {\n        this.clonedFrom.clones.removeValue(this);\n      }\n\n      var uid = this._uid;\n\n      if (uid != null) {\n        registry.map.removeKey(uid);\n      }\n    }\n  };\n  /**\r\n   * Adds an IDisposer, which will be disposed when this object is disposed.\r\n   *\r\n   * @param target Object to dispose\r\n   * @ignore Exclude from docs\r\n   */\n\n\n  BaseObject.prototype.addDisposer = function (target) {\n    this._disposers.push(target);\n  };\n  /**\r\n   * Disposes disposable object and removes it from `_disposers`.\r\n   *\r\n   * @param target Object to dispose\r\n   * @ignore Exclude from docs\r\n   */\n\n\n  BaseObject.prototype.removeDispose = function (target) {\n    //if(target){\n    if (!this._disposed) {\n      var index = $array.indexOf(this._disposers, target);\n\n      if (index > -1) {\n        this._disposers.splice(index, 1);\n      }\n    }\n\n    target.dispose(); //}\n  };\n  /**\r\n   * Makes a copy of this object and returns the clone. Try to avoid cloning complex objects like chart, create new instances if you need them.\r\n   *\r\n   * @param cloneId  An id to use for clone (if not set a unique id will be generated)\r\n   * @returns Clone\r\n   */\n\n\n  BaseObject.prototype.clone = function (cloneId) {\n    if (!cloneId) {\n      cloneId = \"clone-\" + registry.getUniqueId();\n    }\n\n    var newObject = new this.constructor();\n    newObject.cloneId = cloneId;\n    newObject.copyFrom(this); // add to clones list\n    // this.clones.push(newObject); // moved this to copyFrom\n\n    return newObject;\n  };\n\n  Object.defineProperty(BaseObject.prototype, \"clones\", {\n    /**\r\n     * Returns a collection of object's clones.\r\n     *\r\n     * @ignore Exclude from docs\r\n     * @return Clones\r\n     */\n    get: function () {\n      if (!this._clones) {\n        this._clones = new List();\n      }\n\n      return this._clones;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\r\n   * Copies all properties and related data from different element.\r\n   *\r\n   * @param object Source element\r\n   */\n\n  BaseObject.prototype.copyFrom = function (object) {\n    object.clones.push(this); // do not moveValue, as it is expensive! even if there will be several items in clones list, it's not that bad.\n\n    this.clonedFrom = object;\n  };\n\n  Object.defineProperty(BaseObject.prototype, \"className\", {\n    /**\r\n     * @ignore Exclude from docs\r\n     * @return Class name\r\n     */\n    get: function () {\n      return this._className;\n    },\n\n    /**\r\n     * Element's class name. (a class that was used to instantiate the element)\r\n     *\r\n     * @ignore Exclude from docs\r\n     * @param value  Class name\r\n     */\n    set: function (value) {\n      this._className = value;\n      /*if (registry) {\r\n          registry.registeredClasses[value] = typeof this;\r\n      }*/\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\r\n   * Caches value in object's cache.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param key    Key\r\n   * @param value  Value\r\n   * @param ttl    TTL in seconds\r\n   */\n\n  BaseObject.prototype.setCache = function (key, value, ttl) {\n    cache.set(this.uid, key, value, ttl);\n  };\n  /**\r\n   * Retrieves cached value.\r\n   *\r\n   * If optional second padarameter is specified, it will return that value\r\n   * if cache is not available or is expired.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param key    Key\r\n   * @param value  Value to return if cache is not available\r\n   * @return Value\r\n   */\n\n\n  BaseObject.prototype.getCache = function (key, value) {\n    if (value === void 0) {\n      value = undefined;\n    }\n\n    return cache.get(this.uid, key, value);\n  };\n  /**\r\n   * Clears object's local cache.\r\n   *\r\n   * @ignore Exclude from docs\r\n   */\n\n\n  BaseObject.prototype.clearCache = function () {\n    cache.clear(this.uid);\n  };\n  /**\r\n   * Creates [[Disposer]] for `setTimeout` function call. This ensures that all\r\n   * timeouts created by the object will be cleared when object itself is\r\n   * disposed.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param fn     Callback function\r\n   * @param delay  Timeout (ms)\r\n   * @return Disposer for timeout\r\n   */\n\n\n  BaseObject.prototype.setTimeout = function (fn, delay) {\n    var _this = this;\n\n    var id = setTimeout(function () {\n      _this.removeDispose(disposer);\n\n      fn();\n    }, delay);\n    var disposer = new Disposer(function () {\n      clearTimeout(id);\n    });\n\n    this._disposers.push(disposer);\n\n    return disposer;\n  };\n  /**\r\n   * Creates [[Disposer]] for `setInterval` function call. This ensures that all\r\n   * timeouts created by the object will be cleared when object itself is\r\n   * disposed.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param fn     Callback function\r\n   * @param delay  Timeout (ms)\r\n   * @return Disposer for timeout\r\n   */\n\n\n  BaseObject.prototype.setInterval = function (fn, delay) {\n    var _this = this;\n\n    var id = setInterval(function () {\n      _this.removeDispose(disposer);\n\n      fn();\n    }, delay);\n    var disposer = new Disposer(function () {\n      clearTimeout(id);\n    });\n\n    this._disposers.push(disposer);\n\n    return disposer;\n  };\n\n  Object.defineProperty(BaseObject.prototype, \"config\", {\n    /**\r\n     * ==========================================================================\r\n     * JSON-BASED CONFIG PROCESSING\r\n     * ==========================================================================\r\n     * @hidden\r\n     */\n\n    /**\r\n     * Use this property to set JSON-based config. When set, triggers processing\r\n     * routine, which will go through all properties, and try to apply values,\r\n     * create instances, etc.\r\n     *\r\n     * Use this with caution, as it is a time-consuming process. It's used for\r\n     * initialchart setup only, not routine operations.\r\n     *\r\n     * @param json JSON config\r\n     */\n    set: function (config) {\n      try {\n        this.processConfig(config);\n      } catch (e) {\n        /*if (this instanceof Sprite) {\r\n            this.raiseCriticalError(e);\r\n        }*/\n        this.raiseCriticalError(e);\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\r\n   * Processes the JSON config.\r\n   *\r\n   * @param json  JSON config\r\n   * @ignore Exclude from docs\r\n   */\n\n  BaseObject.prototype.processConfig = function (config) {\n    var _this = this;\n\n    if (!config) {\n      return;\n    } // Get target\n\n\n    var target = this; // Iterate through all of the items\n\n    $object.eachOrdered(config, function (configKey, value) {\n      var configValue = value; // Is this a callback?\n\n      if (configKey == \"callback\" && typeof value == \"function\") {\n        value.call(target);\n      } // Check if there's a property in target\n\n\n      if (_this.hasProperty(configKey)) {\n        var item_1; // Do we have instructions to create an object?\n        // We create a new object if \"type\" key is set, but only if the\n        // target object is of different type.\n\n        if ($type.isObject(configValue) && $type.hasValue(configValue[\"type\"]) && (!$type.isObject(target[configKey]) || !$type.hasValue(target[configKey].className) || configValue[\"forceCreate\"] || target[configKey].className != configValue[\"type\"]) && !_this.asIs(configKey)) {\n          item_1 = _this.createClassInstance(configValue[\"type\"]); // Create new instance\n\n          if (item_1) {\n            target[configKey] = item_1;\n          } else {\n            item_1 = target[configKey];\n          }\n        } else {\n          // Get item from the object\n          item_1 = target[configKey];\n        }\n        /**\r\n         * It is...\r\n         * --------------------------------------------------------------------\r\n         */\n\n\n        if (item_1 instanceof Adapter) {\n          // ... an Adapter, try to add handlers to it\n          // ------------------------------------------------------------------\n          _this.processAdapters(item_1, configValue);\n        } else if (item_1 instanceof EventDispatcher) {\n          // ... an EventDispatcher, try to add handlers to it\n          // ------------------------------------------------------------------\n          _this.processEvents(item_1, configValue);\n        } else if (configKey == \"locale\" && $type.isString(configValue)) {\n          // ... a locale specified as string, e.g. \"fr_FR\"\n          // ------------------------------------------------------------------\n          if (document[\"am4lang_\" + configValue]) {\n            target[configKey] = document[\"am4lang_\" + configValue];\n          }\n        } else if (configKey == \"parent\" && $type.isString(configValue)) {\n          // ... a parent referred via its it\n          // ------------------------------------------------------------------\n          var parent_1 = _this.map.getKey(configValue);\n\n          if (parent_1) {\n            target[configKey] = parent_1;\n          } else {\n            throw Error(\"Non-existing ID in config: \\\"\" + configValue + \"\\\".\");\n          }\n        } else if (_this.asIs(configKey)) {\n          // ... a special field, just set it to new value\n          // ------------------------------------------------------------------\n          // (no need to add each indvidual item)\n          target[configKey] = configValue;\n        } else if (_this.asFunction(configKey) && $type.isString(configValue)) {\n          // ... a field indicating function name to look for in registry\n          // ------------------------------------------------------------------\n          if ($type.hasValue(registry.registeredClasses[configValue])) {\n            target[configKey] = registry.registeredClasses[configValue];\n          } else {\n            throw Error(\"Invalid easing function: \" + configValue);\n          }\n        } else if (configValue instanceof BaseObject) {\n          // ... a BaseObject object, we just going to use it as it is\n          // ------------------------------------------------------------------\n          target[configKey] = configValue;\n        } else if (item_1 instanceof BaseObject) {\n          // ... another child BaseObject\n          // ------------------------------------------------------------------\n          // Let's just pass in config part in and let itself deal with it\n          item_1.config = configValue;\n        } else if (item_1 instanceof ListTemplate || item_1 instanceof OrderedListTemplate || item_1 instanceof SortedListTemplate) {\n          // ... a list with template\n          // ------------------------------------------------------------------\n          // Let's see what we can do with it\n          if ($type.isArray(configValue)) {\n            // It's an array.\n            // Create a list item for entry, or try to apply properties to an\n            // existing entry if possible and it is present.\n            if (item_1 instanceof ListTemplate) {\n              _this.processListTemplate(configValue, item_1);\n            } else {\n              _this.processOrderedTemplate(configValue, item_1);\n            }\n          } else if ($type.isObject(configValue)) {\n            // It's a single oject.\n            // Treat it as a template.\n            if (configValue instanceof BaseObject) {\n              // Item is already a BaseObject, no need to process it further\n              item_1.template = configValue;\n            } else {\n              // Now let's find out if the whole object if a template, or we\n              // need to get it from `template` key\n              var templateValue = void 0;\n\n              if ($type.hasValue(configValue.template)) {\n                templateValue = configValue.template;\n              } else {\n                templateValue = configValue;\n              }\n\n              if (item_1.template instanceof BaseObject) {\n                // Template is a BaseObject so we will just let its config\n                // deal with the configuration\n                item_1.template.config = templateValue;\n              } else {\n                $object.each(templateValue, function (entryKey, entryValue) {\n                  var listItem = item_1.template[entryKey];\n\n                  if (listItem instanceof Adapter) {\n                    _this.processAdapters(listItem, entryValue);\n                  } else if (listItem instanceof EventDispatcher) {\n                    _this.processEvents(listItem, entryValue);\n                  } else if (listItem instanceof DictionaryTemplate) {\n                    _this.processDictionaryTemplate(listItem, entryValue);\n                  } else if (item_1.template[entryKey] instanceof BaseObject) {\n                    // Template is a BaseObject. Let it deal with its own config.\n                    item_1.template[entryKey].config = entryValue;\n                  } else if ($type.isObject(entryValue) && $type.hasValue(entryValue[\"type\"])) {\n                    listItem = _this.createClassInstance(entryValue[\"type\"]);\n\n                    if (listItem) {\n                      if (listItem instanceof BaseObject) {\n                        listItem.config = entryValue;\n                      }\n\n                      item_1.template[entryKey] = listItem;\n                    } else {\n                      item_1.template[entryKey] = entryValue;\n                    }\n                  } else if (listItem instanceof List) {\n                    // It's List, process it\n                    _this.processList(entryValue, listItem);\n                  } else {\n                    // Aything else. Just assing and be done with it.\n                    item_1.template[entryKey] = _this.maybeColorOrPercent(entryValue);\n                  }\n                });\n              } // Check maybe there are `values` to insert\n\n\n              if ($type.hasValue(configValue.values)) {\n                if (item_1 instanceof ListTemplate) {\n                  _this.processListTemplate(configValue.values, item_1);\n                } else {\n                  _this.processOrderedTemplate(configValue.values, item_1);\n                }\n              }\n            }\n          } else {// Something else?\n            // Not sure what to do with it on a list - ignore\n          }\n        } else if (item_1 instanceof List) {\n          // ... a list\n          // ------------------------------------------------------------------\n          if (configKey == \"children\") {\n            _this.processList(configValue, item_1, _this);\n          } else {\n            _this.processList(configValue, item_1);\n          }\n        } else if (item_1 instanceof DictionaryTemplate) {\n          // ... a dictionary with template\n          // ------------------------------------------------------------------\n          _this.processDictionaryTemplate(item_1, configValue);\n        } else if (item_1 instanceof Dictionary) {\n          // ... a dictionary\n          // ------------------------------------------------------------------\n          _this.processDictionary(item_1, configValue);\n        } else if (item_1 instanceof Color || item_1 instanceof Percent) {\n          // ... it's a Color or Percent\n          // ------------------------------------------------------------------\n          target[configKey] = _this.maybeColorOrPercent(configValue);\n        } else if ($type.isObject(item_1) && $type.isObject(configValue)) {\n          // ... a regular object\n          // ------------------------------------------------------------------\n          $object.copyAllProperties(configValue, item_1);\n        } else {\n          // ... something else - probably a simple property or object\n          // ------------------------------------------------------------------\n          // Maybe convert to `Percent` or `Color`?\n          configValue = _this.maybeColorOrPercent(configValue); // Assign\n\n          target[configKey] = configValue;\n        }\n      } else if (!_this.isReserved(configKey)) {\n        // Doesn't have property set. But we're going to assume JSON config\n        // creator knows what he/she is doing and set it anyway.\n        target[configKey] = configValue;\n      }\n    }, this.configOrder); // Any errors?\n\n    if (this.processingErrors.length) {\n      var errors = this.processingErrors.join(\"\\n\");\n      this._processingErrors = [];\n      throw Error(errors);\n    }\n  };\n  /**\r\n   * Tries to detect if value is color or percent and converts to proper object\r\n   * if necessary.\r\n   *\r\n   * Returns the same source value if no color/percent detected\r\n   *\r\n   * @param value  Source value\r\n   * @return Converted value\r\n   */\n\n\n  BaseObject.prototype.maybeColorOrPercent = function (value) {\n    if ($type.isString(value)) {\n      if (value.match(/^[\\-]?[0-9.]+\\%$/)) {\n        return percent($type.toNumber(value));\n      } else if (value.match(/^\\#[0-9abcdef]{3,}$/i)) {\n        return color(value);\n      }\n    }\n\n    return value;\n  };\n\n  BaseObject.prototype.processAdapters = function (item, config) {\n    var _this = this;\n\n    if ($type.isArray(config)) {\n      $array.each(config, function (entry, index) {\n        item.add(entry.key, entry.callback, entry.priority || 0, _this);\n      });\n    } else if ($type.isObject(config)) {\n      $object.each(config, function (key, entry) {\n        if (!item.has(key, entry)) {\n          item.add(key, entry);\n        }\n      });\n    }\n  };\n\n  BaseObject.prototype.processEvents = function (item, config) {\n    var _this = this;\n\n    if ($type.isObject(config)) {\n      $object.each(config, function (key, entry) {\n        if (!item.has(key, entry)) {\n          item.on(key, entry);\n        }\n      });\n    } else if ($type.isArray(config)) {\n      $array.each(config, function (entry, index) {\n        item.on(entry.type, entry.callback, _this);\n      });\n    }\n  };\n  /**\r\n   * Processes JSON config for a [[DictionaryTemplate]] item.\r\n   *\r\n   * @todo Description\r\n   * @param item    Item\r\n   * @param config  Config\r\n   */\n\n\n  BaseObject.prototype.processDictionaryTemplate = function (item, config) {\n    // We can only process object\n    // Not sure what to do with other types - ignore\n    if ($type.isObject(config)) {\n      // Create an entry for each item, or override properties for\n      // existing one.\n      $object.each(config, function (entryKey, entryValue) {\n        var listItem; // Get existing one, or create a new one\n\n        if (entryKey == \"template\") {\n          listItem = item.template;\n        } else if (item.hasKey(entryKey)) {\n          listItem = item.getKey(entryKey);\n        } else {\n          listItem = item.create(entryKey);\n        } // Set data\n\n\n        if (listItem instanceof BaseObject) {\n          listItem.config = entryValue;\n        } else if ($type.isObject(listItem) && $type.isObject(entryValue)) {\n          $object.copyAllProperties(entryValue, listItem);\n        } else {\n          listItem.setKey(entryKey, entryValue);\n        }\n      });\n    }\n  };\n  /**\r\n   * Processes JSON config for a [[Dictionary]] item.\r\n   *\r\n   * @todo Description\r\n   * @param item    Item\r\n   * @param config  Config\r\n   */\n\n\n  BaseObject.prototype.processDictionary = function (item, config) {\n    // We can only process object\n    // Not sure what to do with other types - ignore\n    if ($type.isObject(config)) {\n      // Create an entry for each item, or override properties for\n      // existing one.\n      // @todo support for non-basic types\n      $object.each(config, function (entryKey, entryValue) {\n        item.setKey(entryKey, entryValue);\n      });\n    }\n  };\n  /**\r\n   * Processes [[ListTemplate]].\r\n   *\r\n   * @param configValue  Config value\r\n   * @param item         Item\r\n   */\n\n\n  BaseObject.prototype.processListTemplate = function (configValue, item) {\n    var _this = this;\n\n    $array.each(configValue, function (entry, index) {\n      var type = _this.getConfigEntryType(entry);\n\n      var listItem;\n\n      if (item.hasIndex(index) && !entry[\"forceCreate\"]) {\n        listItem = item.getIndex(index);\n      } else if (entry instanceof BaseObject) {\n        // Item is already a BaseObject, no need to process it further\n        item.push(entry);\n        return;\n      } else if (type) {\n        listItem = item.create(type);\n      } else {\n        listItem = item.create();\n      }\n\n      if (entry === listItem) {// It's already the same item, do nothing\n      } else {\n        if ($type.isObject(entry)) {\n          // If the list item is BaseObject, we just need to let it\n          // deal if its own config\n          if (listItem instanceof BaseObject) {\n            listItem.config = entry;\n          } else if ($type.isObject(listItem) && $type.isObject(entry)) {\n            $object.copyAllProperties(entry, listItem);\n          } else {\n            item.setIndex(item.indexOf(listItem), entry);\n          }\n        }\n      }\n    }); // Truncate the list if it contains less items than the config\n    // array\n\n    while (configValue.length > item.length) {\n      item.pop();\n    }\n  };\n  /**\r\n   * Processes [[OrdererListTemplate]] or [[SortedListTemplate]].\r\n   *\r\n   * @param configValue  Config value\r\n   * @param item         Item\r\n   */\n\n\n  BaseObject.prototype.processOrderedTemplate = function (configValue, item) {\n    var _this = this;\n\n    $array.each(configValue, function (entry, index) {\n      var type = _this.getConfigEntryType(entry);\n\n      var listItem;\n\n      if (type) {\n        listItem = item.create(type);\n      } else {\n        listItem = item.create();\n      }\n\n      if ($type.isObject(entry)) {\n        // If the list item is BaseObject, we just need to let it\n        // deal if its own config\n        if (listItem instanceof BaseObject) {\n          listItem.config = entry;\n        } else if ($type.isObject(listItem) && $type.isObject(entry)) {\n          $object.copyAllProperties(entry, listItem);\n        } else {\n          item.insert(entry);\n        }\n      }\n    });\n  };\n  /**\r\n   * Processes [[List]].\r\n   *\r\n   * @param configValue  Config value\r\n   * @param item         Item\r\n   */\n\n\n  BaseObject.prototype.processList = function (configValue, item, parent) {\n    var _this = this; // Convert to array if necessary\n\n\n    if (!$type.isArray(configValue)) {\n      configValue = [configValue];\n    } // It's an array\n    // Create a list item for entry\n\n\n    var itemCount = item.length;\n    $array.each(configValue, function (entry, index) {\n      if ($type.isObject(entry)) {\n        // An object.\n        //\n        // Let's see if we can instantiate a class out of it, or we need\n        // to push it into list as it is.\n        //\n        // If there are items already at the specified index in the list,\n        // apply properties rather than create a new one.\n        var listItem = void 0;\n\n        if (index < itemCount && !entry[\"forceCreate\"]) {\n          listItem = item.getIndex(index);\n        } else if (entry instanceof BaseObject) {\n          // Item is already a BaseObject, no need to process it further\n          item.push(entry);\n          return;\n        } else {\n          listItem = _this.createEntryInstance(entry);\n\n          if (parent) {\n            listItem.parent = parent;\n          } else {\n            item.push(listItem);\n          }\n        } // If the list item is BaseObject, we just need to let it\n        // deal if its own config\n\n\n        if (listItem instanceof BaseObject) {\n          listItem.config = entry;\n        } else if ($type.isObject(listItem) && $type.isObject(entry)) {\n          $object.copyAllProperties(entry, listItem);\n        }\n      } else {\n        // Basic value.\n        // Just push it into list, or override existing value\n        if (item.hasIndex(index)) {\n          item.setIndex(index, entry);\n        } else {\n          item.push(entry);\n        }\n      }\n    }); // Truncate the list if it contains less items than the config\n    // array\n\n    while (configValue.length > item.length) {\n      item.pop();\n    }\n  };\n  /**\r\n   * This function is used to sort element's JSON config properties, so that\r\n   * some properties that absolutely need to be processed last, can be put at\r\n   * the end.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param a  Element 1\r\n   * @param b  Element 2\r\n   * @return Sorting number\r\n   */\n\n\n  BaseObject.prototype.configOrder = function (a, b) {\n    if (a == b) {\n      return 0;\n    } // Language must come first, so it's all set up when the rest of the\n    // elements are being instantiated\n    else if (a == \"language\") {\n        return -1;\n      } else if (b == \"language\") {\n        return 1;\n      } else {\n        return 0;\n      }\n  };\n  /**\r\n   * Checks if field should be just assigned as is, without any checking when\r\n   * processing JSON config.\r\n   *\r\n   * Extending functions can override this function to do their own checks.\r\n   *\r\n   * @param field  Field name\r\n   * @return Assign as is?\r\n   */\n\n\n  BaseObject.prototype.asIs = function (field) {\n    return $array.indexOf([\"locale\"], field) != -1;\n  };\n  /**\r\n   * Checks if field needs to be converted to function, if it is specified\r\n   * as string.\r\n   *\r\n   * @param field  Field name\r\n   * @return Assign as function?\r\n   */\n\n\n  BaseObject.prototype.asFunction = function (field) {\n    return false;\n  };\n  /**\r\n   * Creates a relevant class instance if such class definition exists.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param className  Class name\r\n   * @return Instance\r\n   */\n\n\n  BaseObject.prototype.createClassInstance = function (className) {\n    if ($type.hasValue(registry.registeredClasses[className])) {\n      return new registry.registeredClasses[className]();\n    } else {\n      throw Error(\"Invalid type: \\\"\" + className + \"\\\".\");\n    }\n  };\n  /**\r\n   * Creates a class instance for a config entry using it's type. (as set in\r\n   * `type` property)\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param config  Config part\r\n   * @return Instance\r\n   */\n\n\n  BaseObject.prototype.createEntryInstance = function (config) {\n    var res;\n\n    if ($type.hasValue(config[\"type\"])) {\n      res = this.createClassInstance(config[\"type\"]);\n    }\n\n    if (!res) {\n      return config;\n    }\n\n    return res;\n  };\n  /**\r\n   * Determines config object type.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param config  Config part\r\n   * @return Type\r\n   */\n\n\n  BaseObject.prototype.getConfigEntryType = function (config) {\n    if ($type.hasValue(config[\"type\"])) {\n      if ($type.hasValue(registry.registeredClasses[config[\"type\"]])) {\n        return registry.registeredClasses[config[\"type\"]];\n      } else {\n        throw Error(\"Invalid type: \\\"\" + config[\"type\"] + \"\\\".\");\n      }\n    }\n\n    return;\n  };\n  /**\r\n   * Checks if this element has a property.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param prop  Property name\r\n   * @return Has property?\r\n   */\n\n\n  BaseObject.prototype.hasProperty = function (prop) {\n    return prop in this ? true : false;\n  };\n  /**\r\n   * Checkes whether JSON key is a reserved keyword.\r\n   *\r\n   * @param key  Key\r\n   * @return Reserved\r\n   */\n\n\n  BaseObject.prototype.isReserved = function (key) {\n    return [\"type\", \"forceCreate\"].indexOf(key) !== -1;\n  };\n\n  Object.defineProperty(BaseObject.prototype, \"processingErrors\", {\n    /**\r\n     * A list of errors that happened during JSON processing.\r\n     *\r\n     * @return Errors\r\n     */\n    get: function () {\n      if (!this._processingErrors) {\n        this._processingErrors = [];\n      }\n\n      return this._processingErrors;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  return BaseObject;\n}();\n\nexport { BaseObject };\n;\n/**\r\n * A version of [[BaseObject]] with events properties and methods.\r\n * Classes that use [[EventDispatcher]] should extend this instead of\r\n * [[BaseObject]] directly.\r\n */\n\nvar BaseObjectEvents =\n/** @class */\nfunction (_super) {\n  tslib_1.__extends(BaseObjectEvents, _super);\n  /**\r\n   * Constructor\r\n   */\n\n\n  function BaseObjectEvents() {\n    var _this = _super.call(this) || this;\n\n    _this.className = \"BaseObjectEvents\";\n    return _this;\n  }\n\n  Object.defineProperty(BaseObjectEvents.prototype, \"events\", {\n    /**\r\n     * An [[EventDispatcher]] instance\r\n     */\n    get: function () {\n      if (!this._eventDispatcher) {\n        this._eventDispatcher = new EventDispatcher();\n\n        this._disposers.push(this._eventDispatcher);\n      }\n\n      return this._eventDispatcher;\n    },\n    enumerable: true,\n    configurable: true\n  }); //public set events(value:EventDispatcher<AMEvent<this, this[\"_events\"]>>){\n  //\tthis._eventDispatcher = value;\n  //}\n\n  /**\r\n   * Dispatches an event using own event dispatcher. Will automatically\r\n   * populate event data object with event type and target (this element).\r\n   * It also checks if there are any handlers registered for this sepecific\r\n   * event.\r\n   *\r\n   * @param eventType Event type (name)\r\n   * @param data      Data to pass into event handler(s)\r\n   */\n\n  BaseObjectEvents.prototype.dispatch = function (eventType, data) {\n    // @todo Implement proper type check\n    if (this._eventDispatcher) {\n      if (this.events.isEnabled(eventType)) {\n        if (data) {\n          data.type = eventType;\n          data.target = data.target || this;\n          this.events.dispatch(eventType, {\n            type: eventType,\n            target: this\n          });\n        } else {\n          this.events.dispatch(eventType, {\n            type: eventType,\n            target: this\n          });\n        }\n      }\n    }\n  };\n  /**\r\n   * Works like `dispatch`, except event is triggered immediately, without\r\n   * waiting for the next frame cycle.\r\n   *\r\n   * @param eventType Event type (name)\r\n   * @param data      Data to pass into event handler(s)\r\n   */\n\n\n  BaseObjectEvents.prototype.dispatchImmediately = function (eventType, data) {\n    // @todo Implement proper type check\n    if (this._eventDispatcher) {\n      if (this.events.isEnabled(eventType)) {\n        if (data) {\n          data.type = eventType;\n          data.target = data.target || this;\n          this.events.dispatchImmediately(eventType, data);\n        } else {\n          this.events.dispatchImmediately(eventType, {\n            type: eventType,\n            target: this\n          });\n        }\n      }\n    }\n  };\n  /**\r\n   * Copies all parameters from another [[Sprite]].\r\n   *\r\n   * @param source Source object\r\n   */\n\n\n  BaseObjectEvents.prototype.copyFrom = function (source) {\n    _super.prototype.copyFrom.call(this, source);\n\n    if (source._eventDispatcher) {\n      this.events.copyFrom(source._eventDispatcher);\n    }\n  };\n\n  return BaseObjectEvents;\n}(BaseObject);\n\nexport { BaseObjectEvents };","map":null,"metadata":{},"sourceType":"module"}