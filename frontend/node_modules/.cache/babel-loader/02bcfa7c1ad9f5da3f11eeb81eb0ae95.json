{"ast":null,"code":"/**\r\n * An Adapter can be used to apply chained synchronous transformations to any\r\n * value at runtime.\r\n *\r\n * Each type class using Adapters must have `adapters` property and adapter\r\n * interface defined.\r\n *\r\n * Adapters can be used to allow external code to apply transformations to any\r\n * value at any time.\r\n *\r\n * For example we have a Weather class which has a method `now()` which returns\r\n * current temperature.\r\n *\r\n * ```\r\n * function now() {\r\n *   // ... calculate temperature\r\n *   let temp = \"Temperature now is \" + degrees + \"F\";\r\n *   return temp;\r\n * }\r\n * ```\r\n *\r\n * Now, supposed we want to let other classes to modify the output of the\r\n * `now()`? We just apply an adapter to the `temp` before it is returned:\r\n *\r\n * ```\r\n * temp = this.adapters.apply(\"now\", {\r\n *   temp: temp,\r\n *   degrees: degrees\r\n * }).temp;\r\n * ```\r\n *\r\n * Some other class might tap onto it by defining an Adapter that calculates\r\n * the temperature in Celsius:\r\n *\r\n * weather.adapters.add(\"now\", (arg) => {\r\n *   arg.temp += \"(\" + farenheitToCelsius(arg.degrees) + \"C)\";\r\n *   return arh;\r\n * });\r\n *\r\n * Furthermore some time-related class could add time:\r\n *\r\n * weather.adapters.add(\"now\", (arg) => {\r\n *   arg.temp += \"; the time now is \" + (new Date().toLocaleString());\r\n *   return arh;\r\n * });\r\n *\r\n * So without adapters we would get output like this:\r\n *\r\n * ```\r\n * Temperature now is 90F\r\n * ```\r\n *\r\n * With adapters applied we now have:\r\n *\r\n * ```\r\n * Temperature now is 90F (32C); the time now is 12/11/2012, 7:00:00 PM\r\n * ```\r\n */\n\n/**\r\n * ============================================================================\r\n * IMPORTS\r\n * ============================================================================\r\n * @hidden\r\n */\nimport { SortedList } from \"./SortedList\";\nimport * as $number from \"./Number\";\nimport * as $order from \"./Order\";\nimport * as $iter from \"../utils/Iterator\";\nimport * as $array from \"../utils/Array\";\nimport * as $type from \"../utils/Type\";\n/**\r\n * ============================================================================\r\n * GLOBAL ADAPTER\r\n * ============================================================================\r\n * @hidden\r\n */\n\n/**\r\n * A global adapter is an adpater that is attached to a class type rather than\r\n * specific object instance.\r\n *\r\n * @ignore Exclude from docs\r\n */\n\nvar GlobalAdapter =\n/** @class */\nfunction () {\n  function GlobalAdapter() {\n    /**\r\n     * Callback id iterator.\r\n     */\n    this._callbackId = 0;\n    /**\r\n     * A list of if callbacks (adapters).\r\n     */\n\n    this._callbacks = new SortedList(function (left, right) {\n      return $order.or($number.order(left.priority, right.priority), $number.order(left.id, right.id));\n    });\n  }\n  /**\r\n   * Adds a global callback which is not specific to any particular object.\r\n   * Whenever an adapter in any object of the specific class type is invoked\r\n   * global adapters will kick in.\r\n   *\r\n   * @param type      Class type\r\n   * @param key       Adapter key\r\n   * @param callback  Callback function\r\n   * @param priority  Priority (higher priority meaning adapter will be applied later)\r\n   * @param scope     Callback function scaope\r\n   */\n\n\n  GlobalAdapter.prototype.addAll = function (type, key, callback, priority, scope) {\n    if (priority === void 0) {\n      priority = 0;\n    }\n\n    this._callbacks.insert({\n      id: ++this._callbackId,\n      key: key,\n      callback: callback,\n      priority: priority,\n      scope: scope,\n      type: type\n    });\n  };\n  /**\r\n   * Returns if there are adapters for specific type available.\r\n   *\r\n   * @param type  Adapter type\r\n   * @param key   Adapter key\r\n   * @return {boolean}\r\n   */\n\n\n  GlobalAdapter.prototype.isEnabled = function (type, key) {\n    // TODO check the type and key\n    return this._callbacks.length > 0;\n  };\n  /**\r\n   * Applies global adapters for the object of the specific type.\r\n   *\r\n   * @param type   Class type\r\n   * @param key    Adapter key\r\n   * @param value  Value\r\n   */\n\n\n  GlobalAdapter.prototype.applyAll = function (type, key, value) {\n    // This is needed to improve the performance and reduce garbage collection\n    var callbacks = this._callbacks.values;\n    var length = callbacks.length;\n\n    if (length == 0) {\n      return value;\n    } // Cycle through all callbacks and find the ones we need to use\n\n\n    for (var i = 0; i < length; ++i) {\n      var item = callbacks[i];\n\n      if (item.key === key && type instanceof item.type) {\n        value = item.callback.call(item.scope, value, type, key);\n      }\n    }\n\n    return value;\n  };\n\n  return GlobalAdapter;\n}();\n\nexport { GlobalAdapter };\n/**\r\n * A global Adapter for plugins that want to add specific\r\n * functionality for any chart, not just specific instance.\r\n *\r\n * If you want to add an adapter which applies to all instances of the same\r\n * object type, like, for instance all slices in PieSeries, you can use\r\n * global adapter.\r\n *\r\n * Global adapter is a system-wide instance, accessible via `globalAdapter`.\r\n *\r\n * ```TypeScript\r\n * am4core.globalAdapter.addAll<am4charts.IPieSeriesAdapters, am4charts.PieSeries, \"fill\">(am4charts.PieSeries, \"fill\", (value, target, key) => {\r\n *   return am4core.color(\"#005500\");\r\n * });\r\n * ```\r\n * ```JavaScript\r\n * am4core.globalAdapter.addAll(am4charts.PieSeries, \"fill\", (value, target, key) => {\r\n *   return am4core.color(\"#005500\");\r\n * });\r\n * ```\r\n *\r\n * @todo Description (improve)\r\n */\n\nexport var globalAdapter = new GlobalAdapter();\n/**\r\n * ============================================================================\r\n * REGULAR ADAPTER\r\n * ============================================================================\r\n * @hidden\r\n */\n\n/**\r\n * Adapter allows adding ordered callback functions and associating them with a\r\n * string-based key. An Adapter user can then easily invoke those callbacks to\r\n * apply custom functions on its input, output or intermediate values.\r\n *\r\n * Custom code and plugins can add their own callbacks to modify and enhance\r\n * core functionality.\r\n *\r\n * See the description of `add()` for an example.\r\n *\r\n * Almost any object in amCharts4 has own adapter, accessible with `adapter`\r\n * property.\r\n *\r\n * Any adapters added to it will be applied to that object only.\r\n *\r\n * ### Global Adapters\r\n *\r\n * If you want to add an adapter which applies to all instances of the same\r\n * object type, like, for instance all slices in PieSeries, you can use\r\n * global adapter.\r\n *\r\n * Global adapter is a system-wide instance, accessible via `globalAdapter`.\r\n *\r\n * ```TypeScript\r\n * am4core.globalAdapter.addAll<am4charts.IPieSeriesAdapters, am4charts.PieSeries, \"fill\">(am4charts.PieSeries. \"fill\", (value, target, key) => {\r\n *   return am4core.color(\"#005500\");\r\n * });\r\n * ```\r\n * ```JavaScript\r\n * am4core.globalAdapter.addAll(am4charts.PieSeries. \"fill\", (value, target, key) => {\r\n *   return am4core.color(\"#005500\");\r\n * });\r\n * ```\r\n *\r\n * {@link https://www.amcharts.com/docs/v4/reference/adapter_module/#globalAdapter_property More info}.\r\n *\r\n * @important\r\n */\n\nvar Adapter =\n/** @class */\nfunction () {\n  /**\r\n   * Constructor, sets the object referece this Adapter should be used for.\r\n   *\r\n   * @param c Object\r\n   */\n  function Adapter(c) {\n    /**\r\n     * Internal counter for callback ids.\r\n     */\n    this._callbackId = 0;\n    /**\r\n     * A list of adapter callbacks.\r\n     *\r\n     * @param $number.order(left.priority, right.priority) [description]\r\n     * @param $number.order(left.id,       right.id));\t}  [description]\r\n     */\n\n    this._callbacks = new SortedList(function (left, right) {\n      return $order.or($number.order(left.priority, right.priority), $number.order(left.id, right.id));\n    });\n    this.object = c; // TODO this exposes the internal events\n\n    this.events = this._callbacks.events;\n  }\n  /**\r\n   * Adds a callback for a specific key.\r\n   *\r\n   * ```TypeScript\r\n   * // Override fill color value and make all slices green\r\n   * chart.series.template.adapter.add(\"fill\", (value, target, key) => {\r\n   *   return am4core.color(\"#005500\");\r\n   * });\r\n   * ```\r\n   * ```JavaScript\r\n   * // Override fill color value and make all slices green\r\n   * chart.series.template.adapter.add(\"fill\", function(value, target, key) {\r\n   *   return am4core.color(\"#005500\");\r\n   * });\r\n   * ```\r\n   * ```JSON\r\n   * {\r\n   *   // ...\r\n   *   \"series\": [{\r\n   *     // ...\r\n   *     \"adapter\": {\r\n   *     \t// Override fill color value and make all slices green\r\n   *     \t\"fill\": function(value, target, key) {\r\n   *     \t  return am4core.color(\"#005500\");\r\n   *     \t}\r\n   *     }\r\n   *   }]\r\n   * }\r\n   * ```\r\n   *\r\n   * The above will call user-defined function (adapter) whenever `fill` value\r\n   * is requested from the Pie series, allowing it to override the default\r\n   * using custom code and any fuzzy logic.\r\n   *\r\n   * There can be any number of adapters set on one property key.\r\n   *\r\n   * In this case adapters will be applied in daisy-chain fashion. The first\r\n   * adapter in queue will make its transformation. The next one will have\r\n   * the output of the first adapter as a starting value, etc.\r\n   *\r\n   * The order of the adapters are determined either by the order they were\r\n   * added in, or their `priority` value.\r\n   *\r\n   * The heigher the `priority`, the later in the game adapter will be applied.\r\n   *\r\n   * @param key       Key\r\n   * @param callback  A callback function\r\n   * @param priority  The higher priority, the more chance the adapter will be applied last\r\n   * @param scope     Scope for the callback function\r\n   */\n\n\n  Adapter.prototype.add = function (key, callback, priority, scope) {\n    if (priority === void 0) {\n      priority = 0;\n    }\n\n    this._callbacks.insert({\n      id: ++this._callbackId,\n      key: key,\n      callback: callback,\n      priority: priority,\n      scope: scope\n    });\n  };\n  /**\r\n   * Checks whether specific adapter is already set.\r\n   *\r\n   * @param key       Key\r\n   * @param callback  A callback function\r\n   * @param priority  The higher priority, the more chance the adapter will be applied last\r\n   * @param scope     Scope for the callback function\r\n   * @returns                            Adapter set?\r\n   */\n\n\n  Adapter.prototype.has = function (key, callback, priority, scope) {\n    if (priority === void 0) {\n      priority = 0;\n    }\n\n    return $iter.contains(this._callbacks.iterator(), function (item) {\n      return item.key === key && item.callback === callback && item.priority === priority && item.scope === scope;\n    });\n  };\n  /**\r\n   * Removes adapter callbacks for the specific `key`.\r\n   *\r\n   * If `priority` is specified, only callbacks for that priority are removed.\r\n   *\r\n   * @param key      Key\r\n   * @param priority Priority\r\n   * @todo Implement\r\n   */\n\n\n  Adapter.prototype.remove = function (key, priority) {\n    var _this = this; // It has to make a copy because it removes the elements while iterating\n    // TODO inefficient\n\n\n    $array.each($iter.toArray(this._callbacks.iterator()), function (item) {\n      // TODO test this\n      if (item.key === key && (!$type.isNumber(priority) || priority === item.priority)) {\n        _this._callbacks.remove(item);\n      }\n    });\n  };\n  /**\r\n   * Returns if there are any adapters set for the specific `key`.\r\n   *\r\n   * @returns Are there any adapters for the key?\r\n   */\n\n\n  Adapter.prototype.isEnabled = function (key) {\n    // TODO check the key\n    return this._callbacks.length > 0 || globalAdapter.isEnabled(this.object, key);\n  };\n  /**\r\n   * Passes the input value through all the callbacks for the defined `key`.\r\n   *\r\n   * @param key      Key\r\n   * @param value    Input value\r\n   * @param ...rest  Rest of the parameters to be passed into callback\r\n   * @return Output value\r\n   */\n\n\n  Adapter.prototype.apply = function (key, value) {\n    // This is needed to improve the performance and reduce garbage collection\n    var callbacks = this._callbacks.values;\n    var length = callbacks.length;\n\n    if (length > 0) {\n      for (var i = 0; i < length; ++i) {\n        var item = callbacks[i];\n\n        if (item.key === key) {\n          value = item.callback.call(item.scope, value, this.object, key);\n        }\n      }\n    } // Apply global adapters\n\n\n    value = globalAdapter.applyAll(this.object, key, value);\n    return value;\n  };\n  /**\r\n   * Returns all adapter keys that are currently in effect.\r\n   *\r\n   * @return Adapter keys\r\n   */\n\n\n  Adapter.prototype.keys = function () {\n    // TODO inefficient\n    return $iter.toArray($iter.map(this._callbacks.iterator(), function (x) {\n      return x.key;\n    }));\n  };\n  /**\r\n   * Copies all the adapter callbacks from `source`.\r\n   *\r\n   * @param source  An Adapter to copy items from\r\n   */\n\n\n  Adapter.prototype.copyFrom = function (source) {\n    var _this = this;\n\n    $iter.each(source._callbacks.iterator(), function (x) {\n      _this.add(x.key, x.callback, x.priority, x.scope);\n    });\n  };\n  /**\r\n   * Clears all callbacks from this Adapter.\r\n   */\n\n\n  Adapter.prototype.clear = function () {\n    this._callbacks.clear();\n  };\n\n  return Adapter;\n}();\n\nexport { Adapter };","map":null,"metadata":{},"sourceType":"module"}