{"ast":null,"code":"/**\r\n * This functionality is related to the HTML wrapper that houses `<svg>` tag.\r\n */\nimport { Disposer } from \"../utils/Disposer\";\nimport { Popup } from \"../elements/Popup\";\nimport { Modal } from \"../elements/Modal\";\nimport { ListTemplate, ListDisposer } from \"../utils/List\";\nimport * as $utils from \"../utils/Utils\";\nimport * as $dom from \"../utils/DOM\";\nimport * as $array from \"../utils/Array\";\nimport * as $type from \"../utils/Type\";\nimport ResizeSensor from \"css-element-queries/src/ResizeSensor\";\n/**\r\n * ============================================================================\r\n * MAIN CLASS\r\n * ============================================================================\r\n * @hidden\r\n */\n\n/**\r\n * A array of all SVG Containers (one SVG container per chart instance).\r\n *\r\n * @ignore Exclude from docs\r\n */\n\nexport var svgContainers = [];\n/**\r\n * A class used to create an HTML wrapper for the SVG contents.\r\n */\n\nvar SVGContainer =\n/** @class */\nfunction () {\n  /**\r\n   * Constructor\r\n   *\r\n   * * Creates an HTML wrapper for SVG\r\n   */\n  function SVGContainer(htmlElement, ghost) {\n    var _this = this;\n    /**\r\n     * Indicates if this object has already been deleted. Any\r\n     * destruction/disposal code should take this into account when deciding\r\n     * wheter to run potentially costly disposal operations if they already have\r\n     * been run.\r\n     */\n\n\n    this._disposed = false;\n    /**\r\n     * If this component is in a separate HTML container, `autoResize` means the\r\n     * module will constantly measure container's size and adopt contents to it.\r\n     */\n\n    this.autoResize = true;\n    /**\r\n     * Holds list of references to [[Sprite]] objects that should not be exported\r\n     * when exporting chart to an image.\r\n     *\r\n     * @ignore\r\n     */\n\n    this.nonExportableSprites = [];\n    /**\r\n     * List of objects that need to be disposed when this one is disposed.\r\n     */\n\n    this._disposers = [];\n    this.cssScale = 1; // Log parent HTML element\n\n    this.htmlElement = htmlElement;\n\n    if (!ghost) {\n      var callback_1 = function () {\n        if (_this.autoResize) {\n          _this.measure();\n        }\n      };\n\n      this.resizeSensor = new ResizeSensor(htmlElement, callback_1);\n\n      this._disposers.push(new Disposer(function () {\n        _this.resizeSensor.detach(callback_1);\n      }));\n    } // Adds to containers array\n\n\n    svgContainers.push(this);\n    /**\r\n     * Create child div for the container - it will have svg node\r\n     * It might seem that this container is not necessay, however having it solves\r\n     * a problems with mouse position detection and some other.\r\n     */\n\n    var svgContainer = document.createElement(\"div\");\n    var style = svgContainer.style;\n    style.width = \"100%\";\n    style.height = \"100%\";\n    style.position = \"relative\";\n    htmlElement.appendChild(svgContainer);\n    this.SVGContainer = svgContainer;\n  }\n  /**\r\n   * Measures size of parent HTML element.\r\n   *\r\n   * @ignore Exclude from docs\r\n   */\n\n\n  SVGContainer.prototype.measure = function () {\n    var width = $utils.width(this.htmlElement);\n    var height = $utils.height(this.htmlElement);\n    var container = this.container;\n\n    if (container) {\n      if (this.width != width || this.height != height) {\n        this.width = width;\n        this.height = height;\n\n        if (width > 0) {\n          container.maxWidth = width;\n        }\n\n        if (height > 0) {\n          container.maxHeight = height;\n        }\n\n        $dom.fixPixelPerfect(this.SVGContainer);\n      }\n\n      if (!container.maxWidth) {\n        container.maxWidth = 0;\n      }\n\n      if (!container.maxHeight) {\n        container.maxHeight = 0;\n      }\n\n      this.cssScale = 1;\n      this.checkTransform(this.htmlElement);\n    }\n  };\n\n  Object.defineProperty(SVGContainer.prototype, \"container\", {\n    /**\r\n     * @return Container\r\n     */\n    get: function () {\n      return this._container;\n    },\n\n    /**\r\n     * A [[Container]] element which is placed into container.\r\n     *\r\n     * @param container  Container\r\n     */\n    set: function (container) {\n      this._container = container;\n      this.measure();\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\r\n   * Returns if this object has been already been disposed.\r\n   *\r\n   * @return Is disposed?\r\n   */\n\n  SVGContainer.prototype.isDisposed = function () {\n    return this._disposed;\n  };\n  /**\r\n   * Removes this container from SVG container list in system, which\r\n   * effectively disables size change monitoring for it.\r\n   */\n\n\n  SVGContainer.prototype.dispose = function () {\n    if (!this._disposed) {\n      $array.remove(svgContainers, this);\n    }\n\n    $array.each(this._disposers, function (item) {\n      item.dispose();\n    });\n  };\n\n  Object.defineProperty(SVGContainer.prototype, \"hideOverflow\", {\n    /**\r\n     * Indicates if chart container should have its style set\r\n     * to `overflow: hidden`.\r\n     *\r\n     * Normally, we don't want that, so that certain elements, such as tooltips,\r\n     * would be able to go outside chart area.\r\n     *\r\n     * There is one issue though. Some browsers ignore SVG masks and would\r\n     * display scrollbars if chart elements, that go outside chart area extend\r\n     * outside window.\r\n     *\r\n     * This is especially true for [[MapChart]], which can have its elements\r\n     * extend very widely when zoomed in. Even if those parts are not visible\r\n     * because of SVG masks, some browsers might still display window scrollbars.\r\n     *\r\n     * This is why we set this setting to `true` in [[MapChart]].\r\n     *\r\n     * Other charts use default of `false`.\r\n     */\n    set: function (value) {\n      if (value) {\n        this.SVGContainer.style.overflow = \"hidden\";\n      } else {\n        this.SVGContainer.style.overflow = \"\";\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(SVGContainer.prototype, \"modal\", {\n    /**\r\n     * ==========================================================================\r\n     * MODAL/POPUP RELATED STUFF\r\n     * ==========================================================================\r\n     * @hidden\r\n     */\n\n    /**\r\n     * Returns a [[Modal]] instance, associated with this chart.\r\n     * (elements top parent)\r\n     *\r\n     * Accessing modal does not make it appear. To make a modal appear, use\r\n     * `showModal()` method.\r\n     *\r\n     * @see {@link Modal} for more information about using Modal windows\r\n     * @return Modal instance\r\n     */\n    get: function () {\n      if (!$type.hasValue(this._modal)) {\n        // Create new modal\n        this._modal = new Modal();\n        this._modal.container = this.SVGContainer; // Add to disposers\n\n        this._disposers.push(this._modal);\n      }\n\n      return this._modal;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\r\n   * Opens a modal window with specific content (`text` parameter) and,\r\n   * optionally, `title`.\r\n   *\r\n   * The `text` parameter can contain HTML content.\r\n   *\r\n   * @see {@link Modal} for more information about using Modal windows\r\n   * @param text   Modal contents\r\n   * @param title  Title for the modal window\r\n   */\n\n  SVGContainer.prototype.openModal = function (text, title) {\n    // Hide previous modal\n    this.closeModal(); // Create modal\n\n    var modal = this.modal;\n    modal.content = text;\n    modal.readerTitle = title;\n    modal.open();\n    return modal;\n  };\n  /**\r\n   * Hides modal window if there is one currently open.\r\n   */\n\n\n  SVGContainer.prototype.closeModal = function () {\n    if (this._modal) {\n      this.modal.close();\n    }\n  };\n\n  Object.defineProperty(SVGContainer.prototype, \"popups\", {\n    /**\r\n     * A list of popups for this chart.\r\n     *\r\n     * @return Popups\r\n     */\n    get: function () {\n      if (!$type.hasValue(this._popups)) {\n        // Create popup template\n        var popupTemplate = new Popup();\n        popupTemplate.container = this.SVGContainer; // Create the list\n\n        this._popups = new ListTemplate(popupTemplate); // Add to disposers\n\n        this._disposers.push(new ListDisposer(this._popups));\n\n        this._disposers.push(this._popups.template);\n      }\n\n      return this._popups;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\r\n   * Creates, opens, and returns a new [[Popup]] window.\r\n   *\r\n   * `text` can be any valid HTML.\r\n   *\r\n   * `title` is currently not supported.\r\n   *\r\n   * @param text   Popup contents\r\n   * @param title  Popup title\r\n   * @return Popup instance\r\n   */\n\n  SVGContainer.prototype.openPopup = function (text, title) {\n    var popup = this.popups.create();\n    popup.content = text;\n\n    if ($type.hasValue(title)) {\n      popup.title = title;\n    }\n\n    popup.open();\n    return popup;\n  };\n  /**\r\n   * Closes all currently open popup windows\r\n   */\n\n\n  SVGContainer.prototype.closeAllPopups = function () {\n    this.popups.each(function (popup) {\n      popup.close();\n    });\n  };\n\n  SVGContainer.prototype.checkTransform = function (div) {\n    if (window.getComputedStyle) {\n      if (div && div.style) {\n        var style = window.getComputedStyle(div, null);\n\n        if (style) {\n          var matrix = style.getPropertyValue(\"-webkit-transform\") || style.getPropertyValue(\"-moz-transform\") || style.getPropertyValue(\"-ms-transform\") || style.getPropertyValue(\"-o-transform\") || style.getPropertyValue(\"transform\");\n\n          if (matrix && matrix !== \"none\") {\n            var values = matrix.split('(')[1].split(')')[0].split(',');\n            var a = Number(values[0]);\n            var b = Number(values[1]);\n            var scale = Math.sqrt(a * a + b * b);\n\n            if (!isNaN(scale)) {\n              this.cssScale *= scale;\n            }\n          }\n        }\n      }\n\n      if (div.parentNode && div.parentNode instanceof HTMLElement) {\n        this.checkTransform(div.parentNode);\n      }\n    }\n  };\n\n  return SVGContainer;\n}();\n\nexport { SVGContainer };","map":null,"metadata":{},"sourceType":"module"}