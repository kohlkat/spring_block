{"ast":null,"code":"/**\r\n * Handles date and time formatting\r\n */\nimport * as tslib_1 from \"tslib\";\nimport { Language } from \"../utils/Language\";\nimport { BaseObject } from \"../Base\";\nimport { getTextFormatter } from \"../formatters/TextFormatter\";\nimport { registry } from \"../Registry\";\nimport * as $strings from \"../utils/Strings\";\nimport * as $utils from \"../utils/Utils\";\nimport * as $type from \"../utils/Type\";\n/**\r\n * Handles date and time formatting.\r\n *\r\n * @see {@link https://www.amcharts.com/docs/v4/concepts/formatters/formatting-date-time/} Tutorial on date/time formatting\r\n * @todo Better type casting of passed in date?\r\n * @todo Quarter support?\r\n * @todo When parsing named months make the search case-insensitive\r\n * @todo Escape a.m./p.m. properly when used in RegEx\r\n */\n\nvar DateFormatter =\n/** @class */\nfunction (_super) {\n  tslib_1.__extends(DateFormatter, _super);\n  /**\r\n   * Constructor\r\n   */\n\n\n  function DateFormatter() {\n    var _this = _super.call(this) || this;\n    /**\r\n     * Date format.\r\n     */\n\n\n    _this._dateFormat = \"yyyy-MM-dd\";\n    /**\r\n     * Input date format.\r\n     */\n\n    _this._inputDateFormat = \"yyyy-MM-dd\";\n    /**\r\n     * Assume UTC time zone.\r\n     */\n\n    _this._utc = false;\n    /**\r\n     * First day of week.\r\n     *\r\n     * 0 - Sunday\r\n     * 1 - Monday\r\n     *\r\n     * Etc.\r\n     */\n\n    _this._firstDayOfWeek = 1;\n    /**\r\n     * A list of month names.\r\n     */\n\n    _this._months = [\"January\", \"February\", \"March\", \"April\", \"May\", \"June\", \"July\", \"August\", \"September\", \"October\", \"November\", \"December\"];\n    /**\r\n     * A list of short month names.\r\n     *\r\n     * @param {Array<ShortMonthNames>}\r\n     */\n\n    _this._monthsShort = [\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May(short)\", \"Jun\", \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\"];\n    /**\r\n     * A list of weekday names.\r\n     */\n\n    _this._weekdays = [\"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\"];\n    /**\r\n     * A list of short weekday names.\r\n     */\n\n    _this._weekdaysShort = [\"Sun\", \"Mon\", \"Tue\", \"Wed\", \"Thu\", \"Fri\", \"Sat\"];\n    /**\r\n     * Output format to produce. If the format calls for applying color to the\r\n     * formatted value, this setting will determine what markup to use: SVG or\r\n     * HTML.\r\n     *\r\n     * Available options: svg, html.\r\n     *\r\n     * @default \"svg\"\r\n     */\n\n    _this._outputFormat = \"svg\";\n    /**\r\n     * Should the first letter of the formatted date be capitalized?\r\n     *\r\n     * @default true\r\n     */\n\n    _this.capitalize = true;\n    _this.className = \"DateFormatter\";\n\n    _this.applyTheme();\n\n    return _this;\n  }\n\n  Object.defineProperty(DateFormatter.prototype, \"language\", {\n    /**\r\n     * @return Language\r\n     */\n    get: function () {\n      return this._language;\n    },\n\n    /**\r\n     * A reference to [[Language]] object.\r\n     *\r\n     * @param  value  Language\r\n     */\n    set: function (value) {\n      this._language = value;\n      this.dateFormat = this._language.translate(\"_date\");\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\r\n   * Formats the date value according to specified format.\r\n   *\r\n   * @see {@link https://www.amcharts.com/docs/v4/concepts/formatters/formatting-date-time/} Tutorial on date/time formatting\r\n   * @param source  Date value\r\n   * @param format  Format\r\n   * @return Formatted date string\r\n   */\n\n  DateFormatter.prototype.format = function (source, format) {\n    // No language?\n    if (!this.language) {\n      if (this.sprite) {\n        this.language = this.sprite.language;\n      } else {\n        this.language = new Language();\n      }\n    } // No format passed in or it's empty\n\n\n    if (typeof format === \"undefined\" || format === \"\") {\n      format = this._dateFormat;\n    } // Init return value\n\n\n    var formatted; // Do casting if required\n    // This will take care of timestamps as well as Date objects\n\n    var date;\n\n    if ($type.isString(source)) {\n      // If it's a string, let's try parsing it using our own functionality\n      date = this.parse(source);\n    } else {\n      date = $utils.anyToDate(source);\n    } // Is it a built-in format or Intl.DateTimeFormat\n\n\n    if (format instanceof Object) {\n      if (this.intlLocales) {\n        return new Intl.DateTimeFormat(this.intlLocales, format).format(date);\n      } else {\n        return new Intl.DateTimeFormat(undefined, format).format(date);\n      }\n    } else {\n      // Clean format\n      format = $utils.cleanFormat(format); // get format info (it will also deal with parser caching)\n\n      var info = this.parseFormat(format); // Should we apply custom time zone?\n\n      if ($type.hasValue(this.timezoneOffset)) {\n        date.setMinutes(date.getMinutes() + date.getTimezoneOffset() - this.timezoneOffset);\n      } // Check if it's a valid date\n\n\n      if (!$type.isNumber(date.getTime())) {\n        return this.language.translate(\"Invalid date\");\n      } // Apply format\n\n\n      formatted = this.applyFormat(date, info, this.language); // Capitalize\n\n      if (this.capitalize) {\n        formatted = formatted.replace(/^.{1}/, formatted.substr(0, 1).toUpperCase());\n      }\n    } // We're done\n\n\n    return formatted;\n  };\n  /**\r\n   * Parses format into structured infromation.\r\n   *\r\n   * @param format Format template\r\n   */\n\n\n  DateFormatter.prototype.parseFormat = function (format) {\n    // Check cache\n    var cached = this.getCache(format);\n\n    if ($type.hasValue(cached)) {\n      return cached;\n    } // Init format parse info holder\n\n\n    var info = {\n      \"template\": \"\",\n      \"parts\": []\n    }; // Let TextFormatter split into chunks\n\n    var chunks = getTextFormatter().chunk(format, true);\n\n    for (var i = 0; i < chunks.length; i++) {\n      var chunk = chunks[i];\n\n      if (chunk.type === \"value\") {\n        // Just \"Date\"?\n        if (chunk.text.match(/^date$/i) && $type.isString(this._dateFormat)) {\n          chunk.text = this._dateFormat;\n        } // Find all possible parts\n\n\n        var matches = chunk.text.match(/G|yyyy|yyy|yy|y|YYYY|YYY|YY|Y|u|MMMMM|MMMM|MMM|MM|M|ww|w|W|dd|d|DDD|DD|D|F|g|EEEEE|EEEE|EEE|EE|E|eeeee|eeee|eee|ee|e|aaa|aa|a|hh|h|HH|H|KK|K|kk|k|mm|m|ss|s|SSS|SS|S|A|zzzz|zzz|zz|z|ZZ|Z|t|x|nnn|nn|n|i|I/g); // Found?\n\n        if (matches) {\n          // Populate template\n          for (var x = 0; x < matches.length; x++) {\n            info.parts.push(matches[x]);\n            chunk.text = chunk.text.replace(matches[x], $strings.PLACEHOLDER);\n          }\n        }\n      } // Apply to template\n\n\n      info.template += chunk.text;\n    } // Apply style formatting\n    //info.template = getTextFormatter().format(info.template, this.outputFormat);\n    // Save cache\n\n\n    this.setCache(format, info);\n    return info;\n  };\n  /**\r\n   * Applies format to Date.\r\n   *\r\n   * @param date      Date object\r\n   * @param info      Parsed format information\r\n   * @param language  Language\r\n   * @return Formatted date string\r\n   */\n\n\n  DateFormatter.prototype.applyFormat = function (date, info, language) {\n    // Init return value\n    var res = info.template; // Get values\n\n    var fullYear,\n        month,\n        weekday,\n        day,\n        hours,\n        minutes,\n        seconds,\n        milliseconds,\n        offset = date.getTimezoneOffset(),\n        timestamp = date.getTime();\n\n    if (this.utc) {\n      fullYear = date.getUTCFullYear();\n      month = date.getUTCMonth();\n      weekday = date.getUTCDay();\n      day = date.getUTCDate();\n      hours = date.getUTCHours();\n      minutes = date.getUTCMinutes();\n      seconds = date.getUTCSeconds();\n      milliseconds = date.getUTCMilliseconds();\n    } else {\n      fullYear = date.getFullYear();\n      month = date.getMonth();\n      weekday = date.getDay();\n      day = date.getDate();\n      hours = date.getHours();\n      minutes = date.getMinutes();\n      seconds = date.getSeconds();\n      milliseconds = date.getMilliseconds();\n    } // Go through each part and format/replace it in template\n\n\n    for (var i = 0, len = info.parts.length; i < len; i++) {\n      var value = \"\";\n\n      switch (info.parts[i]) {\n        case \"G\":\n          value = language.translate(fullYear < 0 ? \"_era_bc\" : \"_era_ad\");\n          break;\n\n        case \"yyyy\":\n          value = Math.abs(fullYear).toString();\n\n          if (fullYear < 0) {\n            value += language.translate(\"_era_bc\");\n          }\n\n          break;\n\n        case \"yyy\":\n        case \"yy\":\n        case \"y\":\n          value = Math.abs(fullYear).toString().substr(-info.parts[i].length);\n\n          if (fullYear < 0) {\n            value += language.translate(\"_era_bc\");\n          }\n\n          break;\n\n        case \"YYYY\":\n        case \"YYY\":\n        case \"YY\":\n        case \"Y\":\n          var week = $utils.getWeek(date);\n          var year = fullYear;\n\n          if (week == 1 && weekday > 1) {\n            year--;\n          }\n\n          if (info.parts[i] == \"YYYY\") {\n            value = Math.abs(year).toString();\n          } else {\n            value = Math.abs(year).toString().substr(-info.parts[i].length);\n          }\n\n          if (year < 0) {\n            value += language.translate(\"_era_bc\");\n          }\n\n          break;\n\n        case \"u\":\n          // @todo\n          break;\n\n        case \"MMMMM\":\n          value = language.translate(this._months[month]).substr(0, 1);\n          break;\n\n        case \"MMMM\":\n          value = language.translate(this._months[month]);\n          break;\n\n        case \"MMM\":\n          value = language.translate(this._monthsShort[month]);\n          break;\n\n        case \"MM\":\n          value = $utils.padString(month + 1, 2, \"0\");\n          break;\n\n        case \"M\":\n          value = (month + 1).toString();\n          break;\n\n        case \"ww\":\n          value = $utils.padString($utils.getWeek(date, this.utc), 2, \"0\");\n          break;\n\n        case \"w\":\n          value = $utils.getWeek(date, this.utc).toString();\n          break;\n\n        case \"W\":\n          value = $utils.getMonthWeek(date, this.utc).toString();\n          break;\n\n        case \"dd\":\n          value = $utils.padString(day, 2, \"0\");\n          break;\n\n        case \"d\":\n          value = day.toString();\n          break;\n\n        case \"DD\":\n        case \"DDD\":\n          value = $utils.padString($utils.getYearDay(date, this.utc).toString(), info.parts[i].length, \"0\");\n          break;\n\n        case \"D\":\n          value = $utils.getYearDay(date, this.utc).toString();\n          break;\n\n        case \"F\":\n          // @todo\n          break;\n\n        case \"g\":\n          // @todo\n          break;\n\n        case \"t\":\n          value = language.translateFunc(\"_dateOrd\").call(this, day);\n          break;\n\n        case \"E\":\n          value = (weekday || 7).toString();\n          break;\n\n        case \"EE\":\n          value = $utils.padString((weekday || 7).toString(), 2, \"0\");\n          break;\n\n        case \"EEE\":\n        case \"eee\":\n          value = language.translate(this._weekdaysShort[weekday]);\n          break;\n\n        case \"EEEE\":\n        case \"eeee\":\n          value = language.translate(this._weekdays[weekday]);\n          break;\n\n        case \"EEEEE\":\n        case \"eeeee\":\n          value = language.translate(this._weekdays[weekday]).substr(0, 1);\n          break;\n\n        case \"e\":\n        case \"ee\":\n          value = (weekday - this.firstDayOfWeek + 1).toString();\n\n          if (info.parts[i] == \"ee\") {\n            value = $utils.padString(value, 2, \"0\");\n          }\n\n          break;\n\n        case \"a\":\n          if (hours >= 12) {\n            value = language.translate(\"PM\");\n          } else {\n            value = language.translate(\"AM\");\n          }\n\n          break;\n\n        case \"aa\":\n          if (hours >= 12) {\n            value = language.translate(\"P.M.\");\n          } else {\n            value = language.translate(\"A.M.\");\n          }\n\n          break;\n\n        case \"aaa\":\n          if (hours >= 12) {\n            value = language.translate(\"P\");\n          } else {\n            value = language.translate(\"A\");\n          }\n\n          break;\n\n        case \"h\":\n          value = $utils.get12Hours(hours).toString();\n          break;\n\n        case \"hh\":\n          value = $utils.padString($utils.get12Hours(hours), 2, \"0\");\n          break;\n\n        case \"H\":\n          value = hours.toString();\n          break;\n\n        case \"HH\":\n          value = $utils.padString(hours, 2, \"0\");\n          break;\n\n        case \"K\":\n          value = $utils.get12Hours(hours, 0).toString();\n          break;\n\n        case \"KK\":\n          value = $utils.padString($utils.get12Hours(hours, 0), 2, \"0\");\n          break;\n\n        case \"k\":\n          value = (hours + 1).toString();\n          break;\n\n        case \"kk\":\n          value = $utils.padString(hours + 1, 2, \"0\");\n          break;\n\n        case \"m\":\n          value = minutes.toString();\n          break;\n\n        case \"mm\":\n          value = $utils.padString(minutes, 2, \"0\");\n          break;\n\n        case \"s\":\n          value = seconds.toString();\n          break;\n\n        case \"ss\":\n          value = $utils.padString(seconds, 2, \"0\");\n          break;\n\n        case \"S\":\n        case \"SS\":\n        case \"SSS\":\n          value = Math.round(milliseconds / 1000 * Math.pow(10, info.parts[i].length)).toString();\n          break;\n\n        case \"x\":\n          value = timestamp.toString();\n          break;\n\n        case \"n\":\n        case \"nn\":\n        case \"nnn\":\n          value = $utils.padString(milliseconds, info.parts[i].length, \"0\");\n          break;\n\n        case \"z\":\n          value = $utils.getTimeZone(date, false, false, this.utc);\n          break;\n\n        case \"zz\":\n          value = $utils.getTimeZone(date, true, false, this.utc);\n          break;\n\n        case \"zzz\":\n          value = $utils.getTimeZone(date, false, true, this.utc);\n          break;\n\n        case \"zzzz\":\n          value = $utils.getTimeZone(date, true, true, this.utc);\n          break;\n\n        case \"Z\":\n        case \"ZZ\":\n          var tz = Math.abs(offset) / 60;\n          var tzh = Math.floor(tz);\n          var tzm = tz * 60 - tzh * 60;\n\n          if (this.utc) {\n            tzh = 0;\n            tzm = 0;\n          }\n\n          if (info.parts[i] == \"Z\") {\n            value = \"GMT\";\n            value += offset > 0 ? \"-\" : \"+\";\n            value += $utils.padString(tzh, 2) + \":\" + $utils.padString(tzm, 2);\n          } else {\n            value = offset > 0 ? \"-\" : \"+\";\n            value += $utils.padString(tzh, 2) + $utils.padString(tzm, 2);\n          }\n\n          break;\n\n        case \"i\":\n          value = date.toISOString();\n          break;\n\n        case \"I\":\n          value = date.toUTCString();\n          break;\n      }\n\n      res = res.replace($strings.PLACEHOLDER, value);\n    }\n\n    return res;\n  };\n  /**\r\n   * Parses any input value into Date object.\r\n   *\r\n   * @see {@link https://www.amcharts.com/docs/v4/concepts/formatters/formatting-date-time/#Parsing_Dates} Tutorial on date/time parsing\r\n   * @param source  Source value\r\n   * @param format  Source format\r\n   * @return Date object\r\n   */\n\n\n  DateFormatter.prototype.parse = function (source, format) {\n    // Format set?\n    if (!$type.hasValue(format)) {\n      format = this.inputDateFormat;\n    } // Is it already a Date\n\n\n    if (source instanceof Date) {\n      return source;\n    } // Is it a numeric timestamp\n\n\n    if (typeof source === \"number\") {\n      return new Date(source);\n    } // No? Let's check if it's string, and try converting to it if nec\n\n\n    if (typeof source !== \"string\") {\n      source = source.toString();\n    } // no language?\n\n\n    if (!this.language) {\n      if (this.sprite) {\n        this.language = this.sprite.language;\n      } else {\n        this.language = new Language();\n      }\n    } // Init return value\n\n\n    var res; // Init RegEx for parsing\n\n    var reg = \"\"; // Clean format\n\n    format = $utils.cleanFormat(format); // Clip format to length of the source string\n\n    format = format.substr(0, source.length); // Parse format\n\n    var info = this.parseFormat(format); // Init parsed items holder\n\n    var parsedIndexes = {\n      \"year\": -1,\n      \"year3\": -1,\n      \"year2\": -1,\n      \"year1\": -1,\n      \"month\": -1,\n      \"monthShort\": -1,\n      \"monthLong\": -1,\n      \"weekdayShort\": -1,\n      \"weekdayLong\": -1,\n      \"day\": -1,\n      \"yearDay\": -1,\n      \"week\": -1,\n      \"hourBase0\": -1,\n      \"hour12Base0\": -1,\n      \"hourBase1\": -1,\n      \"hour12Base1\": -1,\n      \"minute\": -1,\n      \"second\": -1,\n      \"millisecond\": -1,\n      \"millisecondDigits\": -1,\n      \"am\": -1,\n      \"zone\": -1,\n      \"timestamp\": -1,\n      \"iso\": -1\n    }; // Init values\n\n    var resValues = {\n      \"year\": 1970,\n      \"month\": 0,\n      \"day\": 1,\n      \"hour\": 0,\n      \"minute\": 0,\n      \"second\": 0,\n      \"millisecond\": 0,\n      \"timestamp\": null,\n      \"offset\": 0,\n      \"utc\": this.utc\n    }; // Index adjuster\n\n    var indexAdjust = 0,\n        index = 0; // Iterate through all of the parts\n\n    for (var i = 0; i < info.parts.length; i++) {\n      // Set current match index\n      index = i + indexAdjust + 1;\n\n      switch (info.parts[i]) {\n        case \"yyyy\":\n        case \"YYYY\":\n          reg += \"([0-9]{4})\";\n          parsedIndexes.year = index;\n          break;\n\n        case \"yyy\":\n        case \"YYY\":\n          reg += \"([0-9]{3})\";\n          parsedIndexes.year3 = index;\n          break;\n\n        case \"yy\":\n        case \"YY\":\n          reg += \"([0-9]{2})\";\n          parsedIndexes.year2 = index;\n          break;\n\n        case \"y\":\n        case \"Y\":\n          reg += \"([0-9]{1})\";\n          parsedIndexes.year1 = index;\n          break;\n\n        case \"MMMM\":\n          reg += \"(\" + this.getStringList(this._months).join(\"|\") + \")\";\n          parsedIndexes.monthLong = index;\n          break;\n\n        case \"MMM\":\n          reg += \"(\" + this.getStringList(this._monthsShort).join(\"|\") + \")\";\n          parsedIndexes.monthShort = index;\n          break;\n\n        case \"MM\":\n        case \"M\":\n          reg += \"([0-9]{2}|[0-9]{1})\";\n          parsedIndexes.month = index;\n          break;\n\n        case \"ww\":\n        case \"w\":\n          reg += \"([0-9]{2}|[0-9]{1})\";\n          parsedIndexes.week = index;\n          break;\n\n        case \"dd\":\n        case \"d\":\n          reg += \"([0-9]{2}|[0-9]{1})\";\n          parsedIndexes.day = index;\n          break;\n\n        case \"DDD\":\n        case \"DD\":\n        case \"D\":\n          reg += \"([0-9]{3}|[0-9]{2}|[0-9]{1})\";\n          parsedIndexes.yearDay = index;\n          break;\n\n        case \"dddd\":\n          reg += \"(\" + this.getStringList(this._weekdays).join(\"|\") + \")\";\n          parsedIndexes.weekdayLong = index;\n          break;\n\n        case \"ddd\":\n          reg += \"(\" + this.getStringList(this._weekdaysShort).join(\"|\") + \")\";\n          parsedIndexes.weekdayShort = index;\n          break;\n\n        case \"aaa\":\n        case \"aa\":\n        case \"a\":\n          // TODO: fix (escape regex)\n          reg += \"(\" + this.getStringList([\"AM\", \"PM\", \"A\\.M\\.\", \"P\\.M\\.\", \"A\", \"P\"]).join(\"|\") + \")\";\n          parsedIndexes.am = index;\n          break;\n\n        case \"hh\":\n        case \"h\":\n          reg += \"([0-9]{2}|[0-9]{1})\";\n          parsedIndexes.hour12Base1 = index;\n          break;\n\n        case \"HH\":\n        case \"H\":\n          reg += \"([0-9]{2}|[0-9]{1})\";\n          parsedIndexes.hourBase0 = index;\n          break;\n\n        case \"KK\":\n        case \"K\":\n          reg += \"([0-9]{2}|[0-9]{1})\";\n          parsedIndexes.hour12Base0 = index;\n          break;\n\n        case \"kk\":\n        case \"k\":\n          reg += \"([0-9]{2}|[0-9]{1})\";\n          parsedIndexes.hourBase1 = index;\n          break;\n\n        case \"mm\":\n        case \"m\":\n          reg += \"([0-9]{2}|[0-9]{1})\";\n          parsedIndexes.minute = index;\n          break;\n\n        case \"ss\":\n        case \"s\":\n          reg += \"([0-9]{2}|[0-9]{1})\";\n          parsedIndexes.second = index;\n          break;\n\n        case \"SSS\":\n        case \"SS\":\n        case \"S\":\n          reg += \"([0-9]{3}|[0-9]{2}|[0-9]{1})\";\n          parsedIndexes.millisecond = index;\n          parsedIndexes.millisecondDigits = info.parts[i].length;\n          break;\n\n        case \"nnn\":\n        case \"nn\":\n        case \"n\":\n          reg += \"([0-9]{3}|[0-9]{2}|[0-9]{1})\";\n          parsedIndexes.millisecond = index;\n          break;\n\n        case \"x\":\n          reg += \"([0-9]{1,})\";\n          parsedIndexes.timestamp = index;\n          break;\n\n        case \"Z\":\n          reg += \"GMT([-+]+[0-9]{2}:[0-9]{2})\";\n          parsedIndexes.zone = index;\n          break;\n\n        case \"ZZ\":\n          reg += \"([\\\\-+]+[0-9]{2}[0-9]{2})\";\n          parsedIndexes.zone = index;\n          break;\n\n        case \"i\":\n          reg += \"([0-9]{4})-([0-9]{2})-([0-9]{2})T([0-9]{2}):([0-9]{2}):([0-9]{2})\\.([0-9]{3})([Zz]?)\";\n          parsedIndexes.iso = index;\n          indexAdjust += 7;\n          break;\n\n        case \"G\":\n        case \"YYYY\":\n        case \"YYY\":\n        case \"YY\":\n        case \"Y\":\n        case \"MMMMM\":\n        case \"W\":\n        case \"EEEEE\":\n        case \"EEEE\":\n        case \"EEE\":\n        case \"EE\":\n        case \"E\":\n        case \"eeeee\":\n        case \"eeee\":\n        case \"eee\":\n        case \"ee\":\n        case \"e\":\n        case \"zzzz\":\n        case \"zzz\":\n        case \"zz\":\n        case \"z\":\n        case \"t\":\n          // Ignore\n          indexAdjust--;\n          break;\n      }\n\n      reg += \"[^0-9]*\";\n    } // Try matching\n\n\n    var regex = new RegExp(reg);\n    var matches = source.match(regex);\n\n    if (matches) {\n      // Populate the date object\n      // Full year\n      if (parsedIndexes.year > -1) {\n        resValues.year = parseInt(matches[parsedIndexes.year]);\n      } // 3-digit year\n\n\n      if (parsedIndexes.year3 > -1) {\n        var val = parseInt(matches[parsedIndexes.year3]);\n        val += 1000;\n        resValues.year = val;\n      } // 2-digit year\n\n\n      if (parsedIndexes.year2 > -1) {\n        var val = parseInt(matches[parsedIndexes.year2]);\n\n        if (val > 50) {\n          val += 1000;\n        } else {\n          val += 2000;\n        }\n\n        resValues.year = val;\n      } // 1-digit year\n\n\n      if (parsedIndexes.year1 > -1) {\n        var val = parseInt(matches[parsedIndexes.year1]);\n        val = Math.floor(new Date().getFullYear() / 10) * 10 + val;\n        resValues.year = val;\n      } // Full month\n\n\n      if (parsedIndexes.monthLong > -1) {\n        resValues.month = this.resolveMonth(matches[parsedIndexes.monthLong]);\n      } // Short month\n\n\n      if (parsedIndexes.monthShort > -1) {\n        resValues.month = this.resolveShortMonth(matches[parsedIndexes.monthShort]);\n      } // Numeric month\n\n\n      if (parsedIndexes.month > -1) {\n        resValues.month = parseInt(matches[parsedIndexes.month]) - 1;\n      } // Weekday\n      // @todo\n      // Week\n\n\n      if (parsedIndexes.week > -1 && parsedIndexes.day === -1) {\n        // We parse weeks ONLY if day is not explicitly set\n        // TODO: this needs work\n        // (but maybe later - I can hardly imagine anyone passing their dates in weeks)\n        resValues.month = 0;\n        resValues.day = $utils.getDayFromWeek(parseInt(matches[parsedIndexes.week]), resValues.year, 1, this.utc);\n      } // Day\n\n\n      if (parsedIndexes.day > -1) {\n        resValues.day = parseInt(matches[parsedIndexes.day]);\n      } // Year day\n\n\n      if (parsedIndexes.yearDay > -1) {\n        resValues.month = 0;\n        resValues.day = parseInt(matches[parsedIndexes.yearDay]);\n      } // 24 Hour (0-23)\n\n\n      if (parsedIndexes.hourBase0 > -1) {\n        resValues.hour = parseInt(matches[parsedIndexes.hourBase0]);\n      } // 24 Hour (1-24)\n\n\n      if (parsedIndexes.hourBase1 > -1) {\n        resValues.hour = parseInt(matches[parsedIndexes.hourBase1]) - 1;\n      } // 12 Hour (0-11)\n\n\n      if (parsedIndexes.hour12Base0 > -1) {\n        var val = parseInt(matches[parsedIndexes.hour12Base0]);\n\n        if (val == 11) {\n          val = 0;\n        }\n\n        if (parsedIndexes.am > -1 && !this.isAm(matches[parsedIndexes.am])) {\n          val += 12;\n        }\n\n        resValues.hour = val;\n      } // 12 Hour (1-12)\n\n\n      if (parsedIndexes.hour12Base1 > -1) {\n        var val = parseInt(matches[parsedIndexes.hour12Base1]);\n\n        if (val == 12) {\n          val = 0;\n        }\n\n        if (parsedIndexes.am > -1 && !this.isAm(matches[parsedIndexes.am])) {\n          val += 12;\n        }\n\n        resValues.hour = val;\n      } // Minute\n\n\n      if (parsedIndexes.minute > -1) {\n        resValues.minute = parseInt(matches[parsedIndexes.minute]);\n      } // Second\n\n\n      if (parsedIndexes.second > -1) {\n        resValues.second = parseInt(matches[parsedIndexes.second]);\n      } // Millisecond\n\n\n      if (parsedIndexes.millisecond > -1) {\n        var val = parseInt(matches[parsedIndexes.millisecond]);\n\n        if (parsedIndexes.millisecondDigits == 2) {\n          val *= 10;\n        } else if (parsedIndexes.millisecondDigits == 1) {\n          val *= 100;\n        }\n\n        resValues.millisecond = val;\n      } // Timestamp\n\n\n      if (parsedIndexes.timestamp > -1) {\n        resValues.timestamp = parseInt(matches[parsedIndexes.timestamp]);\n      } // Adjust time zone\n\n\n      if (parsedIndexes.zone > -1) {\n        var zone = matches[parsedIndexes.zone].replace(/:/, \"\");\n        var match = $type.getValue(zone.match(/([+\\-]?)([0-9]{2})([0-9]{2})/));\n        var dir = match[1];\n        var hour = match[2];\n        var minute = match[3];\n        var offset = parseInt(hour) * 60 + parseInt(minute); // Adjust offset\n        // Making it negative does not seem to make sense, but it's right\n        // because of how JavaScript calculates GTM offsets\n\n        if (dir == \"+\") {\n          offset *= -1;\n        } // Check the difference in offset\n\n\n        var originalOffset = new Date().getTimezoneOffset();\n        var diff = offset - originalOffset;\n        resValues.offset = diff;\n      } // ISO\n\n\n      if (parsedIndexes.iso > -1) {\n        if (matches[parsedIndexes.iso + 7] == \"Z\" || matches[parsedIndexes.iso + 7] == \"z\") {\n          resValues.utc = true;\n        }\n\n        resValues.year = $type.toNumber(matches[parsedIndexes.iso + 0]);\n        resValues.month = $type.toNumber(matches[parsedIndexes.iso + 1]) - 1;\n        resValues.day = $type.toNumber(matches[parsedIndexes.iso + 2]);\n        resValues.hour = $type.toNumber(matches[parsedIndexes.iso + 3]);\n        resValues.minute = $type.toNumber(matches[parsedIndexes.iso + 4]);\n        resValues.second = $type.toNumber(matches[parsedIndexes.iso + 5]);\n        resValues.millisecond = $type.toNumber(matches[parsedIndexes.iso + 6]);\n      } // Create Date object\n\n\n      if (resValues.utc) {\n        res = new Date(Date.UTC(resValues.year, resValues.month, resValues.day, resValues.hour, resValues.minute, resValues.second, resValues.millisecond));\n      } else {\n        res = new Date(resValues.year, resValues.month, resValues.day, resValues.hour, resValues.minute, resValues.second, resValues.millisecond);\n      }\n    } else {\n      // Didn't match anything\n      // Let's try dropping it into Date constructor and hope for the best\n      res = new Date(source);\n    }\n\n    return res;\n  };\n  /**\r\n   * Resolves month name (i.e. \"December\") into a month number (11).\r\n   *\r\n   * @param value  Month name\r\n   * @return Month number\r\n   */\n\n\n  DateFormatter.prototype.resolveMonth = function (value) {\n    // Let's try English first\n    var month = this._months.indexOf(value);\n\n    if (month > -1) {\n      return month;\n    } // Try the translation\n\n\n    if (this.language && !this.language.isDefault()) {\n      month = this.language.translateAll(this._months).indexOf(value);\n\n      if (month > -1) {\n        return month;\n      }\n    }\n\n    return 0;\n  };\n  /**\r\n   * Resolves short month name (i.e. \"Dec\") into a month number.\r\n   *\r\n   * @param value  Short month name\r\n   * @return Month number\r\n   */\n\n\n  DateFormatter.prototype.resolveShortMonth = function (value) {\n    // Let's try English first\n    var month = this._monthsShort.indexOf(value);\n\n    if (month > -1) {\n      return month;\n    } // Try the translation\n\n\n    if (this.language && !this.language.isDefault()) {\n      month = this.language.translateAll(this._monthsShort).indexOf(value);\n\n      if (month > -1) {\n        return month;\n      }\n    }\n\n    return 0;\n  };\n  /**\r\n   * Checks if passed in string represents AM/PM notation in many of its\r\n   * versions.\r\n   *\r\n   * @param value  Source string\r\n   * @return Is it AM/PM?\r\n   */\n\n\n  DateFormatter.prototype.isAm = function (value) {\n    var list = this.getStringList([\"AM\", \"A.M.\", \"A\"]);\n    return list.indexOf(value.toUpperCase()) > -1;\n  };\n  /**\r\n   * Invalidates related [[Sprite]] causing it to redraw.\r\n   */\n\n\n  DateFormatter.prototype.invalidateSprite = function () {\n    if (this.sprite) {\n      this.sprite.invalidate();\n    }\n  };\n  /**\r\n   * Translates list of strings.\r\n   *\r\n   * @param list  Source strings\r\n   * @return Translated strings\r\n   */\n\n\n  DateFormatter.prototype.getStringList = function (list) {\n    var res = [];\n\n    for (var i = 0; i < list.length; i++) {\n      res.push($utils.escapeForRgex(list[i])); // translate?\n\n      if (this.language && !this.language.isDefault()) {\n        res.push($utils.escapeForRgex(this.language.translate(list[i])));\n      }\n    }\n\n    return res;\n  };\n\n  Object.defineProperty(DateFormatter.prototype, \"dateFormat\", {\n    /**\r\n     * @return Date format\r\n     */\n    get: function () {\n      return this._dateFormat;\n    },\n\n    /**\r\n     * Date format to use.\r\n     *\r\n     * If format is not supplied in-line in the string, this setting will be\r\n     * used.\r\n     *\r\n     * @default \"yyyy-MM-dd\"\r\n     * @param value Date format\r\n     */\n    set: function (value) {\n      this._dateFormat = value;\n      this.invalidateSprite();\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(DateFormatter.prototype, \"inputDateFormat\", {\n    /**\r\n     * @return Date format\r\n     */\n    get: function () {\n      return this._inputDateFormat;\n    },\n\n    /**\r\n     * Date format to use when parsing dates.\r\n     *\r\n     * @default \"yyyy-MM-dd\"\r\n     * @param value Date format\r\n     */\n    set: function (value) {\n      this._inputDateFormat = value;\n      this.invalidateSprite();\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(DateFormatter.prototype, \"intlLocales\", {\n    /**\r\n     * @return Date format\r\n     */\n    get: function () {\n      return this._intlLocales;\n    },\n\n    /**\r\n     * Locales if you are using date formats in `Intl.DateTimeFormatOptions` syntax.\r\n     *\r\n     * @param value Locales\r\n     */\n    set: function (value) {\n      this._intlLocales = value;\n      this.invalidateSprite();\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(DateFormatter.prototype, \"utc\", {\n    /**\r\n     * @return Use UTC?\r\n     */\n    get: function () {\n      return this._utc;\n    },\n\n    /**\r\n     * Should formatter use UTC functions?\r\n     *\r\n     * If UTC is used, all date/time values will be independent on client's\r\n     * time zone.\r\n     *\r\n     * @param value Use UTC?\r\n     */\n    set: function (value) {\n      this._utc = value;\n      this.invalidateSprite();\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(DateFormatter.prototype, \"timezoneOffset\", {\n    /**\r\n     * @return Offset (minutes)\r\n     */\n    get: function () {\n      return this._timezoneOffset;\n    },\n\n    /**\r\n     * If set, will format date/time in specific time zone.\r\n     *\r\n     * The value is a number of minutes from target time zone to UTC.\r\n     *\r\n     * E.g. `300` will recalculate Dates in \"GMT-5\" time zone.\r\n     *\r\n     * @param  value  Offset (minutes)\r\n     */\n    set: function (value) {\n      if (this._timezoneOffset != value) {\n        this._timezoneOffset = value;\n        this.invalidateSprite();\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(DateFormatter.prototype, \"firstDayOfWeek\", {\n    /**\r\n     * @return First day of week\r\n     */\n    get: function () {\n      return this._firstDayOfWeek;\n    },\n\n    /**\r\n     * Dirst day of the week:\r\n     *\r\n     * * 0 - Sunday\r\n     * * 1 - Monday\r\n     * * 2 - Tuesday\r\n     *\r\n     * Etc.\r\n     *\r\n     * @param value First day of week\r\n     */\n    set: function (value) {\n      this._firstDayOfWeek = value;\n      this.invalidateSprite();\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(DateFormatter.prototype, \"outputFormat\", {\n    /**\r\n     * @ignore Exclude from docs\r\n     * @return Format\r\n     */\n    get: function () {\n      return this._outputFormat;\n    },\n\n    /**\r\n     * Output format for the formatted date.\r\n     *\r\n     * @ignore Exclude from docs\r\n     * @param value  Format\r\n     */\n    set: function (value) {\n      this._outputFormat = value.toLowerCase();\n      this.invalidateSprite();\n    },\n    enumerable: true,\n    configurable: true\n  });\n  return DateFormatter;\n}(BaseObject);\n\nexport { DateFormatter };\n/**\r\n * Register class in system, so that it can be instantiated using its name from\r\n * anywhere.\r\n *\r\n * @ignore\r\n */\n\nregistry.registeredClasses[\"DateFormatter\"] = DateFormatter;","map":null,"metadata":{},"sourceType":"module"}