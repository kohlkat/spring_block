{"ast":null,"code":"/**\r\n * This module contains funcitonality related to geographical projections\r\n */\nimport { registry } from \"../../../core/Registry\";\nimport * as $math from \"../../../core/utils/Math\";\nimport * as d3geo from \"d3-geo\";\n/**\r\n * ============================================================================\r\n * MAIN CLASS\r\n * ============================================================================\r\n * @hidden\r\n */\n\n/**\r\n * This is a base class for a geographical projection.\r\n */\n\nvar Projection =\n/** @class */\nfunction () {\n  function Projection() {\n    this.d3Projection = d3geo.geoEquirectangular();\n  }\n\n  Object.defineProperty(Projection.prototype, \"d3Projection\", {\n    /**\r\n     * d3 projection\r\n     */\n    get: function () {\n      return this._d3Projection;\n    },\n\n    /**\r\n     * d3 projection\r\n     */\n    set: function (projection) {\n      this._d3Projection = projection;\n      projection.precision(0.1);\n      this._d3Path = d3geo.geoPath().projection(projection);\n\n      if (this.chart) {\n        this.chart.invalidateProjection();\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Projection.prototype, \"d3Path\", {\n    /**\r\n     * d3 path generator method\r\n     * @ignore\r\n     */\n    get: function () {\n      return this._d3Path;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Projection.prototype, \"scale\", {\n    /**\r\n     * @ignore\r\n     */\n    get: function () {\n      return this.d3Projection.scale() / 100;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\r\n   * Converts a geographical point (lat/long) to a screen point (x/y)\r\n   * @param geoPoint Geo point (lat/long)\r\n   * @return Screen point (x/y)\r\n   */\n\n  Projection.prototype.convert = function (geoPoint) {\n    /*\r\n    geoPoint = $geo.normalizePoint(geoPoint);\r\n    geoPoint = this.rotate(geoPoint, this.deltaLongitude, this.deltaLatitude, this.deltaGama);\r\n    let pointInRadians: IPoint = this.project(geoPoint.longitude * $math.RADIANS, geoPoint.latitude * $math.RADIANS);\r\n    return {\r\n        x: $math.round(pointInRadians.x * $math.DEGREES - this.centerPoint.x, 4) * this.scale,\r\n        y: $math.round(-pointInRadians.y * $math.DEGREES - this.centerPoint.y, 4) * this.scale\r\n    };*/\n    var p = this.d3Projection([geoPoint.longitude, geoPoint.latitude]);\n\n    if (p) {\n      return {\n        x: p[0],\n        y: p[1]\n      };\n    }\n  };\n  /**\r\n   * Converts a screen point (x/y) to a geographical point (lat/long)\r\n   * @param point Screen point (x/y)\r\n   * @return Geo point (lat/long)\r\n   */\n\n\n  Projection.prototype.invert = function (point) {\n    /*\r\n    let pointInRadians: IGeoPoint = this.unproject((point.x / this.scale + this.centerPoint.x) * $math.RADIANS, (-point.y / this.scale - this.centerPoint.y) * $math.RADIANS);\r\n      let geoPoint = { longitude: pointInRadians.longitude * $math.DEGREES, latitude: pointInRadians.latitude * $math.DEGREES };\r\n      geoPoint = this.unrotate(geoPoint, this.deltaLongitude, this.deltaLatitude, this.deltaGama);\r\n    */\n    var p = this.d3Projection.invert([point.x, point.y]);\n\n    if (p) {\n      return {\n        longitude: p[0],\n        latitude: p[1]\n      };\n    }\n  };\n  /**\r\n   * Returns X/Y coordinates.\r\n   * Individual projections will override this method to apply their own\r\n   * projection logic.\r\n   * @deprecated\r\n   * @param lambda [description]\r\n   * @param phi    [description]\r\n   * @return X/Y coordinates\r\n   * @todo Needs description\r\n   */\n\n\n  Projection.prototype.project = function (lambda, phi) {\n    return this.convert({\n      longitude: lambda * $math.DEGREES,\n      latitude: phi * $math.DEGREES\n    });\n  };\n  /**\r\n   * Returns geographical coordinates (lat/long).\r\n   * Individual projections will override this method to apply their own\r\n   * projection logic.\r\n   * @deprecated\r\n   * @param x X coordinate\r\n   * @param y Y coordinate\r\n   * @return Geographical point\r\n   * @todo Needs description\r\n   */\n\n\n  Projection.prototype.unproject = function (x, y) {\n    return this.invert({\n      x: x,\n      y: y\n    });\n  };\n  /**\r\n   * @ignore\r\n   * @deprecated\r\n   */\n\n\n  Projection.prototype.rotate = function (geoPoint, deltaLongitude, deltaLatitude, deltaGamma) {\n    var deltaLambda = deltaLongitude * $math.RADIANS;\n    var deltaPhi = deltaLatitude * $math.RADIANS;\n    deltaGamma = deltaGamma * $math.RADIANS;\n    var lambda = geoPoint.longitude * $math.RADIANS + deltaLambda;\n    var phi = geoPoint.latitude * $math.RADIANS;\n    var cosDeltaPhi = Math.cos(deltaPhi);\n    var sinDeltaPhi = Math.sin(deltaPhi);\n    var cosDeltaGamma = Math.cos(deltaGamma);\n    var sinDeltaGamma = Math.sin(deltaGamma);\n    var cosPhi = Math.cos(phi);\n    var x = Math.cos(lambda) * cosPhi;\n    var y = Math.sin(lambda) * cosPhi;\n    var z = Math.sin(phi);\n    var k = z * cosDeltaPhi + x * sinDeltaPhi;\n    return {\n      longitude: $math.DEGREES * Math.atan2(y * cosDeltaGamma - k * sinDeltaGamma, x * cosDeltaPhi - z * sinDeltaPhi),\n      latitude: $math.DEGREES * Math.asin(k * cosDeltaGamma + y * sinDeltaGamma)\n    };\n  };\n  /**\r\n   * @ignore\r\n   * @deprecated\r\n   */\n\n\n  Projection.prototype.unrotate = function (geoPoint, deltaLongitude, deltaLatitude, deltaGamma) {\n    var deltaLambda = deltaLongitude * $math.RADIANS;\n    var deltaPhi = deltaLatitude * $math.RADIANS;\n    deltaGamma = deltaGamma * $math.RADIANS;\n    var lambda = geoPoint.longitude * $math.RADIANS - deltaLambda;\n    var phi = geoPoint.latitude * $math.RADIANS;\n    var cosDeltaPhi = Math.cos(deltaPhi);\n    var sinDeltaPhi = Math.sin(deltaPhi);\n    var cosDeltaGamma = Math.cos(deltaGamma);\n    var sinDeltaGamma = Math.sin(deltaGamma);\n    var cosPhi = Math.cos(phi);\n    var x = Math.cos(lambda) * cosPhi;\n    var y = Math.sin(lambda) * cosPhi;\n    var z = Math.sin(phi);\n    var k = z * cosDeltaGamma - y * sinDeltaGamma;\n    return {\n      longitude: $math.DEGREES * Math.atan2(y * cosDeltaGamma + z * sinDeltaGamma, x * cosDeltaPhi + k * sinDeltaPhi),\n      latitude: $math.DEGREES * Math.asin(k * cosDeltaPhi - x * sinDeltaPhi)\n    };\n  }; //@todo: move to some utils?\n  //@todo: add credits to: https://www.movable-type.co.uk/scripts/latlong.html\n\n\n  Projection.prototype.intermediatePoint = function (pointA, pointB, position) {\n    var p = d3geo.geoInterpolate([pointA.longitude, pointA.latitude], [pointB.longitude, pointB.latitude])(position);\n    return {\n      longitude: p[0],\n      latitude: p[1]\n    };\n  };\n\n  ; // returns radians\n\n  Projection.prototype.multiDistance = function (multiGeoLine) {\n    var distance = 0;\n\n    for (var s = 0; s < multiGeoLine.length; s++) {\n      var points = multiGeoLine[s];\n\n      if (points.length > 1) {\n        for (var p = 1; p < points.length; p++) {\n          var pointA = points[p - 1];\n          var pointB = points[p];\n          distance += this.distance(pointA, pointB);\n        }\n      }\n    }\n\n    return distance;\n  }; // returns radians\n\n\n  Projection.prototype.distance = function (pointA, pointB) {\n    return d3geo.geoDistance([pointA.longitude, pointA.latitude], [pointB.longitude, pointB.latitude]);\n  };\n  /**\r\n   * Converts relative position along the line (0-1) into pixel coordinates.\r\n   *\r\n   * @param position  Position (0-1)\r\n   * @return Coordinates\r\n   */\n\n\n  Projection.prototype.positionToPoint = function (multiGeoLine, position) {\n    if (multiGeoLine) {\n      var intermediatePoint = this.positionToGeoPoint(multiGeoLine, position);\n      var intermediatePointA = this.positionToGeoPoint(multiGeoLine, position - 0.01);\n      var intermediatePointB = this.positionToGeoPoint(multiGeoLine, position + 0.01);\n\n      if (intermediatePointA && intermediatePointB) {\n        var point = this.convert(intermediatePoint);\n        var pa = this.convert(intermediatePointA);\n        var pb = this.convert(intermediatePointB);\n        return {\n          x: point.x,\n          y: point.y,\n          angle: $math.getAngle(pa, pb)\n        };\n      }\n    }\n\n    return {\n      x: 0,\n      y: 0,\n      angle: 0\n    };\n  };\n  /**\r\n   * Converts relative position along the line (0-1) into pixel coordinates.\r\n   *\r\n   * @param position  Position (0-1)\r\n   * @return Coordinates\r\n   */\n\n\n  Projection.prototype.positionToGeoPoint = function (multiGeoLine, position) {\n    if (multiGeoLine) {\n      var totalDistance = this.multiDistance(multiGeoLine);\n      var currentDistance = 0;\n      var distanceAB = void 0;\n      var positionA = 0;\n      var positionB = 0;\n      var pointA = void 0;\n      var pointB = void 0;\n\n      for (var s = 0; s < multiGeoLine.length; s++) {\n        var points = multiGeoLine[s];\n\n        if (points.length > 1) {\n          for (var p = 1; p < points.length; p++) {\n            pointA = points[p - 1];\n            pointB = points[p];\n            positionA = currentDistance / totalDistance;\n            distanceAB = this.distance(pointA, pointB);\n            currentDistance += distanceAB;\n            positionB = currentDistance / totalDistance;\n\n            if (positionA <= position && positionB > position) {\n              s = multiGeoLine.length;\n              break;\n            }\n          }\n        } else if (points.length == 1) {\n          pointA = points[0];\n          pointB = points[0];\n          positionA = 0;\n          positionB = 1;\n        }\n      }\n\n      if (pointA && pointB) {\n        var positionAB = (position - positionA) / (positionB - positionA);\n        return this.intermediatePoint(pointA, pointB, positionAB);\n      }\n    }\n\n    return {\n      longitude: 0,\n      latitude: 0\n    };\n  };\n\n  return Projection;\n}();\n\nexport { Projection };\n/**\r\n * Register class in system, so that it can be instantiated using its name from\r\n * anywhere.\r\n *\r\n * @ignore\r\n */\n\nregistry.registeredClasses[\"Projection\"] = Projection;","map":null,"metadata":{},"sourceType":"module"}