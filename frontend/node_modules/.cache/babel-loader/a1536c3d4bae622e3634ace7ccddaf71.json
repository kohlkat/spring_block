{"ast":null,"code":"/**\r\n * Defines Funnel Chart Series.\r\n */\nimport * as tslib_1 from \"tslib\";\n/**\r\n * ============================================================================\r\n * IMPORTS\r\n * ============================================================================\r\n * @hidden\r\n */\n\nimport { PercentSeries, PercentSeriesDataItem } from \"./PercentSeries\";\nimport { FunnelSlice } from \"../elements/FunnelSlice\";\nimport { FunnelTick } from \"../elements/FunnelTick\";\nimport { ListTemplate, ListDisposer } from \"../../core/utils/List\";\nimport { registry } from \"../../core/Registry\";\nimport * as $math from \"../../core/utils/Math\";\nimport * as $iter from \"../../core/utils/Iterator\";\nimport * as $type from \"../../core/utils/Type\";\nimport { percent } from \"../../core/utils/Percent\";\nimport { Disposer } from \"../../core/utils/Disposer\";\n/**\r\n * ============================================================================\r\n * DATA ITEM\r\n * ============================================================================\r\n * @hidden\r\n */\n//@todo: sequenced?\n\n/**\r\n * Defines a [[DataItem]] for [[FunnelSeries]].\r\n *\r\n * @see {@link DataItem}\r\n */\n\nvar FunnelSeriesDataItem =\n/** @class */\nfunction (_super) {\n  tslib_1.__extends(FunnelSeriesDataItem, _super);\n  /**\r\n   * Constructor\r\n   */\n\n\n  function FunnelSeriesDataItem() {\n    var _this = _super.call(this) || this;\n\n    _this.className = \"FunnelSeriesDataItem\"; // this helps to invalidate series when value is 0 an it is hidden (no other events are triggered then)\n\n    _this.events.on(\"visibilitychanged\", function () {\n      if (_this.component) {\n        _this.component.invalidateDataItems();\n      }\n    }, _this, false);\n\n    _this.applyTheme();\n\n    return _this;\n  }\n\n  Object.defineProperty(FunnelSeriesDataItem.prototype, \"sliceLink\", {\n    /**\r\n     * A [[FunnelSlice]] element, related to this data item ([[FunnelSlice]]).\r\n     *\r\n     * @readonly\r\n     * @return Slice element\r\n     */\n    get: function () {\n      var _this = this;\n\n      if (!this._sliceLink) {\n        var sliceLink_1 = this.component.sliceLinks.create();\n        this._sliceLink = sliceLink_1;\n\n        this._disposers.push(sliceLink_1);\n\n        sliceLink_1.parent = this.component.slicesContainer;\n\n        this._disposers.push(new Disposer(function () {\n          if (_this.component) {\n            _this.component.sliceLinks.removeValue(sliceLink_1);\n          }\n        }));\n\n        this.addSprite(sliceLink_1);\n        sliceLink_1.visible = this.visible;\n      }\n\n      return this._sliceLink;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  return FunnelSeriesDataItem;\n}(PercentSeriesDataItem);\n\nexport { FunnelSeriesDataItem };\n/**\r\n * ============================================================================\r\n * MAIN CLASS\r\n * ============================================================================\r\n * @hidden\r\n */\n\n/**\r\n * Defines [[Series]] for a FunnelSlice series on a [[SlicedChart]].\r\n *\r\n * @see {@link IFunnelSeriesEvents} for a list of available Events\r\n * @see {@link IFunnelSeriesAdapters} for a list of available Adapters\r\n * @see {@link https://www.amcharts.com/docs/v4/chart-types/sliced-chart/} for documentation\r\n * @important\r\n */\n\nvar FunnelSeries =\n/** @class */\nfunction (_super) {\n  tslib_1.__extends(FunnelSeries, _super);\n  /**\r\n   * Constructor\r\n   */\n\n\n  function FunnelSeries() {\n    var _this = _super.call(this) || this;\n\n    _this._nextY = 0;\n    _this.className = \"FunnelSeries\";\n    _this.orientation = \"vertical\";\n    _this.width = percent(100);\n    _this.height = percent(100);\n    _this.slicesContainer.width = percent(100);\n    _this.slicesContainer.height = percent(100);\n\n    _this._disposers.push(_this.slicesContainer.events.on(\"maxsizechanged\", _this.invalidateDataItems, _this, false));\n\n    _this.labelsOpposite = true;\n    _this.labelsContainer.layout = \"absolute\";\n    _this.bottomRatio = 0;\n\n    _this.applyTheme();\n\n    return _this;\n  }\n  /**\r\n   * Creates a [[FunnelSlice]] element.\r\n   *\r\n   * @return Slice\r\n   */\n\n\n  FunnelSeries.prototype.createSlice = function () {\n    return new FunnelSlice();\n  };\n  /**\r\n   * Creates a [[FunnelTick]] element.\r\n   *\r\n   * @return Tick\r\n   */\n\n\n  FunnelSeries.prototype.createTick = function () {\n    return new FunnelTick();\n  };\n  /**\r\n   * Sets defaults that instantiate some objects that rely on parent, so they\r\n   * cannot be set in constructor.\r\n   */\n\n\n  FunnelSeries.prototype.applyInternalDefaults = function () {\n    _super.prototype.applyInternalDefaults.call(this);\n\n    if (!$type.hasValue(this.readerTitle)) {\n      this.readerTitle = this.language.translate(\"Funnel Series\");\n    }\n  };\n  /**\r\n   * Returns a new/empty DataItem of the type appropriate for this object.\r\n   *\r\n   * @see {@link DataItem}\r\n   * @return Data Item\r\n   */\n\n\n  FunnelSeries.prototype.createDataItem = function () {\n    return new FunnelSeriesDataItem();\n  };\n  /**\r\n   * Inits FunnelSlice.\r\n   *\r\n   * @param slice to init\r\n   */\n\n\n  FunnelSeries.prototype.initSlice = function (slice) {\n    slice.isMeasured = false;\n    slice.defaultState.properties.scale = 1;\n    slice.observe(\"scale\", this.handleSliceScale, this);\n    slice.observe([\"dx\", \"dy\", \"x\", \"y\"], this.handleSliceMove, this);\n    slice.tooltipText = \"{category}: {value.percent.formatNumber('#.#')}% ({value.value})\";\n    var hoverState = slice.states.create(\"hover\");\n    hoverState.properties.expandDistance = 0.2;\n  };\n  /**\r\n   * [initLabel description]\r\n   *\r\n   * @todo Description\r\n   * @param label [description]\r\n   */\n\n\n  FunnelSeries.prototype.initLabel = function (label) {\n    _super.prototype.initLabel.call(this, label);\n\n    label.verticalCenter = \"middle\";\n    label.horizontalCenter = \"middle\";\n    label.isMeasured = true;\n    label.padding(5, 5, 5, 5);\n  };\n  /**\r\n   * (Re)validates the whole series, effectively causing it to redraw.\r\n   *\r\n   * @ignore Exclude from docs\r\n   */\n\n\n  FunnelSeries.prototype.validate = function () {\n    _super.prototype.validate.call(this);\n\n    this._nextY = 0;\n  };\n  /**\r\n   * [validateDataElements description]\r\n   *\r\n   * @todo Description\r\n   * @ignore Exclude from docs\r\n   */\n\n\n  FunnelSeries.prototype.validateDataElements = function () {\n    var _this = this;\n\n    var slicesContainer = this.slicesContainer;\n    var labelsContainer = this.labelsContainer;\n    var labelTemplate = this.labels.template;\n\n    if (this.alignLabels) {\n      labelTemplate.interactionsEnabled = true;\n      slicesContainer.isMeasured = true;\n      labelsContainer.isMeasured = true;\n    } else {\n      labelTemplate.interactionsEnabled = false;\n      slicesContainer.isMeasured = false;\n      labelsContainer.isMeasured = false;\n    }\n\n    var total = 0;\n    var count = 0;\n    this.dataItems.each(function (dItem) {\n      if ($type.hasValue(dItem.value)) {\n        count++;\n\n        if (dItem.value > 0) {\n          total += dItem.getWorkingValue(\"value\") / dItem.value;\n        } else {\n          if (_this.ignoreZeroValues) {\n            count--;\n          } else {\n            if (!dItem.visible || dItem.__disabled || dItem.isHiding) {\n              count--;\n            } else {\n              total += 1;\n            }\n          }\n        }\n      }\n    });\n    this._total = 1 / count * total;\n    this._count = count;\n\n    _super.prototype.validateDataElements.call(this);\n\n    this.arrangeLabels();\n  };\n  /**\r\n   * [getNextValue description]\r\n   *\r\n   * @todo Description\r\n   * @param dataItem  [description]\r\n   * @return [description]\r\n   */\n\n\n  FunnelSeries.prototype.getNextValue = function (dataItem) {\n    var index = dataItem.index;\n    var nextValue = dataItem.getWorkingValue(\"value\");\n\n    if (index < this.dataItems.length - 1) {\n      var nextItem = this.dataItems.getIndex(index + 1);\n      nextValue = nextItem.getWorkingValue(\"value\");\n\n      if (!nextItem.visible || nextItem.isHiding || nextItem.__disabled || nextItem.value == 0 && this.ignoreZeroValues) {\n        return this.getNextValue(nextItem);\n      }\n    }\n\n    return nextValue;\n  };\n  /**\r\n   * [formDataElement description]\r\n   *\r\n   * @todo Description\r\n   */\n\n\n  FunnelSeries.prototype.formDataElement = function () {};\n  /**\r\n   * Validates data item's element, effectively redrawing it.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param dataItem  Data item\r\n   */\n\n\n  FunnelSeries.prototype.validateDataElement = function (dataItem) {\n    if ($type.hasValue(dataItem.value)) {\n      // FunnelSlice\n      var slice = dataItem.slice;\n      slice.orientation = this.orientation;\n      var sliceLink = dataItem.sliceLink;\n      sliceLink.orientation = this.orientation;\n      var tick = dataItem.tick;\n      var label = dataItem.label;\n      tick.slice = slice;\n      tick.label = label;\n      this.decorateSlice(dataItem);\n      sliceLink.fill = slice.fill;\n\n      if (dataItem.index == this.dataItems.length - 1) {\n        sliceLink.disabled = true;\n      } // do this at the end, otherwise bullets won't be positioned properly\n\n\n      _super.prototype.validateDataElement.call(this, dataItem);\n    }\n  };\n  /**\r\n   * [decorateSlice description]\r\n   *\r\n   * @todo Description\r\n   * @param dataItem [description]\r\n   */\n\n\n  FunnelSeries.prototype.decorateSlice = function (dataItem) {\n    var slice = dataItem.slice;\n    var sliceLink = dataItem.sliceLink;\n    var label = dataItem.label;\n    var tick = dataItem.tick;\n    var maxWidth = this.slicesContainer.innerWidth;\n    var maxHeight = this.slicesContainer.innerHeight;\n    var nextValue = this.getNextValue(dataItem);\n    var workingValue = Math.abs(dataItem.getWorkingValue(\"value\"));\n    var bottomRatio = this.bottomRatio;\n    var d = 1;\n\n    if (dataItem.value != 0) {\n      d = workingValue / Math.abs(dataItem.value);\n    } else {\n      if (dataItem.__disabled || dataItem.isHiding || !dataItem.visible) {\n        d = 0.000001;\n      }\n    }\n\n    if (this.ignoreZeroValues && dataItem.value == 0) {\n      dataItem.__disabled = true;\n      return;\n    } else {\n      dataItem.__disabled = false;\n    }\n\n    if (this._nextY == Infinity) {\n      this._nextY = 0;\n    }\n\n    if (this.orientation == \"vertical\") {\n      var linkHeight = sliceLink.pixelHeight * d;\n      maxHeight = maxHeight + linkHeight; // to avoid one link gap in the bottom\n\n      slice.topWidth = workingValue / this.dataItem.values.value.high * maxWidth;\n      slice.bottomWidth = (workingValue - (workingValue - nextValue) * bottomRatio) / this.dataItem.values.value.high * maxWidth;\n      sliceLink.topWidth = slice.bottomWidth;\n      sliceLink.bottomWidth = (workingValue - (workingValue - nextValue)) / this.dataItem.values.value.high * maxWidth;\n      slice.y = this._nextY;\n      slice.height = Math.min(100000, $math.max(0, maxHeight / this._count * d / this._total - linkHeight));\n      slice.x = maxWidth / 2;\n\n      if (!this.alignLabels) {\n        label.x = slice.x;\n      } else {\n        label.x = undefined;\n      }\n\n      label.y = slice.pixelY + slice.pixelHeight * tick.locationY;\n      this._nextY += slice.pixelHeight + linkHeight;\n      sliceLink.y = this._nextY - linkHeight;\n      sliceLink.x = slice.x;\n    } else {\n      var linkWidth = sliceLink.pixelWidth * d;\n      maxWidth = maxWidth + linkWidth; // to avoid one link gap in the bottom\n\n      slice.topWidth = workingValue / this.dataItem.values.value.high * maxHeight;\n      slice.bottomWidth = (workingValue - (workingValue - nextValue) * bottomRatio) / this.dataItem.values.value.high * maxHeight;\n      sliceLink.topWidth = slice.bottomWidth;\n      sliceLink.bottomWidth = (workingValue - (workingValue - nextValue)) / this.dataItem.values.value.high * maxHeight;\n      slice.x = this._nextY;\n      slice.width = Math.min(100000, maxWidth / this._count * d * 1 / this._total - linkWidth);\n      slice.y = maxHeight / 2;\n\n      if (!this.alignLabels) {\n        label.y = slice.y;\n      } else {\n        label.y = this.labelsContainer.measuredHeight;\n      }\n\n      label.x = slice.pixelX + slice.pixelWidth * tick.locationX;\n      this._nextY += slice.pixelWidth + linkWidth;\n      sliceLink.x = this._nextY - linkWidth;\n      sliceLink.y = slice.y;\n    }\n  };\n\n  FunnelSeries.prototype.getLastLabel = function (index) {\n    if (index > 0) {\n      var lastLabel = this.labels.getIndex(index);\n\n      if (lastLabel.__disabled || !lastLabel.visible) {\n        return this.getLastLabel(index - 1);\n      } else {\n        return lastLabel;\n      }\n    }\n  };\n  /**\r\n   * [arrangeLabels description]\r\n   *\r\n   * @todo Description\r\n   */\n\n\n  FunnelSeries.prototype.arrangeLabels = function () {\n    if (this.alignLabels) {\n      var count = this.labels.length;\n\n      if (count > 1) {\n        var lastLabel = this.getLastLabel(count - 1);\n\n        if (lastLabel) {\n          var lastY = lastLabel.pixelY;\n          var lastX = lastLabel.pixelX;\n\n          if (count > 1) {\n            for (var i = count - 2; i >= 0; i--) {\n              var label = this.labels.getIndex(i);\n\n              if (label.visible && !label.__disabled) {\n                if (label.invalid) {\n                  label.validate();\n                }\n\n                if (this.orientation == \"vertical\") {\n                  if (label.pixelY + label.measuredHeight > lastY) {\n                    label.y = Math.min(1000000, lastY - label.measuredHeight);\n                  }\n                } // horizontal\n                else {\n                    if (label.pixelX + label.measuredWidth > lastX) {\n                      label.x = Math.min(1000000, lastX - label.measuredWidth);\n                    }\n                  }\n\n                lastY = label.pixelY;\n                lastX = label.pixelX;\n              }\n            }\n\n            lastY = 0;\n            lastX = 0;\n\n            for (var i = 0; i < count; i++) {\n              var label = this.labels.getIndex(i);\n\n              if (label.visible && !label.__disabled) {\n                if (label.invalid) {\n                  label.validate();\n                }\n\n                if (this.orientation == \"vertical\") {\n                  if (label.pixelY < lastY) {\n                    label.y = Math.min(1000000, lastY);\n                  }\n                } // horizontal\n                else {\n                    if (label.pixelX < lastX) {\n                      label.x = Math.min(1000000, lastX);\n                    }\n                  }\n\n                lastY += label.measuredHeight;\n                lastX += label.measuredWidth;\n              }\n            }\n          }\n        }\n      }\n    }\n  };\n  /**\r\n   * Positions series bullet.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param bullet  Bullet\r\n   */\n\n\n  FunnelSeries.prototype.positionBullet = function (bullet) {\n    _super.prototype.positionBullet.call(this, bullet);\n\n    var dataItem = bullet.dataItem;\n    var slice = dataItem.slice;\n    var locationX = bullet.locationX;\n\n    if (!$type.isNumber(locationX)) {\n      locationX = 0.5;\n    }\n\n    var locationY = bullet.locationY;\n\n    if (!$type.isNumber(locationY)) {\n      locationY = 1;\n    }\n\n    bullet.x = slice.pixelX + slice.measuredWidth * locationX;\n    bullet.y = slice.pixelY + slice.measuredHeight * locationY;\n  };\n\n  Object.defineProperty(FunnelSeries.prototype, \"orientation\", {\n    /**\r\n     * @return Orientation\r\n     */\n    get: function () {\n      return this.getPropertyValue(\"orientation\");\n    },\n\n    /**\r\n     * Orientation of the funnel slices: \"horizontal\" or \"vertical\" (default).\r\n     *\r\n     * @default \"vertical\"\r\n     * @param value Orientation\r\n     */\n    set: function (value) {\n      if (this.setPropertyValue(\"orientation\", value)) {\n        this.labelsOpposite = this.labelsOpposite;\n        this.invalidate();\n\n        if (value == \"vertical\") {\n          this.ticks.template.locationX = 1;\n          this.ticks.template.locationY = 0.5;\n          this.labels.template.rotation = 0;\n          this.layout = \"horizontal\";\n        } else {\n          this.ticks.template.locationX = 0.5;\n          this.ticks.template.locationY = 1;\n          this.labels.template.rotation = -90;\n          this.layout = \"vertical\";\n        }\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(FunnelSeries.prototype, \"bottomRatio\", {\n    /**\r\n     * @return {number}\r\n     */\n    get: function () {\n      return this.getPropertyValue(\"bottomRatio\");\n    },\n\n    /**\r\n     * Indicates how slice's bottom will change in relation to slices top AND\r\n     * next slices top.\r\n     *\r\n     * Basically it's a relative value (0-1) that indicates bottom width\r\n     * position between current slice's top width and the top withd of the next\r\n     * one.\r\n     *\r\n     * The scale goes from 0 (closer to current slice width) to 1 (closer to next\r\n     * slice with).\r\n     *\r\n     * `0` (default) will mean that bottom will be the same as top, resulting in\r\n     * a prefectly square slice.\r\n     *\r\n     * From the data-viz standpoint `0` is a correct setting, since area of the\r\n     * slices will depict their value correctly.\r\n     *\r\n     * `1` will mean that slice will become trapezoid with its bottom matching\r\n     * width of the next slice.\r\n     *\r\n     * `0.5` will make bottom width be in the middle of width of current slice\r\n     * and the next slice.\r\n     *\r\n     * @default 0\r\n     * @param {number}\r\n     */\n    set: function (value) {\n      if (this.setPropertyValue(\"bottomRatio\", value)) {\n        this.invalidate();\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(FunnelSeries.prototype, \"sliceLinks\", {\n    /**\r\n     * A list of elements linking each actual slice.\r\n     *\r\n     * Please note that links are [[FunnelSlice]] objects, just like real links,\r\n     * so they have all the same configuration options.\r\n     *\r\n     * You can use `template` of this link, to specify how links will look.\r\n     *\r\n     * ```TypeScript\r\n     * series.sliceLinks.template.fillOpacity = 0.5;\r\n     * ```\r\n     * ```JavaScript\r\n     * series.sliceLinks.template.fillOpacity = 0.5;\r\n     * ```\r\n     * ```JSON\r\n     * {\r\n     *   // ...\r\n     *   \"series\": [{\r\n     *     \"type\": \"FunnelSeries\",\r\n     *      // ...\r\n     *      \"sliceLinks\": {\r\n     *        \"fillOpacity\": 0.5\r\n     *      }\r\n     *   }]\r\n     * }\r\n     * ```\r\n     *\r\n     * @return Funnel links\r\n     */\n    get: function () {\n      if (!this._sliceLinks) {\n        var sliceLink = new FunnelSlice();\n        sliceLink.applyOnClones = true;\n        sliceLink.fillOpacity = 0.5;\n        sliceLink.expandDistance = -0.3;\n        sliceLink.hiddenState.properties.opacity = 0;\n\n        this._disposers.push(sliceLink);\n\n        this._sliceLinks = new ListTemplate(sliceLink);\n\n        this._disposers.push(new ListDisposer(this._sliceLinks));\n      }\n\n      return this._sliceLinks;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\r\n   * Shows hidden series.\r\n   *\r\n   * @param duration  Duration of reveal animation (ms)\r\n   * @return Animation\r\n   */\n\n  FunnelSeries.prototype.show = function (duration) {\n    var _this = this;\n\n    var startIndex = this.startIndex;\n    var endIndex = this.endIndex;\n    var interpolationDuration = this.defaultState.transitionDuration;\n\n    if ($type.isNumber(duration)) {\n      interpolationDuration = duration;\n    }\n\n    var delay = 0;\n    $iter.each($iter.indexed(this.dataItems.iterator()), function (a) {\n      var i = a[0];\n      var dataItem = a[1];\n\n      if (_this.sequencedInterpolation) {\n        delay = _this.sequencedInterpolationDelay * i + interpolationDuration * (i - startIndex) / (endIndex - startIndex);\n      }\n\n      dataItem.show(interpolationDuration, delay, [\"value\"]);\n    });\n\n    var animation = _super.prototype.show.call(this, duration);\n\n    return animation;\n  };\n  /**\r\n   * Hides series.\r\n   *\r\n   * @param duration  Duration of hiding animation (ms)\r\n   * @return Animation\r\n   */\n\n\n  FunnelSeries.prototype.hide = function (duration) {\n    var _this = this;\n\n    var fields = [\"value\"];\n    var value = 0;\n    var startIndex = this.startIndex;\n    var endIndex = this.endIndex;\n    var delay = 0;\n    var interpolationDuration = this.hiddenState.transitionDuration;\n\n    if ($type.isNumber(duration)) {\n      interpolationDuration = duration;\n    }\n\n    $iter.each($iter.indexed(this.dataItems.iterator()), function (a) {\n      var i = a[0];\n      var dataItem = a[1];\n\n      if (_this.sequencedInterpolation) {\n        delay = _this.sequencedInterpolationDelay * i + interpolationDuration * (i - startIndex) / (endIndex - startIndex);\n      }\n\n      dataItem.hide(interpolationDuration, delay, value, fields);\n    });\n\n    var animation = _super.prototype.hide.call(this, duration);\n\n    if (animation && !animation.isFinished()) {\n      animation.delay(delay);\n    }\n\n    return animation;\n  };\n  /**\r\n   * @ignore\r\n   */\n\n\n  FunnelSeries.prototype.setAlignLabels = function (value) {\n    _super.prototype.setAlignLabels.call(this, value);\n\n    this.ticks.template.disabled = !value;\n    var labelsContainer = this.labelsContainer;\n\n    if (labelsContainer) {\n      // do not align\n      if (!value) {\n        labelsContainer.width = percent(100);\n        labelsContainer.height = percent(100);\n      } //align\n      else {\n          labelsContainer.height = undefined;\n          labelsContainer.width = undefined;\n          labelsContainer.margin(10, 10, 10, 10);\n        }\n    }\n\n    this.labelsOpposite = this.labelsOpposite;\n  };\n\n  Object.defineProperty(FunnelSeries.prototype, \"labelsOpposite\", {\n    /**\r\n     * @return Labels on opposite side?\r\n     */\n    get: function () {\n      return this.getPropertyValue(\"labelsOpposite\");\n    },\n\n    /**\r\n     * Put labels on the oppsite side of the series?\r\n     *\r\n     * This setting is only used if `alignLabels = true`.\r\n     *\r\n     * If set to `true` (default) labels will be drawn to the right (on vertical\r\n     * series), or to the bottom (on horizontal series).\r\n     *\r\n     * If set to `false`, labels will be positioned to the left or top\r\n     * respectively.\r\n     *\r\n     * @default true\r\n     * @since 4.1.13\r\n     * @param  value  Labels on opposite side?\r\n     */\n    set: function (value) {\n      this.setPropertyValue(\"labelsOpposite\", value);\n      var labelTemplate = this.labels.template;\n      var labelAlign = \"none\";\n      var labelValign = \"none\";\n\n      if (!this.alignLabels) {\n        if (this.orientation == \"vertical\") {\n          labelAlign = \"center\";\n        } else {\n          labelValign = \"middle\";\n        }\n      } else {\n        // opposite (left/bottom)\n        if (value) {\n          this.labelsContainer.toFront(); // left\n\n          if (this.orientation == \"vertical\") {\n            this.ticks.template.locationX = 1;\n            labelTemplate.horizontalCenter = \"left\";\n            labelAlign = \"right\";\n          } // bottom\n          else {\n              this.ticks.template.locationY = 1;\n              labelTemplate.horizontalCenter = \"right\";\n              labelValign = \"bottom\";\n            }\n        } // non oposite (right/top)\n        else {\n            this.labelsContainer.toBack(); // right\n\n            if (this.orientation == \"vertical\") {\n              this.ticks.template.locationX = 0;\n              labelAlign = \"left\";\n            } // top\n            else {\n                labelValign = \"top\";\n                this.ticks.template.locationY = 0;\n              }\n          }\n      }\n\n      labelTemplate.align = labelAlign;\n      labelTemplate.valign = labelValign;\n      this.validateLayout();\n      this.ticks.each(function (tick) {\n        tick.invalidate();\n      });\n      this.invalidateDataItems();\n    },\n    enumerable: true,\n    configurable: true\n  });\n  return FunnelSeries;\n}(PercentSeries);\n\nexport { FunnelSeries };\n/**\r\n * bboxter class in system, so that it can be instantiated using its name from\r\n * anywhere.\r\n *\r\n * @ignore\r\n */\n\nregistry.registeredClasses[\"FunnelSeries\"] = FunnelSeries;\nregistry.registeredClasses[\"FunnelSeriesDataItem\"] = FunnelSeriesDataItem;","map":null,"metadata":{},"sourceType":"module"}