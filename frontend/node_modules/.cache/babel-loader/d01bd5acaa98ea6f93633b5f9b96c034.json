{"ast":null,"code":"/**\r\n * ============================================================================\r\n * IMPORTS\r\n * ============================================================================\r\n * @hidden\r\n */\nimport { registry } from \"./Registry\";\nimport { Container } from \"./Container\";\nimport { Label } from \"./elements/Label\";\nimport { raf } from \"./utils/AsyncPending\";\nimport { triggerIdle } from \"./utils/AsyncPending\";\nimport * as $array from \"./utils/Array\";\nimport * as $object from \"./utils/Object\";\nimport * as $log from \"./utils/Log\";\n/**\r\n * ============================================================================\r\n * MAIN CLASS\r\n * ============================================================================\r\n * @hidden\r\n */\n\n/**\r\n * The main class that handles system-wide tasks, like caching, heartbeats, etc.\r\n * @important\r\n */\n\nvar System =\n/** @class */\nfunction () {\n  /**\r\n   * Performs initialization of the System object.\r\n   *\r\n   * Called when the first [[Sprite]] object is created.\r\n   *\r\n   * @ignore Exclude from docs\r\n   */\n  function System() {\n    /**\r\n     * A flag indicating if the system is on pause.\r\n     */\n    this._isPaused = false;\n    /**\r\n     * Holds the list of currently playing animations.\r\n     *\r\n     * @ignore Exclude from docs\r\n     */\n\n    this.animations = [];\n    /**\r\n     * Unique ID of the object.\r\n     */\n\n    this.uid = registry.getUniqueId();\n    /**\r\n     * @todo Description\r\n     * @todo Needed?\r\n     * @ignore Exclude from docs\r\n     */\n\n    this.dummyCounter = 0;\n    this._frameRequested = false;\n    this.updateStepDuration = 45;\n    this.time = Date.now();\n  }\n  /**\r\n   * Reports time elapsed since timer was reset.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @todo Needed?\r\n   * @param msg    Message to report in console\r\n   * @param reset  Reset time counter\r\n   */\n\n\n  System.prototype.reportTime = function (msg, reset) {\n    if (this.dummyCounter < 6) {//console.log(Date.now() - this.time, msg, this.dummyCounter2);\n    }\n\n    if (reset) {\n      this.time = Date.now();\n    }\n  };\n  /**\r\n   * Performs \"heartbeat\" operations `frameRate` number of times per second.\r\n   *\r\n   * When the chart element is invalidated, it is not immediately redrawn.\r\n   *\r\n   * Instead it waits for the next `update()` cycle to be re-validated.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @todo Maybe should be private?\r\n   */\n\n\n  System.prototype.update = function () {\n    var _this = this;\n\n    if (this._isPaused) {\n      return;\n    }\n\n    this._frameRequested = false;\n    var time = Date.now();\n    registry.dispatchImmediately(\"enterframe\"); //this.validateLayouts();\n    //this.validatePositions();\n\n    /*\r\n            for (let key in registry.invalidLayouts) {\r\n                this.validateLayouts(key);\r\n            }\r\n            for (let key in registry.invalidPositions) {\r\n                this.validatePositions(key);\r\n            }\r\n    */\n\n    var skippedComponents = []; // data objects first - do all calculations\n    // only data is parsed in chunks, thats why we do for loop instead of a while like with other invalid items.\n    // important to go backwards, as items are removed!\n    // TODO use iterator instead\n\n    for (var key in registry.invalidDatas) {\n      if ($object.hasKey(registry.invalidDatas, key)) {\n        var invalidData = registry.invalidDatas[key];\n\n        while (invalidData.length > 0) {\n          var component = invalidData[0];\n          var dataProvider = component.dataProvider;\n\n          if (!component.isDisposed()) {\n            if (dataProvider && dataProvider.dataInvalid) {\n              try {\n                dataProvider.validateData();\n\n                if (dataProvider.dataValidationProgress < 1) {\n                  break;\n                }\n              } catch (e) {\n                $array.remove(invalidData, dataProvider);\n                dataProvider.raiseCriticalError(e);\n              }\n            } else {\n              try {\n                component.validateData();\n\n                if (component.dataValidationProgress < 1) {\n                  break;\n                }\n              } catch (e) {\n                $array.remove(invalidData, component);\n                component.raiseCriticalError(e);\n              }\n            }\n          } else {\n            $array.remove(invalidData, component);\n          }\n        }\n\n        if (Date.now() - time > this.updateStepDuration) {\n          break;\n        }\n      }\n    }\n\n    while (registry.invalidRawDatas.length > 0) {\n      var component = registry.invalidRawDatas[0];\n\n      if (!component.isDisposed()) {\n        try {\n          component.validateRawData();\n        } catch (e) {\n          $array.remove(registry.invalidRawDatas, component);\n          component.raiseCriticalError(e);\n        }\n      } else {\n        $array.remove(registry.invalidRawDatas, component);\n      }\n    } // TODO use iterator instead\n\n\n    while (registry.invalidDataItems.length > 0) {\n      var component = registry.invalidDataItems[0];\n      var dataProvider = component.dataProvider; // this is needed to avoid partial value validation when data is parsed in chunks\n\n      if (component.isDisposed() || component.dataInvalid || dataProvider && dataProvider.dataInvalid) {// void\n      } else {\n        try {\n          component.validateDataItems();\n        } catch (e) {\n          $array.remove(registry.invalidDataItems, component);\n          component.raiseCriticalError(e);\n        }\n      } // this might seem too much, as validateValues removes from invalidDataItems aswell, but just to be sure (in case validateData is overriden and no super is called)\n\n\n      $array.remove(registry.invalidDataItems, component);\n    } // TODO use iterator instead\n\n\n    while (registry.invalidDataRange.length > 0) {\n      var component = registry.invalidDataRange[0];\n      var dataProvider = component.dataProvider;\n\n      if (component.isDisposed() || component.dataInvalid || dataProvider && dataProvider.dataInvalid) {// void\n      } else {\n        try {\n          component.validateDataRange();\n\n          if (!component.skipRangeEvent) {\n            component.dispatchImmediately(\"datarangechanged\");\n          }\n\n          component.skipRangeEvent = false;\n        } catch (e) {\n          $array.remove(registry.invalidDataRange, component);\n          component.raiseCriticalError(e);\n        }\n      } // this might seem too much, as validateDataRange removes from invalidDataRange aswell, but just to be sure (in case validateData is overriden and no super is called)\n\n\n      $array.remove(registry.invalidDataRange, component);\n    }\n\n    var skippedSprites = []; // display objects later\n    // TODO use iterator instead\n\n    $object.each(registry.invalidLayouts, function (key) {\n      _this.validateLayouts(key);\n    });\n    $object.each(registry.invalidPositions, function (key) {\n      _this.validatePositions(key);\n    });\n    var hasSkipped = false;\n    time = Date.now();\n    $object.each(registry.invalidSprites, function (key, invalidSprites) {\n      var count = 0;\n\n      while (invalidSprites.length > 0) {\n        _this.validateLayouts(key);\n\n        _this.validatePositions(key);\n\n        count++;\n\n        if (count == 5) {\n          if (Date.now() - time > _this.updateStepDuration) {\n            break;\n          }\n\n          count = 0;\n        }\n\n        var sprite = invalidSprites[invalidSprites.length - 1]; // we need to check this, as validateLayout might validate sprite\n\n        if (sprite && !sprite.isDisposed()) {\n          if (!sprite._systemCheckIfValidate()) {\n            // void\n            skippedSprites.push(sprite);\n          } else {\n            if (!_this.checkIfValidate2(sprite)) {\n              // void\n              skippedSprites.push(sprite);\n            } else {\n              try {\n                sprite._systemUpdate(skippedSprites);\n              } catch (e) {\n                sprite.invalid = false;\n                $array.remove(invalidSprites, sprite);\n                sprite.raiseCriticalError(e);\n              }\n            }\n          } // this might seem too much, but it's ok\n\n\n          sprite.invalid = false;\n        }\n\n        $array.remove(invalidSprites, sprite);\n      }\n\n      registry.invalidSprites[key] = registry.invalidSprites[key].concat(skippedSprites);\n    });\n    $object.each(registry.invalidSprites, function (key, value) {\n      if (value.length > 0) {\n        hasSkipped = true;\n      }\n    });\n    $object.each(registry.invalidDatas, function (key, value) {\n      if (value.length > 0) {\n        hasSkipped = true;\n      }\n    }); // TODO make this more efficient\n    // TODO don't copy the array\n\n    $array.each($array.copy(this.animations), function (x) {\n      x.update();\n    }); //if(!hasSkipped){\n\n    $object.each(registry.invalidLayouts, function (key) {\n      _this.validateLayouts(key);\n    });\n    $object.each(registry.invalidPositions, function (key) {\n      _this.validatePositions(key);\n    }); //}\n\n    triggerIdle();\n    $object.each(registry.invalidLayouts, function (key) {\n      _this.validateLayouts(key);\n    });\n    $object.each(registry.invalidPositions, function (key) {\n      _this.validatePositions(key);\n    });\n    registry.dispatchImmediately(\"exitframe\");\n\n    if (hasSkipped || this.animations.length > 0 || skippedComponents.length > 0) {\n      this.requestFrame();\n    }\n\n    if (this.updateStepDuration < 200) {\n      var all0_1 = true;\n      $object.each(registry.invalidDatas, function (key, value) {\n        if (value.length > 0) {\n          all0_1 = false;\n        }\n      });\n      $object.each(registry.invalidSprites, function (key, value) {\n        if (value.length > 0) {\n          all0_1 = false;\n        }\n      });\n\n      if (all0_1) {\n        this.updateStepDuration = 200;\n      }\n    }\n  };\n\n  System.prototype.checkIfValidate2 = function (sprite) {\n    if (sprite.dataItem && sprite.dataItem.component && sprite.dataItem.component.dataInvalid && !sprite.dataItem.component.isTemplate) {\n      return false;\n    } else {\n      return true;\n    }\n  };\n  /**\r\n   * Requests new animation frame\r\n   */\n\n\n  System.prototype.requestFrame = function () {\n    var _this = this;\n\n    if (!this._frameRequested) {\n      raf(function () {\n        _this.update();\n      });\n      this._frameRequested = true;\n    }\n  }; //@todo mm\n\n\n  System.prototype.softInvalidate = function (container) {\n    var _this = this;\n\n    container.children.each(function (child) {\n      if (child instanceof Container) {\n        _this.softInvalidate(child);\n      }\n\n      if (child.measureFailed) {\n        if (child instanceof Label) {\n          child.hardInvalidate();\n        } else {\n          child.invalidate();\n        }\n\n        child.measureFailed = false;\n      }\n    });\n  };\n  /**\r\n   * Triggers position re-validation on all [[Sprite]] elements that have\r\n   * invalid(ated) positions.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @todo Maybe should be private?\r\n   */\n\n\n  System.prototype.validatePositions = function (id) {\n    // invalid positions\n    // TODO use iterator instead\n    var invalidPositions = registry.invalidPositions[id];\n\n    while (invalidPositions.length > 0) {\n      var sprite = invalidPositions[invalidPositions.length - 1];\n\n      if (!sprite.isDisposed()) {\n        try {\n          sprite._systemValidatePositions();\n        } catch (e) {\n          sprite.positionInvalid = false;\n          $array.remove(invalidPositions, sprite);\n          sprite.raiseCriticalError(e);\n        }\n      } else {\n        $array.remove(invalidPositions, sprite);\n      }\n    }\n  };\n  /**\r\n   * Triggers position re-validation on all [[Container]] elements that have\r\n   * invalid(ated) layouts.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @todo Maybe should be private?\r\n   */\n\n\n  System.prototype.validateLayouts = function (id) {\n    // invalid positions\n    // TODO use iterator instead\n    var invalidLayouts = registry.invalidLayouts[id];\n\n    while (invalidLayouts.length > 0) {\n      var container = invalidLayouts[invalidLayouts.length - 1];\n\n      if (!container.isDisposed()) {\n        try {\n          container.children.each(function (sprite) {\n            sprite._systemValidateLayouts();\n          });\n          container.validateLayout();\n        } catch (e) {\n          container.layoutInvalid = false;\n          $array.remove(invalidLayouts, container);\n          container.raiseCriticalError(e);\n        }\n      } else {\n        $array.remove(invalidLayouts, container);\n      }\n    }\n  };\n  /**\r\n   * Outputs string to console if `verbose` is `true`.\r\n   *\r\n   * @param value Message to output to console\r\n   */\n\n\n  System.prototype.log = function (value) {\n    $log.log(value);\n  };\n\n  Object.defineProperty(System.prototype, \"isPaused\", {\n    /**\r\n     * @return Is system on pause?\r\n     */\n    get: function () {\n      return this._isPaused;\n    },\n\n    /**\r\n     * Pauses all the processes of all the amCharts objects on the page\r\n     *\r\n     * @return is paused?\r\n     */\n    set: function (value) {\n      this._isPaused = value;\n\n      if (!value) {\n        this._frameRequested = false;\n        this.requestFrame();\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\r\n   * amCharts Version.\r\n   *\r\n   * This follows npm's semver specification.\r\n   *\r\n   * @see {@link https://docs.npmjs.com/misc/semver}\r\n   */\n\n  System.VERSION = \"4.7.10\";\n  return System;\n}();\n\nexport { System };\n/**\r\n * A singleton global instance of [[System]].\r\n *\r\n * All code should use this, rather than instantiating their\r\n * own System objects.\r\n */\n\nexport var system = new System();","map":null,"metadata":{},"sourceType":"module"}