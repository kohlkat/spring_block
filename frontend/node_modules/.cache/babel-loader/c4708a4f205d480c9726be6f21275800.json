{"ast":null,"code":"/**\r\n * Module, defining Axis Renderer for circular axes.\r\n */\nimport * as tslib_1 from \"tslib\";\n/**\r\n * ============================================================================\r\n * IMPORTS\r\n * ============================================================================\r\n * @hidden\r\n */\n\nimport { AxisRenderer } from \"./AxisRenderer\";\nimport { AxisFillCircular } from \"./AxisFillCircular\";\nimport { GridCircular } from \"./GridCircular\";\nimport { AxisLabelCircular } from \"./AxisLabelCircular\";\nimport { registry } from \"../../core/Registry\";\nimport { percent } from \"../../core/utils/Percent\";\nimport * as $math from \"../../core/utils/Math\";\nimport * as $path from \"../../core/rendering/Path\";\nimport * as $utils from \"../../core/utils/Utils\";\nimport * as $type from \"../../core/utils/Type\";\nimport { AxisBullet } from \"./AxisBullet\";\n/**\r\n * ============================================================================\r\n * MAIN CLASS\r\n * ============================================================================\r\n * @hidden\r\n */\n\n/**\r\n * A renderer for circular axis.\r\n */\n\nvar AxisRendererCircular =\n/** @class */\nfunction (_super) {\n  tslib_1.__extends(AxisRendererCircular, _super);\n  /**\r\n   * Constructor.\r\n   *\r\n   * @param axis Related axis\r\n   */\n\n\n  function AxisRendererCircular() {\n    var _this = // Init\n    _super.call(this) || this;\n    /**\r\n     * @ignore\r\n     */\n\n\n    _this.pixelRadiusReal = 0; // axis.layout = \"none\"; // does not trigger redraw when size changes\n\n    _this.layout = \"none\";\n    _this.className = \"AxisRendererCircular\";\n    _this.isMeasured = false;\n    _this.startAngle = -90;\n    _this.endAngle = 270;\n    _this.useChartAngles = true;\n    _this.radius = percent(100);\n    _this.isMeasured = false;\n    _this.grid.template.location = 0;\n    _this.labels.template.location = 0;\n    _this.labels.template.radius = 15;\n    _this.ticks.template.location = 0;\n    _this.ticks.template.pixelPerfect = false;\n    _this.tooltipLocation = 0;\n    _this.line.strokeOpacity = 0;\n\n    _this.applyTheme();\n\n    return _this;\n  }\n  /**\r\n  * @ignore\r\n  */\n\n\n  AxisRendererCircular.prototype.setAxis = function (axis) {\n    var _this = this;\n\n    _super.prototype.setAxis.call(this, axis);\n\n    axis.isMeasured = false; // modify x and y so that tooltip would always be on circle\n\n    var tooltip = axis.tooltip;\n    tooltip.adapter.add(\"dx\", function (x, target) {\n      var point = $utils.svgPointToSprite({\n        x: target.pixelX,\n        y: target.pixelY\n      }, _this);\n      return _this.pixelRadius * Math.cos(Math.atan2(point.y, point.x)) - point.x;\n    });\n    tooltip.adapter.add(\"dy\", function (y, target) {\n      var point = $utils.svgPointToSprite({\n        x: target.pixelX,\n        y: target.pixelY\n      }, _this);\n      return _this.pixelRadius * Math.sin(Math.atan2(point.y, point.x)) - point.y;\n    });\n  };\n  /**\r\n   * Validates Axis renderer.\r\n   *\r\n   * @ignore Exclude from docs\r\n   */\n\n\n  AxisRendererCircular.prototype.validate = function () {\n    // so that radius would be updated\n    if (this.chart && this.chart.invalid) {\n      this.chart.validate();\n    }\n\n    _super.prototype.validate.call(this);\n  };\n\n  Object.defineProperty(AxisRendererCircular.prototype, \"axisLength\", {\n    /**\r\n     * Returns actual length of the Axis, in pixels.\r\n     *\r\n     * @return Length (px)\r\n     */\n    get: function () {\n      return 2 * Math.PI * this.pixelRadius;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(AxisRendererCircular.prototype, \"radius\", {\n    /**\r\n     * @return Outer radius\r\n     */\n    get: function () {\n      return this.getPropertyValue(\"radius\");\n    },\n\n    /**\r\n     * Outer radius of the axis.\r\n     *\r\n     * Can be absolute (px) or relative ([[Percent]]).\r\n     *\r\n     * @param value  Outer radius\r\n     */\n    set: function (value) {\n      if (this.setPercentProperty(\"radius\", value, false, false, 10, false)) {\n        if (this.axis) {\n          this.axis.invalidate();\n        }\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(AxisRendererCircular.prototype, \"pixelRadius\", {\n    /**\r\n     * Outer radius in pixels.\r\n     *\r\n     * @return Outer radius (px)\r\n     */\n    get: function () {\n      return $utils.relativeRadiusToValue(this.radius, this.pixelRadiusReal) || 0;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(AxisRendererCircular.prototype, \"innerRadius\", {\n    /**\r\n     * @return Inner radius\r\n     */\n    get: function () {\n      return this.getPropertyValue(\"innerRadius\");\n    },\n\n    /**\r\n     * Inner radius of the axis.\r\n     *\r\n     * Can be absolute (px) or relative ([[Percent]]).\r\n     *\r\n     * @param value  Inner radius\r\n     */\n    set: function (value) {\n      if (this.setPercentProperty(\"innerRadius\", value, false, false, 10, false)) {\n        if (this.axis) {\n          this.axis.invalidate();\n        }\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(AxisRendererCircular.prototype, \"useChartAngles\", {\n    /**\r\n     * @return Use chart angles\r\n     */\n    get: function () {\n      return this.getPropertyValue(\"useChartAngles\");\n    },\n\n    /**\r\n     * Specifies if axis should use its own `startAngle` and `endAngle` or\r\n     * inherit them from relative properties from chart.\r\n     *\r\n     * @default false\r\n     * @param value  Use chart's angles\r\n     */\n    set: function (value) {\n      this.setPropertyValue(\"useChartAngles\", value);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(AxisRendererCircular.prototype, \"pixelInnerRadius\", {\n    /**\r\n     * Inner radius in pixels.\r\n     *\r\n     * @return Inner radius (px)\r\n     */\n    get: function () {\n      return $utils.relativeRadiusToValue(this.innerRadius, this.pixelRadiusReal) || 0;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\r\n   * Converts relative position on axis to point coordinates.\r\n   *\r\n   * @param position  Position (0-1)\r\n   * @param position2  Position (0-1) Position on the second axis\r\n   * @return Point\r\n   */\n\n  AxisRendererCircular.prototype.positionToPoint = function (position, position2) {\n    if (!$type.isNumber(position2)) {\n      position2 = 1;\n    }\n\n    var coordinate = this.positionToCoordinate(position);\n    var angle = this.startAngle + (this.endAngle - this.startAngle) * coordinate / this.axisLength;\n    var radius = this.pixelRadius;\n    var innerRadius = this.pixelInnerRadius;\n\n    if (this.axisRendererY) {\n      var realRadius = $math.fitToRange(this.axisRendererY.positionToCoordinate(position2), 0, Infinity);\n      return {\n        x: realRadius * $math.cos(angle),\n        y: realRadius * $math.sin(angle)\n      };\n    }\n\n    return {\n      x: $math.cos(angle) * innerRadius + (radius - innerRadius) * $math.cos(angle) * position2,\n      y: $math.sin(angle) * innerRadius + (radius - innerRadius) * $math.sin(angle) * position2\n    };\n  };\n  /**\r\n   * Converts relative position (0-1) on axis to angle in degrees (0-360).\r\n   *\r\n   * @param position  Position (0-1)\r\n   * @return Angle (0-360)\r\n   */\n\n\n  AxisRendererCircular.prototype.positionToAngle = function (position) {\n    var axis = this.axis;\n    var arc = (this.endAngle - this.startAngle) / (axis.end - axis.start);\n    var angle;\n\n    if (axis.renderer.inversed) {\n      angle = this.startAngle + (axis.end - position) * arc;\n    } else {\n      angle = this.startAngle + (position - axis.start) * arc;\n    }\n\n    return $math.round(angle, 3);\n  };\n  /**\r\n   * Updates and positions the axis line element.\r\n   *\r\n   * @ignore Exclude from docs\r\n   */\n\n\n  AxisRendererCircular.prototype.updateAxisLine = function () {\n    var radius = this.pixelRadius;\n    var startAngle = this.startAngle;\n    var endAngle = this.endAngle;\n    var arc = endAngle - startAngle;\n    this.line.path = $path.moveTo({\n      x: radius * $math.cos(startAngle),\n      y: radius * $math.sin(startAngle)\n    }) + $path.arcTo(startAngle, arc, radius, radius);\n  };\n  /**\r\n   * Updates and positions a grid element.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param grid         Grid element\r\n   * @param position     Starting position\r\n   * @param endPosition  End position\r\n   */\n\n\n  AxisRendererCircular.prototype.updateGridElement = function (grid, position, endPosition) {\n    position = position + (endPosition - position) * grid.location;\n    var point = this.positionToPoint(position);\n\n    if ($type.isNumber(point.x) && $type.isNumber(point.y) && grid.element) {\n      var angle = $math.DEGREES * Math.atan2(point.y, point.x);\n      var radius = $utils.relativeRadiusToValue($type.hasValue(grid.radius) ? grid.radius : percent(100), this.pixelRadius);\n      var gridInnerRadius = $utils.relativeRadiusToValue(grid.innerRadius, this.pixelRadius);\n      grid.zIndex = 0;\n      var innerRadius = $utils.relativeRadiusToValue($type.isNumber(gridInnerRadius) ? gridInnerRadius : this.innerRadius, this.pixelRadius, true);\n      grid.path = $path.moveTo({\n        x: innerRadius * $math.cos(angle),\n        y: innerRadius * $math.sin(angle)\n      }) + $path.lineTo({\n        x: radius * $math.cos(angle),\n        y: radius * $math.sin(angle)\n      });\n    }\n\n    this.toggleVisibility(grid, position, 0, 1);\n  };\n  /**\r\n   * Updates and positions a tick element.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param tick         Tick element\r\n   * @param position     Starting position\r\n   * @param endPosition  End position\r\n   */\n\n\n  AxisRendererCircular.prototype.updateTickElement = function (tick, position, endPosition) {\n    position = position + (endPosition - position) * tick.location;\n    var point = this.positionToPoint(position);\n\n    if (tick.element) {\n      var radius = this.pixelRadius;\n      var angle = $math.DEGREES * Math.atan2(point.y, point.x);\n      var tickLength = tick.length;\n\n      if (tick.inside) {\n        tickLength = -tickLength;\n      }\n\n      tick.zIndex = 1;\n      tick.path = $path.moveTo({\n        x: radius * $math.cos(angle),\n        y: radius * $math.sin(angle)\n      }) + $path.lineTo({\n        x: (radius + tickLength) * $math.cos(angle),\n        y: (radius + tickLength) * $math.sin(angle)\n      });\n    }\n\n    this.toggleVisibility(tick, position, 0, 1);\n  };\n  /**\r\n   * Updates and positions axis bullet.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param bullet       AxisBullet element\r\n   * @param position     Starting position\r\n   * @param endPosition  End position\r\n   */\n\n\n  AxisRendererCircular.prototype.updateBullet = function (bullet, position, endPosition) {\n    var location = 0.5;\n\n    if (bullet instanceof AxisBullet) {\n      location = bullet.location;\n    }\n\n    position = position + (endPosition - position) * location;\n    var point = this.positionToPoint(position);\n    var radius = this.pixelRadius;\n    var angle = $math.DEGREES * Math.atan2(point.y, point.x);\n    point = {\n      x: radius * $math.cos(angle),\n      y: radius * $math.sin(angle)\n    };\n    this.positionItem(bullet, point);\n    this.toggleVisibility(bullet, position, 0, 1);\n  };\n  /**\r\n   * Updates and positions a label element.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param label        Label element\r\n   * @param position     Starting position\r\n   * @param endPosition  Ending position\r\n   */\n\n\n  AxisRendererCircular.prototype.updateLabelElement = function (label, position, endPosition, location) {\n    if (!$type.hasValue(location)) {\n      location = label.location;\n    }\n\n    position = position + (endPosition - position) * location;\n    label.fixPosition(this.positionToAngle(position), this.pixelRadius);\n    label.zIndex = 2;\n    this.toggleVisibility(label, position, this.minLabelPosition, this.maxLabelPosition);\n  };\n  /**\r\n   * Checks if point is within bounds of a container.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param point Point coordinates\r\n   * @return Fits?\r\n   */\n\n\n  AxisRendererCircular.prototype.fitsToBounds = function (point) {\n    return true;\n  };\n\n  Object.defineProperty(AxisRendererCircular.prototype, \"startAngle\", {\n    /**\r\n     * @return Start angle\r\n     */\n    get: function () {\n      return this.getPropertyValue(\"startAngle\");\n    },\n\n    /**\r\n     * Start angle of the axis in degrees (0-360).\r\n     *\r\n     * @param value  Start angle\r\n     */\n    set: function (value) {\n      // do not normalize angel here!\n      if (this.setPropertyValue(\"startAngle\", value)) {\n        this.invalidateAxisItems();\n\n        if (this.axis) {\n          this.axis.invalidateSeries();\n        }\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(AxisRendererCircular.prototype, \"endAngle\", {\n    /**\r\n     * @return End angle\r\n     */\n    get: function () {\n      return this.getPropertyValue(\"endAngle\");\n    },\n\n    /**\r\n     * End angle of the axis in degrees (0-360).\r\n     *\r\n     * @param value  End angle\r\n     */\n    set: function (value) {\n      // do not normalize angel here!\n      if (this.setPropertyValue(\"endAngle\", value)) {\n        this.invalidateAxisItems();\n\n        if (this.axis) {\n          this.axis.invalidateSeries();\n        }\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\r\n   * [getPositionRangePath description]\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @todo Description\r\n   * @param startPosition  Starting position\r\n   * @param endPosition    End position\r\n   * @return SVG path\r\n   */\n\n  AxisRendererCircular.prototype.getPositionRangePath = function (startPosition, endPosition, radius, innerRadius, cornerRadius) {\n    var path = \"\";\n\n    if ($type.isNumber(startPosition) && $type.isNumber(endPosition)) {\n      if (!$type.hasValue(radius)) {\n        radius = this.radius;\n      }\n\n      startPosition = $math.max(startPosition, this.axis.start);\n      endPosition = $math.min(endPosition, this.axis.end);\n\n      if (endPosition < startPosition) {\n        endPosition = startPosition;\n      }\n\n      var pixelRadius = $utils.relativeRadiusToValue(radius, this.pixelRadius);\n      var pixelInnerRadius = $utils.relativeRadiusToValue(innerRadius, this.pixelRadius, true);\n      var startAngle = this.positionToAngle(startPosition);\n      var endAngle = this.positionToAngle(endPosition);\n      var arc = endAngle - startAngle;\n      path = $path.arc(startAngle, arc, pixelRadius, pixelInnerRadius, pixelRadius, cornerRadius);\n    }\n\n    return path;\n  };\n  /**\r\n   * Returns a new grid element, suitable for this Axis Renderer type.\r\n   *\r\n   * @return Grid element\r\n   */\n\n\n  AxisRendererCircular.prototype.createGrid = function () {\n    return new GridCircular();\n  };\n  /**\r\n   * Returns a new fill element, suitable for this Axis Renderer type.\r\n   *\r\n   * @return Fill element\r\n   */\n\n\n  AxisRendererCircular.prototype.createFill = function (axis) {\n    return new AxisFillCircular(axis);\n  };\n  /**\r\n   * Returns a new label element, suitable for this Axis Renderer type.\r\n   *\r\n   * @return Label element\r\n   */\n\n\n  AxisRendererCircular.prototype.createLabel = function () {\n    return new AxisLabelCircular();\n  };\n  /**\r\n   * Converts a point at specific coordinates to a relative position (0-1)\r\n   * on the axis.\r\n   *\r\n   * @param point  Point\r\n   * @return Position (0-1)\r\n   */\n\n\n  AxisRendererCircular.prototype.pointToPosition = function (point) {\n    var angle = $math.fitAngleToRange($math.getAngle(point), this.startAngle, this.endAngle);\n    return this.coordinateToPosition((angle - this.startAngle) / 360 * this.axisLength);\n  };\n\n  return AxisRendererCircular;\n}(AxisRenderer);\n\nexport { AxisRendererCircular };\n/**\r\n * Register class in system, so that it can be instantiated using its name from\r\n * anywhere.\r\n *\r\n * @ignore\r\n */\n\nregistry.registeredClasses[\"AxisRendererCircular\"] = AxisRendererCircular;","map":null,"metadata":{},"sourceType":"module"}