{"ast":null,"code":"/**\r\n * Sankey diagram module.\r\n */\nimport * as tslib_1 from \"tslib\";\n/**\r\n * ============================================================================\r\n * IMPORTS\r\n * ============================================================================\r\n * @hidden\r\n */\n\nimport { FlowDiagram, FlowDiagramDataItem } from \"./FlowDiagram\";\nimport { percent } from \"../../core/utils/Percent\";\nimport { registry } from \"../../core/Registry\";\nimport { SankeyNode } from \"../elements/SankeyNode\";\nimport { SankeyLink } from \"../elements/SankeyLink\";\nimport { Animation } from \"../../core/utils/Animation\";\nimport * as $iter from \"../../core/utils/Iterator\";\nimport * as $math from \"../../core/utils/Math\";\nimport * as $type from \"../../core/utils/Type\";\nimport * as $object from \"../../core/utils/Object\";\n/**\r\n * ============================================================================\r\n * DATA ITEM\r\n * ============================================================================\r\n * @hidden\r\n */\n//@todo rearange notes after dragged\n\n/**\r\n * Defines a [[DataItem]] for [[SankeyDiagram]].\r\n *\r\n * @see {@link DataItem}\r\n */\n\nvar SankeyDiagramDataItem =\n/** @class */\nfunction (_super) {\n  tslib_1.__extends(SankeyDiagramDataItem, _super);\n  /**\r\n   * Constructor\r\n   */\n\n\n  function SankeyDiagramDataItem() {\n    var _this = _super.call(this) || this;\n\n    _this.className = \"SankeyDiagramDataItem\";\n\n    _this.applyTheme();\n\n    return _this;\n  }\n\n  return SankeyDiagramDataItem;\n}(FlowDiagramDataItem);\n\nexport { SankeyDiagramDataItem };\n/**\r\n * ============================================================================\r\n * MAIN CLASS\r\n * ============================================================================\r\n * @hidden\r\n */\n\n/**\r\n * Creates a Sankey Diagram chart.\r\n *\r\n * @see {@link ISankeyDiagramEvents} for a list of available Events\r\n * @see {@link ISankeyDiagramAdapters} for a list of available Adapters\r\n * @see {@link https://www.amcharts.com/docs/v4/chart-types/sankey-diagram/} for documentation\r\n * @important\r\n */\n\nvar SankeyDiagram =\n/** @class */\nfunction (_super) {\n  tslib_1.__extends(SankeyDiagram, _super);\n  /**\r\n   * Constructor\r\n   */\n\n\n  function SankeyDiagram() {\n    var _this = // Init\n    _super.call(this) || this;\n\n    _this.className = \"SankeyDiagram\";\n    _this.orientation = \"horizontal\";\n    _this.nodeAlign = \"middle\";\n    _this.nodesContainer.width = percent(100);\n    _this.nodesContainer.height = percent(100);\n    _this.linksContainer.width = percent(100);\n    _this.linksContainer.height = percent(100); // Apply theme\n\n    _this.applyTheme();\n\n    return _this;\n  }\n  /**\r\n   * (Re)validates chart's data, effectively causing the chart to redraw.\r\n   *\r\n   * @ignore Exclude from docs\r\n   */\n\n\n  SankeyDiagram.prototype.validateData = function () {\n    var _this = this;\n\n    _super.prototype.validateData.call(this);\n\n    this._levelCount = 0;\n    this.nodes.each(function (key, node) {\n      node.level = undefined;\n    });\n    this.nodes.each(function (key, node) {\n      node.level = _this.getNodeLevel(node, 0);\n      _this._levelCount = $math.max(_this._levelCount, node.level);\n    });\n  };\n  /**\r\n   * Returns node's highest level.\r\n   *\r\n   * @param node   Node\r\n   * @param level  Current level\r\n   * @return New level\r\n   */\n\n\n  SankeyDiagram.prototype.getNodeLevel = function (node, level) {\n    var _this = this; //@todo solve circular so\n\n\n    var levels = [level];\n    $iter.each(node.incomingDataItems.iterator(), function (link) {\n      if (link.fromNode) {\n        if ($type.isNumber(link.fromNode.level)) {\n          levels.push(link.fromNode.level + 1);\n        } else {\n          levels.push(_this.getNodeLevel(link.fromNode, level + 1));\n        }\n      }\n    });\n    return Math.max.apply(Math, tslib_1.__spread(levels));\n  };\n  /**\r\n   * Calculates relation between pixel height and total value.\r\n   *\r\n   * In Sankey the actual thickness of links and height of nodes will depend\r\n   * on their values.\r\n   */\n\n\n  SankeyDiagram.prototype.calculateValueHeight = function () {\n    var _this = this; // calculate sums of each level\n\n\n    this._levelSum = {};\n    this._levelNodesCount = {};\n    this.maxSum = 0;\n    var total = this.dataItem.values.value.sum;\n    $iter.each(this._sorted, function (strNode) {\n      var node = strNode[1];\n\n      _this.getNodeValue(node);\n    });\n    this.nodes.each(function (key, node) {\n      var level = node.level;\n      var value = Math.max(node.totalIncoming, node.totalOutgoing);\n\n      if (value / total < _this.minNodeSize) {\n        value = total * _this.minNodeSize;\n      }\n\n      if ($type.isNumber(_this._levelSum[level])) {\n        _this._levelSum[level] += value;\n      } else {\n        _this._levelSum[level] = value;\n      }\n\n      if ($type.isNumber(_this._levelNodesCount[level])) {\n        _this._levelNodesCount[level]++;\n      } else {\n        _this._levelNodesCount[level] = 1;\n      }\n    });\n    var availableHeight;\n\n    if (this.orientation == \"horizontal\") {\n      availableHeight = this.chartContainer.maxHeight - 1;\n    } else {\n      availableHeight = this.chartContainer.maxWidth - 1;\n    }\n\n    var maxSumLevel;\n    var minHeight;\n    $object.each(this._levelSum, function (key, value) {\n      var realValue = value;\n      var levelNodeCount = _this._levelNodesCount[key];\n      var valueHeight = (availableHeight - (levelNodeCount - 1) * _this.nodePadding) / realValue;\n\n      if (minHeight > valueHeight || !$type.isNumber(minHeight)) {\n        minHeight = valueHeight;\n        _this.maxSum = realValue;\n        maxSumLevel = $type.toNumber(key);\n      }\n    });\n    this._maxSumLevel = maxSumLevel;\n    var maxSumLevelNodeCount = this._levelNodesCount[this._maxSumLevel];\n    var valueHeight = (availableHeight - (maxSumLevelNodeCount - 1) * this.nodePadding) / this.maxSum;\n\n    if (!$type.isNumber(this.valueHeight)) {\n      this.valueHeight = valueHeight;\n    } else {\n      var finalHeight = void 0;\n\n      try {\n        finalHeight = this._heightAnimation.animationOptions[0].to;\n      } catch (err) {} // without animations it will be non-smooth as maxValue jumps from one column to another\n\n\n      if (finalHeight != valueHeight) {\n        var duration = this.interpolationDuration;\n\n        try {\n          duration = this.nodes.template.states.getKey(\"active\").transitionDuration;\n        } catch (err) {}\n\n        this._heightAnimation = new Animation(this, {\n          property: \"valueHeight\",\n          from: this.valueHeight,\n          to: valueHeight\n        }, duration, this.interpolationEasing).start();\n\n        this._disposers.push(this._heightAnimation);\n      }\n    }\n  };\n  /**\r\n   * Redraws the chart.\r\n   *\r\n   * @ignore Exclude from docs\r\n   */\n\n\n  SankeyDiagram.prototype.validate = function () {\n    var _this = this;\n\n    _super.prototype.validate.call(this);\n\n    this.calculateValueHeight();\n    var container = this.nodesContainer;\n    var nextCoordinate = {};\n    var maxSumLevelNodeCount = this._levelNodesCount[this._maxSumLevel];\n    var total = this.dataItem.values.value.sum;\n    $iter.each(this._sorted, function (strNode) {\n      var node = strNode[1];\n      var level = node.level;\n      var levelCoordinate = 0;\n      var nodeCount = _this._levelNodesCount[level];\n\n      switch (_this.nodeAlign) {\n        case \"bottom\":\n          levelCoordinate = (_this.maxSum - _this._levelSum[level]) * _this.valueHeight - (nodeCount - maxSumLevelNodeCount) * _this.nodePadding;\n          break;\n\n        case \"middle\":\n          levelCoordinate = (_this.maxSum - _this._levelSum[level]) * _this.valueHeight / 2 - (nodeCount - maxSumLevelNodeCount) * _this.nodePadding / 2;\n          break;\n      }\n\n      node.parent = container;\n      var delta;\n      var x;\n      var y;\n      var value = Math.max(node.totalIncoming, node.totalOutgoing);\n\n      if (value / total < _this.minNodeSize) {\n        value = total * _this.minNodeSize;\n      }\n\n      if (_this.orientation == \"horizontal\") {\n        delta = (_this.innerWidth - node.pixelWidth) / _this._levelCount;\n        x = delta * node.level;\n        y = nextCoordinate[level] || levelCoordinate;\n        var h = value * _this.valueHeight;\n        node.height = h;\n        node.minX = x;\n        node.maxX = x;\n        nextCoordinate[level] = y + h + _this.nodePadding;\n      } else {\n        delta = (_this.innerHeight - node.pixelHeight) / _this._levelCount;\n        x = nextCoordinate[level] || levelCoordinate;\n        y = delta * node.level;\n        var w = value * _this.valueHeight;\n        node.width = w;\n        node.minY = y;\n        node.maxY = y;\n        nextCoordinate[level] = x + w + _this.nodePadding;\n      }\n\n      node.x = x;\n      node.y = y;\n    });\n  };\n  /**\r\n   * Performs actual operations to reveal this element.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param duration Fade in duration (ms)\r\n   * @return Fade in duration (ms)\r\n   */\n\n\n  SankeyDiagram.prototype.showReal = function (duration) {\n    var _this = this;\n\n    if (this.interpolationDuration > 0) {\n      var container_1 = this.nodesContainer;\n      var i_1 = 0;\n      $iter.each(this.links.iterator(), function (link) {\n        link.hide(0);\n      });\n      $iter.each(this._sorted, function (strNode) {\n        var node = strNode[1];\n        var property;\n\n        if (_this.orientation == \"horizontal\") {\n          node.dx = -(container_1.pixelWidth - node.pixelWidth) / _this._levelCount;\n          property = \"dx\";\n        } else {\n          node.dy = -(container_1.pixelHeight - node.pixelHeight) / _this._levelCount;\n          property = \"dy\";\n        }\n\n        var delay = 0;\n        var duration = _this.interpolationDuration;\n\n        if (_this.sequencedInterpolation) {\n          delay = _this.sequencedInterpolationDelay * i_1 + duration * i_1 / $iter.length(_this.nodes.iterator());\n        }\n\n        node.opacity = 0;\n        node.invalidateLinks();\n        node.animate([{\n          property: \"opacity\",\n          from: 0,\n          to: 1\n        }, {\n          property: property,\n          to: 0\n        }], _this.interpolationDuration, _this.interpolationEasing).delay(delay);\n        $iter.each(node.outgoingDataItems.iterator(), function (dataItem) {\n          var animation = dataItem.link.show(_this.interpolationDuration);\n\n          if (animation && !animation.isFinished()) {\n            animation.delay(delay);\n          }\n        });\n        $iter.each(node.incomingDataItems.iterator(), function (dataItem) {\n          if (!dataItem.fromNode) {\n            var animation = dataItem.link.show(_this.interpolationDuration);\n\n            if (animation && !animation.isFinished()) {\n              animation.delay(delay);\n            }\n          }\n        });\n        i_1++;\n      });\n    }\n\n    return _super.prototype.showReal.call(this);\n  };\n  /**\r\n   * Changes the sort type of the nodes.\r\n   *\r\n   * This will actually reshuffle nodes using nice animation.\r\n   */\n\n\n  SankeyDiagram.prototype.changeSorting = function () {\n    var _this = this;\n\n    this.sortNodes();\n    var nextCoordinate = {};\n    $iter.each(this._sorted, function (strNode) {\n      var node = strNode[1];\n      var level = node.level;\n      var levelCoordinate = (_this.maxSum - _this._levelSum[level]) * _this.valueHeight / 2;\n      var property;\n      var nodeHeight;\n\n      if (_this.orientation == \"horizontal\") {\n        property = \"y\";\n        nodeHeight = node.pixelHeight;\n      } else {\n        property = \"x\";\n        nodeHeight = node.pixelWidth;\n      }\n\n      node.animate({\n        property: property,\n        to: nextCoordinate[level] || levelCoordinate\n      }, _this.interpolationDuration, _this.interpolationEasing);\n      nextCoordinate[level] = (nextCoordinate[level] || levelCoordinate) + nodeHeight + _this.nodePadding;\n      node.invalidateLinks();\n    });\n  };\n  /**\r\n   * Sets defaults that instantiate some objects that rely on parent, so they\r\n   * cannot be set in constructor.\r\n   */\n\n\n  SankeyDiagram.prototype.applyInternalDefaults = function () {\n    _super.prototype.applyInternalDefaults.call(this); // Add a default screen reader title for accessibility\n    // This will be overridden in screen reader if there are any `titles` set\n\n\n    if (!$type.hasValue(this.readerTitle)) {\n      this.readerTitle = this.language.translate(\"Sankey diagram\");\n    }\n  };\n  /**\r\n   * Creates and returns a new data item.\r\n   *\r\n   * @return Data item\r\n   */\n\n\n  SankeyDiagram.prototype.createDataItem = function () {\n    return new SankeyDiagramDataItem();\n  };\n\n  Object.defineProperty(SankeyDiagram.prototype, \"nodeAlign\", {\n    /**\r\n     * @returns Returns nodeAlign value\r\n     */\n    get: function () {\n      return this.getPropertyValue(\"nodeAlign\");\n    },\n\n    /**\r\n     * How to align nodes. In case layout is vertical, top means left and bottom means right\r\n     *\r\n     * @param value  Node sorting\r\n     */\n    set: function (value) {\n      this.setPropertyValue(\"nodeAlign\", value);\n      this.changeSorting();\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(SankeyDiagram.prototype, \"orientation\", {\n    /**\r\n     * @return Orientation\r\n     */\n    get: function () {\n      return this.getPropertyValue(\"orientation\");\n    },\n\n    /**\r\n     * Orientation of the chart: \"horizontal\" or \"vertical\";\r\n     *\r\n     * @param value Orientation\r\n     */\n    set: function (value) {\n      this.setPropertyValue(\"orientation\", value, true);\n      var nameLabel = this.nodes.template.nameLabel;\n\n      if (value == \"vertical\") {\n        this.nodes.template.width = undefined;\n        nameLabel.label.horizontalCenter = \"middle\";\n        nameLabel.locationX = 0.5;\n      } else {\n        this.nodes.template.height = undefined;\n        nameLabel.label.horizontalCenter = \"left\";\n        nameLabel.locationX = 1;\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\r\n   * @ignore\r\n   */\n\n  SankeyDiagram.prototype.createNode = function () {\n    var node = new SankeyNode();\n\n    this._disposers.push(node);\n\n    return node;\n  };\n  /**\r\n   * @ignore\r\n   */\n\n\n  SankeyDiagram.prototype.createLink = function () {\n    var link = new SankeyLink();\n\n    this._disposers.push(link);\n\n    return link;\n  };\n\n  Object.defineProperty(SankeyDiagram.prototype, \"valueHeight\", {\n    /**\r\n     * @ignore\r\n     */\n    get: function () {\n      return this._valueHeight;\n    },\n\n    /**\r\n     * @ignore\r\n     */\n    set: function (value) {\n      if (value != this._valueHeight) {\n        this._valueHeight = value;\n        this.invalidate();\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\r\n   * @ignore\r\n   */\n\n  SankeyDiagram.prototype.disposeData = function () {\n    _super.prototype.disposeData.call(this);\n\n    this._sorted = this.nodes.iterator();\n  };\n\n  return SankeyDiagram;\n}(FlowDiagram);\n\nexport { SankeyDiagram };\n/**\r\n * Register class in system, so that it can be instantiated using its name from\r\n * anywhere.\r\n *\r\n * @ignore\r\n */\n\nregistry.registeredClasses[\"SankeyDiagram\"] = SankeyDiagram;","map":null,"metadata":{},"sourceType":"module"}