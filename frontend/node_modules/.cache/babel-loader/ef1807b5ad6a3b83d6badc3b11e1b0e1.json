{"ast":null,"code":"/**\r\n * Column series module.\r\n */\nimport * as tslib_1 from \"tslib\";\n/**\r\n * ============================================================================\r\n * IMPORTS\r\n * ============================================================================\r\n * @hidden\r\n */\n\nimport { XYSeries, XYSeriesDataItem } from \"./XYSeries\";\nimport { visualProperties } from \"../../core/Sprite\";\nimport { Container } from \"../../core/Container\";\nimport { ListTemplate, ListDisposer } from \"../../core/utils/List\";\nimport { Dictionary } from \"../../core/utils/Dictionary\";\nimport { ValueAxis } from \"../axes/ValueAxis\";\nimport { CategoryAxis } from \"../axes/CategoryAxis\";\nimport { registry } from \"../../core/Registry\";\nimport { Column } from \"../elements/Column\";\nimport { RoundedRectangle } from \"../../core/elements/RoundedRectangle\";\nimport { percent } from \"../../core/utils/Percent\";\nimport * as $math from \"../../core/utils/Math\";\nimport * as $object from \"../../core/utils/Object\";\nimport * as $iter from \"../../core/utils/Iterator\";\nimport * as $array from \"../../core/utils/Array\";\nimport * as $type from \"../../core/utils/Type\";\nimport { Disposer } from \"../../core/utils/Disposer\";\n/**\r\n * ============================================================================\r\n * DATA ITEM\r\n * ============================================================================\r\n * @hidden\r\n */\n\n/**\r\n * Defines a [[DataItem]] for [[ColumnSeries]].\r\n *\r\n * @see {@link DataItem}\r\n */\n\nvar ColumnSeriesDataItem =\n/** @class */\nfunction (_super) {\n  tslib_1.__extends(ColumnSeriesDataItem, _super);\n  /**\r\n   * Constructor\r\n   */\n\n\n  function ColumnSeriesDataItem() {\n    var _this = _super.call(this) || this;\n\n    _this.className = \"ColumnSeriesDataItem\";\n    _this.locations[\"dateX\"] = 0.5;\n    _this.locations[\"dateY\"] = 0.5;\n    _this.locations[\"categoryX\"] = 0.5;\n    _this.locations[\"categoryY\"] = 0.5;\n\n    _this.applyTheme();\n\n    return _this;\n  }\n\n  Object.defineProperty(ColumnSeriesDataItem.prototype, \"column\", {\n    /**\r\n     * @return Column\r\n     */\n    get: function () {\n      return this._column;\n    },\n\n    /**\r\n     * A column used to draw a column for this data item.\r\n     *\r\n     * @param column\r\n     */\n    set: function (column) {\n      this.setColumn(column);\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  ColumnSeriesDataItem.prototype.setColumn = function (column) {\n    var _this = this;\n\n    if (this._column && column != this._column) {\n      $array.remove(this.sprites, this._column);\n    }\n\n    this._column = column;\n\n    if (column) {\n      var prevDataItem = column.dataItem;\n\n      if (prevDataItem && prevDataItem != this) {\n        prevDataItem.column = undefined;\n      }\n\n      this.addSprite(column);\n\n      this._disposers.push(new Disposer(function () {\n        // TODO investigate why component is undefined\n        // https://codepen.io/team/amcharts/pen/dac4be245d658233a6d7e5597df2208b?editors=0010\n        if (_this.component) {\n          _this.component.columns.removeValue(column);\n        }\n      }));\n    }\n  };\n\n  Object.defineProperty(ColumnSeriesDataItem.prototype, \"rangesColumns\", {\n    /**\r\n     * A dictionary storing axes ranges columns by axis uid\r\n     */\n    get: function () {\n      if (!this._rangesColumns) {\n        this._rangesColumns = new Dictionary();\n      }\n\n      return this._rangesColumns;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  return ColumnSeriesDataItem;\n}(XYSeriesDataItem);\n\nexport { ColumnSeriesDataItem };\n/**\r\n * ============================================================================\r\n * MAIN CLASS\r\n * ============================================================================\r\n * @hidden\r\n */\n\n/**\r\n * Defines [[Series]] for a column graph.\r\n *\r\n * @see {@link IColumnSeriesEvents} for a list of available Events\r\n * @see {@link IColumnSeriesAdapters} for a list of available Adapters\r\n * @todo Example\r\n * @important\r\n */\n\nvar ColumnSeries =\n/** @class */\nfunction (_super) {\n  tslib_1.__extends(ColumnSeries, _super);\n  /**\r\n   * Constructor\r\n   */\n\n\n  function ColumnSeries() {\n    var _this = _super.call(this) || this;\n    /**\r\n     * Start location within cell for columns.\r\n     */\n\n\n    _this._startLocation = 0;\n    /**\r\n     * End location within cell for columns.\r\n     */\n\n    _this._endLocation = 1;\n    _this.className = \"ColumnSeries\";\n    _this.width = percent(100);\n    _this.height = percent(100);\n    _this.strokeOpacity = 0;\n    _this.fillOpacity = 1;\n    _this.clustered = true;\n\n    var columnsContainer = _this.mainContainer.createChild(Container);\n\n    columnsContainer.shouldClone = false;\n    columnsContainer.isMeasured = false;\n    columnsContainer.layout = \"none\";\n    _this._columnsContainer = columnsContainer;\n    _this.columns.template.pixelPerfect = false;\n    _this.tooltipColorSource = _this.columns.template;\n\n    _this.applyTheme();\n\n    return _this;\n  }\n\n  Object.defineProperty(ColumnSeries.prototype, \"columnsContainer\", {\n    /**\r\n     * A container that columns are created in.\r\n     *\r\n     * @ignore Exclude from docs\r\n     */\n    get: function () {\n      return this._columnsContainer;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\r\n   * Sets defaults that instantiate some objects that rely on parent, so they\r\n   * cannot be set in constructor.\r\n   */\n\n  ColumnSeries.prototype.applyInternalDefaults = function () {\n    _super.prototype.applyInternalDefaults.call(this);\n\n    if (!$type.hasValue(this.readerTitle)) {\n      this.readerTitle = this.language.translate(\"Column Series\");\n    }\n  };\n  /**\r\n   * Returns a new/empty DataItem of the type appropriate for this object.\r\n   *\r\n   * @see {@link DataItem}\r\n   * @return Data Item\r\n   */\n\n\n  ColumnSeries.prototype.createDataItem = function () {\n    return new ColumnSeriesDataItem();\n  };\n  /**\r\n   * (Re)validates the whole series, effectively causing it to redraw.\r\n   *\r\n   * @ignore Exclude from docs\r\n   */\n\n\n  ColumnSeries.prototype.validate = function () {\n    var _this = this; //@todo Check if we can do better than use `instanceof`\n    // find start/end locations based on clustered/stacked settings\n    // go through chart series instead of base axis series, because axis series doesn't maintain order\n\n\n    if (this.chart) {\n      var baseAxisSeries = this.chart.series;\n      var clusterCount_1 = 0;\n      var index_1 = 0;\n      $iter.each(baseAxisSeries.iterator(), function (series) {\n        if (series instanceof ColumnSeries) {\n          if (_this.baseAxis == series.baseAxis) {\n            if (!series.stacked && series.clustered || clusterCount_1 === 0) {\n              clusterCount_1++;\n            }\n\n            if (series == _this) {\n              index_1 = clusterCount_1 - 1;\n            }\n          }\n        }\n      });\n      var renderer = this.baseAxis.renderer;\n      var cellStartLocation = renderer.cellStartLocation;\n      var cellEndLocation = renderer.cellEndLocation;\n      this._startLocation = cellStartLocation + index_1 / clusterCount_1 * (cellEndLocation - cellStartLocation);\n      this._endLocation = cellStartLocation + (index_1 + 1) / clusterCount_1 * (cellEndLocation - cellStartLocation);\n    }\n\n    _super.prototype.validate.call(this);\n\n    for (var i = 0; i < this.startIndex; i++) {\n      var dataItem = this.dataItems.getIndex(i);\n      this.disableUnusedColumns(dataItem);\n    }\n\n    for (var i = this.dataItems.length - 1; i > this.endIndex; i--) {\n      var dataItem = this.dataItems.getIndex(i);\n      this.disableUnusedColumns(dataItem);\n    }\n  };\n  /**\r\n   * Validates data item's element, effectively redrawing it.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param dataItem  Data item\r\n   */\n\n\n  ColumnSeries.prototype.validateDataElement = function (dataItem) {\n    // important oder here, first real, then super. we need this to know size\n    this.validateDataElementReal(dataItem);\n\n    _super.prototype.validateDataElement.call(this, dataItem);\n  };\n  /**\r\n   * Returns relative start location for the data item.\r\n   *\r\n   * @param dataItem  Data item\r\n   * @return Location (0-1)\r\n   */\n\n\n  ColumnSeries.prototype.getStartLocation = function (dataItem) {\n    var startLocation = this._startLocation;\n\n    if (this.baseAxis == this.xAxis) {\n      startLocation += dataItem.locations[this.xOpenField] - 0.5;\n    } else {\n      startLocation += dataItem.locations[this.yOpenField] - 0.5;\n    }\n\n    return startLocation;\n  };\n  /**\r\n   * [handleDataItemWorkingValueChange description]\r\n   *\r\n   * @ignore Exclude from docs\r\n   */\n\n  /*\r\n  public handleDataItemWorkingValueChange(dataItem?: this[\"_dataItem\"], name?: string): void {\r\n     if (this.simplifiedProcessing) {\r\n         this.validateDataElement(dataItem);\r\n     }\r\n     else {\r\n         super.handleDataItemWorkingValueChange(dataItem, name);\r\n     }\r\n  }*/\n\n  /**\r\n   * Returns relative end location for the data item.\r\n   *\r\n   * @param dataItem  Data item\r\n   * @return Location (0-1)\r\n   */\n\n\n  ColumnSeries.prototype.getEndLocation = function (dataItem) {\n    var endLocation = this._endLocation;\n\n    if (this.baseAxis == this.xAxis) {\n      endLocation += dataItem.locations[this.xField] - 0.5;\n    } else {\n      endLocation += dataItem.locations[this.yField] - 0.5;\n    }\n\n    return endLocation;\n  };\n  /**\r\n   * Validates data item's elements.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param dataItem  Data item\r\n   */\n\n\n  ColumnSeries.prototype.validateDataElementReal = function (dataItem) {\n    var _this = this; //\tif (dataItem.hasValue([this.xField, this.yField])) { // todo: this doesn't work with categories, think of a better way\n\n\n    var l;\n    var r;\n    var t;\n    var b;\n    var startLocation = this.getStartLocation(dataItem);\n    var endLocation = this.getEndLocation(dataItem);\n    var xField = this.xField;\n    var xOpenField = this.xOpenField;\n    var yField = this.yField;\n    var yOpenField = this.yOpenField;\n    var template = this.columns.template;\n    var percentWidth = template.percentWidth;\n    var percentHeight = template.percentHeight;\n    var pixelWidth = template.pixelWidth;\n    var pixelHeight = template.pixelHeight;\n    var maxWidth = template.maxWidth;\n    var maxHeight = template.maxHeight;\n    var paddingLeft = template.pixelPaddingLeft;\n    var paddingRight = template.pixelPaddingRight;\n    var paddingTop = template.pixelPaddingTop;\n    var paddingBottom = template.pixelPaddingBottom;\n    var outOfBounds = false; // two category axes\n\n    if (this.xAxis instanceof CategoryAxis && this.yAxis instanceof CategoryAxis) {\n      if (!dataItem.hasValue(this._xValueFields) || !dataItem.hasValue(this._yValueFields)) {\n        return;\n      }\n\n      startLocation = 0;\n      endLocation = 1;\n\n      if (!$type.isNaN(percentWidth)) {\n        var offset = $math.round((endLocation - startLocation) * (1 - percentWidth / 100) / 2, 5);\n        startLocation += offset;\n        endLocation -= offset;\n      }\n\n      l = this.xAxis.getX(dataItem, xOpenField, startLocation);\n      r = this.xAxis.getX(dataItem, xField, endLocation); // in case width is set in pixels\n\n      if ($type.isNaN(percentWidth)) {\n        var offset = (r - l - pixelWidth) / 2;\n        l += offset;\n        r -= offset;\n      } // in case max width is set in pixels\n\n\n      if (!$type.isNaN(maxWidth) && maxWidth < Math.abs(r - l)) {\n        var offset = (r - l - maxWidth) / 2;\n        l += offset;\n        r -= offset;\n      }\n\n      startLocation = 0;\n      endLocation = 1;\n\n      if (!$type.isNaN(percentHeight)) {\n        var offset = $math.round((1 - percentHeight / 100) / 2, 5);\n        startLocation += offset;\n        endLocation -= offset;\n      }\n\n      t = this.yAxis.getY(dataItem, yOpenField, startLocation);\n      b = this.yAxis.getY(dataItem, yField, endLocation); // in case width is set in pixels\n\n      if ($type.isNaN(percentHeight)) {\n        var offset = (b - t - pixelHeight) / 2;\n        b += offset;\n        t -= offset;\n      } // in case max width is set in pixels\n\n\n      if (!$type.isNaN(maxHeight) && maxHeight < Math.abs(b - t)) {\n        var offset = (b - t - maxHeight) / 2;\n        b += offset;\n        t -= offset;\n      }\n\n      r = this.fixHorizontalCoordinate(r);\n      l = this.fixHorizontalCoordinate(l);\n      t = this.fixVerticalCoordinate(t);\n      b = this.fixVerticalCoordinate(b);\n    } else if (this.baseAxis == this.xAxis) {\n      if (!dataItem.hasValue(this._yValueFields)) {\n        return;\n      } // in case width is set in percent\n\n\n      if (!$type.isNaN(percentWidth)) {\n        var offset = $math.round((endLocation - startLocation) * (1 - percentWidth / 100) / 2, 5);\n        startLocation += offset;\n        endLocation -= offset;\n      }\n\n      l = this.xAxis.getX(dataItem, xOpenField, startLocation);\n      r = this.xAxis.getX(dataItem, xField, endLocation); // in case width is set in pixels\n\n      if ($type.isNaN(percentWidth)) {\n        var offset = (r - l - pixelWidth) / 2;\n        l += offset;\n        r -= offset;\n      } // in case width is set in pixels\n\n\n      if (!$type.isNaN(maxWidth) && maxWidth < Math.abs(r - l)) {\n        var offset = (r - l - maxWidth) / 2;\n        l += offset;\n        r -= offset;\n      }\n\n      var bottomLocation = dataItem.locations[yOpenField];\n      var topLocation = dataItem.locations[yField]; // otherwise gantt chart will start items in the middle of a cell\n\n      if (this.yAxis instanceof ValueAxis) {\n        if (this.dataFields[this.yField] != this.dataFields[this.yOpenField]) {\n          bottomLocation = 0;\n          topLocation = 0;\n        }\n      }\n\n      b = this.yAxis.getY(dataItem, yOpenField, bottomLocation);\n      t = this.yAxis.getY(dataItem, yField, topLocation); // used to save location for bullets, but it's not a good approach\n      // dataItem.locations[xField] = startLocation + (endLocation - startLocation) / 2;\n\n      var axisLenght = Math.ceil(this.yAxis.axisLength);\n\n      if (t < 0 && b < 0 || t > axisLenght && b > axisLenght) {\n        outOfBounds = true;\n      }\n\n      t = this.fixVerticalCoordinate(t);\n      b = this.fixVerticalCoordinate(b);\n\n      if (Math.abs(r - l) - paddingLeft - paddingRight == 0) {\n        outOfBounds = true;\n      }\n    } // horizontal bars\n    else {\n        if (!dataItem.hasValue(this._xValueFields)) {\n          return;\n        }\n\n        if (!$type.isNaN(percentHeight)) {\n          var offset = $math.round((endLocation - startLocation) * (1 - percentHeight / 100) / 2, 5);\n          startLocation += offset;\n          endLocation -= offset;\n        }\n\n        t = this.yAxis.getY(dataItem, yOpenField, startLocation);\n        b = this.yAxis.getY(dataItem, yField, endLocation); // in case height is set in pixels\n\n        if ($type.isNaN(percentHeight)) {\n          var offset = (b - t - pixelHeight) / 2;\n          b -= offset;\n          t += offset;\n        } // in case height is set in pixels\n\n\n        if (!$type.isNaN(maxHeight) && maxHeight < Math.abs(b - t)) {\n          var offset = (b - t - maxHeight) / 2;\n          b -= offset;\n          t += offset;\n        }\n\n        var rightLocation = dataItem.locations[xField];\n        var leftLocation = dataItem.locations[xOpenField]; // otherwise gantt chart will start items in the middle of a cell\n\n        if (this.xAxis instanceof ValueAxis) {\n          if (this.dataFields[this.xField] != this.dataFields[this.xOpenField]) {\n            rightLocation = 0;\n            leftLocation = 0;\n          }\n        }\n\n        r = this.xAxis.getX(dataItem, xField, rightLocation);\n        l = this.xAxis.getX(dataItem, xOpenField, leftLocation); // used to save location for bullets, but it's not a good approach\n        // dataItem.locations[yField] = startLocation + (endLocation - startLocation) / 2;\n\n        var axisLenght = Math.ceil(this.xAxis.axisLength);\n\n        if (r < 0 && l < 0 || r > axisLenght && l > axisLenght) {\n          outOfBounds = true;\n        }\n\n        r = this.fixHorizontalCoordinate(r);\n        l = this.fixHorizontalCoordinate(l);\n\n        if (Math.abs(t - b) - paddingTop - paddingBottom == 0) {\n          outOfBounds = true;\n        }\n      }\n\n    var w = Math.abs(r - l);\n    var h = Math.abs(b - t);\n    var x = Math.min(l, r);\n    var y = Math.min(t, b);\n\n    if (!outOfBounds) {\n      var column_1;\n\n      if (!dataItem.column) {\n        column_1 = this.columns.create(); //$object.forceCopyProperties(this.columns.template, column, visualProperties);\n\n        $object.copyProperties(this, column_1, visualProperties); // need this because 3d columns are not in the same container\n\n        $object.copyProperties(this.columns.template, column_1, visualProperties); // second time, no force, so that columns.template would override series properties\n\n        dataItem.addSprite(column_1);\n        dataItem.column = column_1;\n        column_1.paper = this.paper; // sometimes pattern is not drawn if is set with adapter without this.\n        // accessibility\n\n        if (this.itemsFocusable()) {\n          this.role = \"menu\";\n          column_1.role = \"menuitem\";\n          column_1.focusable = true;\n        } else {\n          this.role = \"list\";\n          column_1.role = \"listitem\";\n          column_1.focusable = false;\n        }\n\n        if (column_1.focusable) {\n          column_1.events.on(\"focus\", function (ev) {\n            column_1.readerTitle = _this.populateString(_this.itemReaderText, dataItem);\n          }, undefined, false);\n          column_1.events.on(\"blur\", function (ev) {\n            column_1.readerTitle = \"\";\n          }, undefined, false);\n        }\n\n        if (column_1.hoverable) {\n          column_1.events.on(\"over\", function (ev) {\n            column_1.readerTitle = _this.populateString(_this.itemReaderText, dataItem);\n          }, undefined, false);\n          column_1.events.on(\"out\", function (ev) {\n            column_1.readerTitle = \"\";\n          }, undefined, false);\n        }\n      } else {\n        column_1 = dataItem.column;\n      }\n\n      column_1.width = w;\n      column_1.height = h;\n      column_1.x = x;\n      column_1.y = y;\n      column_1.realX = l;\n      column_1.realY = t;\n      column_1.realWidth = r - l;\n      column_1.realHeight = b - t;\n      column_1.parent = this.columnsContainer;\n      column_1.virtualParent = this;\n      this.setColumnStates(column_1);\n\n      if (column_1.invalid) {\n        column_1.validate(); // validate as if it was used previously, it will flicker with previous dimensions\n      }\n\n      column_1.__disabled = false; //column.returnAfterTemp();\n\n      $iter.each(this.axisRanges.iterator(), function (axisRange) {\n        var rangeColumn = dataItem.rangesColumns.getKey(axisRange.uid);\n\n        if (!rangeColumn) {\n          rangeColumn = _this.columns.create(); //$object.forceCopyProperties(this.columns.template, rangeColumn, visualProperties);\n\n          $object.copyProperties(axisRange.contents, rangeColumn, visualProperties); // need this because 3d columns are not in the same container\n\n          dataItem.addSprite(rangeColumn);\n          dataItem.rangesColumns.setKey(axisRange.uid, rangeColumn);\n          rangeColumn.paper = _this.paper; // sometimes pattern is not drawn if is set with adapter without this.\t\t\t\t\t\n        }\n\n        rangeColumn.parent = axisRange.contents;\n        rangeColumn.width = w;\n        rangeColumn.height = h;\n        rangeColumn.x = x;\n        rangeColumn.y = y;\n\n        _this.setColumnStates(rangeColumn);\n\n        if (rangeColumn.invalid) {\n          rangeColumn.validate(); // validate as if it was used previously, it will flicker with previous dimensions\n        }\n\n        rangeColumn.__disabled = false; //rangeColumn.returnAfterTemp();\n      });\n    } else {\n      this.disableUnusedColumns(dataItem);\n    }\n\n    dataItem.itemWidth = w;\n    dataItem.itemHeight = h;\n  };\n  /**\r\n   * @ignore\r\n   */\n\n\n  ColumnSeries.prototype.disableUnusedColumns = function (dataItem) {\n    if (dataItem) {\n      if (dataItem.column) {\n        // otherwise might flicker when enabling\n        dataItem.column.width = 0;\n        dataItem.column.height = 0;\n        dataItem.column.__disabled = true;\n      }\n\n      $iter.each(this.axisRanges.iterator(), function (axisRange) {\n        var rangeColumn = dataItem.rangesColumns.getKey(axisRange.uid);\n\n        if (rangeColumn) {\n          // otherwise might flicker when enabling\n          rangeColumn.width = 0;\n          rangeColumn.height = 0;\n          rangeColumn.__disabled = true;\n        }\n      });\n    }\n  };\n  /**\r\n   * Apply different state/coloring to columns based on the change value.\r\n   *\r\n   * @param sprite  Sprite to apply state to\r\n   * @todo Do not apply accessibility to wicks of the candlesticks\r\n   */\n\n\n  ColumnSeries.prototype.setColumnStates = function (sprite) {\n    if (this._dropFromOpenState || this._dropFromPreviousState || this._riseFromOpenState || this._riseFromPreviousState) {\n      var dataItem = sprite.dataItem;\n\n      if (this.xAxis instanceof ValueAxis || this.yAxis instanceof ValueAxis) {\n        var open_1;\n        var value = void 0;\n        var change = void 0;\n\n        if (this.baseAxis == this.yAxis) {\n          if (this.xOpenField && this.xField && this.xAxis instanceof ValueAxis) {\n            open_1 = dataItem.getValue(this.xOpenField);\n            value = dataItem.getValue(this.xField);\n            change = dataItem.getValue(this.xAxis.axisFieldName + \"X\", \"previousChange\");\n          }\n        } else {\n          if (this.yOpenField && this.yField && this.yAxis instanceof ValueAxis) {\n            open_1 = dataItem.getValue(this.yOpenField);\n            value = dataItem.getValue(this.yField);\n            change = dataItem.getValue(this.yAxis.axisFieldName + \"Y\", \"previousChange\");\n          }\n        }\n\n        if (value < open_1) {\n          dataItem.droppedFromOpen = true;\n          sprite.defaultState.copyFrom(this._dropFromOpenState);\n          sprite.setState(this._dropFromOpenState, 0);\n        } else {\n          dataItem.droppedFromOpen = false;\n          sprite.defaultState.copyFrom(this._riseFromOpenState);\n          sprite.setState(this._riseFromOpenState, 0);\n        }\n\n        if (change < 0) {\n          dataItem.droppedFromPrevious = true;\n          sprite.defaultState.copyFrom(this._dropFromPreviousState);\n          sprite.setState(this._dropFromPreviousState, 0);\n        } else {\n          dataItem.droppedFromPrevious = false;\n          sprite.defaultState.copyFrom(this._riseFromPreviousState);\n          sprite.setState(this._riseFromPreviousState, 0);\n        }\n      }\n    }\n  };\n\n  Object.defineProperty(ColumnSeries.prototype, \"columns\", {\n    /**\r\n     * A list of column elements in the series.\r\n     *\r\n     * @return Columns\r\n     */\n    get: function () {\n      if (!this._columns) {\n        this._columns = new ListTemplate(this.createColumnTemplate());\n\n        this._disposers.push(new ListDisposer(this._columns));\n\n        this._disposers.push(this._columns.template);\n      }\n\n      return this._columns;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\r\n   * Creates and returns a column element to use as a template.\r\n   *\r\n   * @return Column template\r\n   */\n\n  ColumnSeries.prototype.createColumnTemplate = function () {\n    return new Column();\n  };\n\n  Object.defineProperty(ColumnSeries.prototype, \"clustered\", {\n    /**\r\n     * @return Clustered?\r\n     */\n    get: function () {\n      return this.getPropertyValue(\"clustered\");\n    },\n\n    /**\r\n     * Cluster this series columns?\r\n     *\r\n     * Setting to `false` will make columns overlap with other series.\r\n     *\r\n     * @default true\r\n     * @param value  Clustered?\r\n     */\n    set: function (value) {\n      this.setPropertyValue(\"clustered\", value, true);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(ColumnSeries.prototype, \"dropFromOpenState\", {\n    /**\r\n     * @return State\r\n     */\n    get: function () {\n      if (!this._dropFromOpenState) {\n        this._dropFromOpenState = this.states.create(\"dropFromOpenState\");\n      }\n\n      return this._dropFromOpenState;\n    },\n\n    /**\r\n     * A state to apply to a column when close value is lower than open value.\r\n     *\r\n     * Can be used to differentiate appearance based on value relations.\r\n     *\r\n     * NOTE: this will work only if at least one axis is [[ValueAxis]].\r\n     *\r\n     * @readonly You can modify state object, but can't overwrite it\r\n     * @param  value  State\r\n     */\n    set: function (value) {\n      this._dropFromOpenState = value;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(ColumnSeries.prototype, \"dropFromPreviousState\", {\n    /**\r\n     * @return State\r\n     */\n    get: function () {\n      if (!this._dropFromPreviousState) {\n        this._dropFromPreviousState = this.states.create(\"dropFromPreviousState\");\n      }\n\n      return this._dropFromPreviousState;\n    },\n\n    /**\r\n     * A state to apply to a column when its value is lower value of a previous\r\n     * column.\r\n     *\r\n     * Can be used to differentiate appearance based on value relations.\r\n     *\r\n     * @readonly You can modify state object, but can't overwrite it\r\n     * @param  value  State\r\n     */\n    set: function (value) {\n      this._dropFromPreviousState = value;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(ColumnSeries.prototype, \"riseFromOpenState\", {\n    /**\r\n     * @return State\r\n     */\n    get: function () {\n      if (!this._riseFromOpenState) {\n        this._riseFromOpenState = this.states.create(\"riseFromOpenState\");\n      }\n\n      return this._riseFromOpenState;\n    },\n\n    /**\r\n     * A state to apply to a column when close value is same or higher than open\r\n     * value.\r\n     *\r\n     * Can be used to differentiate appearance based on value relations.\r\n     *\r\n     * NOTE: this will work only if at least one axis is [[ValueAxis]].\r\n     *\r\n     * @readonly You can modify state object, but can't overwrite it\r\n     * @param  value  State\r\n     */\n    set: function (value) {\n      this._riseFromOpenState = value;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(ColumnSeries.prototype, \"riseFromPreviousState\", {\n    /**\r\n     * @return State\r\n     */\n    get: function () {\n      if (!this._riseFromPreviousState) {\n        this._riseFromPreviousState = this.states.create(\"riseFromPreviousState\");\n      }\n\n      return this._riseFromPreviousState;\n    },\n\n    /**\r\n     * A state to apply to a column when its value is same or higher than value\r\n     * of a previous column.\r\n     *\r\n     * Can be used to differentiate appearance based on value relations.\r\n     *\r\n     * @readonly You can modify state object, but can't overwrite it\r\n     * @param  value  State\r\n     */\n    set: function (value) {\n      this._riseFromPreviousState = value;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\r\n   * Updates value of the related legend item.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param dataItem  Data item\r\n   */\n\n  ColumnSeries.prototype.updateLegendValue = function (dataItem, notRange) {\n    var _this = this;\n\n    _super.prototype.updateLegendValue.call(this, dataItem, notRange);\n\n    if (this.legendDataItem) {\n      var marker = this.legendDataItem.marker;\n      var fromOpenState_1;\n      var fromPreviousState_1;\n\n      if (dataItem) {\n        if (dataItem.droppedFromOpen) {\n          fromOpenState_1 = this._dropFromOpenState;\n        } else {\n          fromOpenState_1 = this._riseFromOpenState;\n        }\n\n        if (dataItem.droppedFromPrevious) {\n          fromPreviousState_1 = this._dropFromPreviousState;\n        } else {\n          fromPreviousState_1 = this._riseFromPreviousState;\n        }\n      }\n\n      $iter.each(marker.children.iterator(), function (child) {\n        if (dataItem) {\n          child.setState(fromPreviousState_1);\n          child.setState(fromOpenState_1);\n        } else {\n          // todo: think what to do here, maybe apply above states based on totals?\n          child.setState(_this._riseFromPreviousState);\n          child.setState(_this._riseFromOpenState);\n        }\n      });\n    }\n  };\n  /**\r\n   * Creates elements in related legend container, that mimics the look of this\r\n   * Series.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param marker  Legend item container\r\n   */\n\n\n  ColumnSeries.prototype.createLegendMarker = function (marker) {\n    var w = marker.pixelWidth;\n    var h = marker.pixelHeight;\n    marker.removeChildren();\n    var column = marker.createChild(RoundedRectangle);\n    column.shouldClone = false;\n    $object.copyProperties(this, column, visualProperties);\n    column.copyFrom(this.columns.template);\n    column.padding(0, 0, 0, 0); // if columns will have padding (which is often), legend marker will be very narrow\n\n    column.width = w;\n    column.height = h;\n    var legendDataItem = marker.dataItem;\n    legendDataItem.color = this.fill;\n    legendDataItem.colorOrig = this.fill;\n  };\n  /**\r\n   * Copies all properties from another instance of [[ColumnSeries]].\r\n   *\r\n   * @param source  Source series\r\n   */\n\n\n  ColumnSeries.prototype.copyFrom = function (source) {\n    _super.prototype.copyFrom.call(this, source);\n\n    this.columns.template.copyFrom(source.columns.template);\n  };\n  /**\r\n  * returns bullet x location\r\n  * @ignore\r\n  */\n\n\n  ColumnSeries.prototype.getBulletLocationX = function (bullet, field) {\n    if (this.baseAxis == this.xAxis) {\n      var bulletLocationX = bullet.locationX;\n\n      if (!$type.isNumber(bulletLocationX)) {\n        bulletLocationX = 0.5;\n      }\n\n      var endLocation = this.getEndLocation(bullet.dataItem);\n      var startLocation = this.getStartLocation(bullet.dataItem);\n      return endLocation - (endLocation - startLocation) * bulletLocationX;\n    } else {\n      return _super.prototype.getBulletLocationX.call(this, bullet, field);\n    }\n  };\n  /**\r\n  * returns bullet y location\r\n  * @ignore\r\n  */\n\n\n  ColumnSeries.prototype.getBulletLocationY = function (bullet, field) {\n    if (this.baseAxis == this.yAxis) {\n      var bulletLocationY = bullet.locationY;\n\n      if (!$type.isNumber(bulletLocationY)) {\n        bulletLocationY = 0.5;\n      }\n\n      var endLocation = this.getEndLocation(bullet.dataItem);\n      var startLocation = this.getStartLocation(bullet.dataItem);\n      return endLocation - (endLocation - startLocation) * bulletLocationY;\n    } else {\n      return _super.prototype.getBulletLocationY.call(this, bullet, field);\n    }\n  };\n\n  ColumnSeries.prototype.getAdjustedXLocation = function (dataItem, field) {\n    if (this.baseAxis == this.xAxis) {\n      var bulletLocationX = 0.5;\n\n      if (dataItem) {\n        bulletLocationX = dataItem.locations[field];\n      }\n\n      if (!$type.isNumber(bulletLocationX)) {\n        bulletLocationX = 0.5;\n      }\n\n      return this._endLocation - (this._endLocation - this._startLocation) * bulletLocationX;\n    } else {\n      return _super.prototype.getAdjustedXLocation.call(this, dataItem, field);\n    }\n  };\n\n  ColumnSeries.prototype.getAdjustedYLocation = function (dataItem, field) {\n    if (this.baseAxis == this.yAxis) {\n      var bulletLocationY = 0.5;\n\n      if (dataItem) {\n        bulletLocationY = dataItem.locations[field];\n      }\n\n      if (!$type.isNumber(bulletLocationY)) {\n        bulletLocationY = 0.5;\n      }\n\n      return this._endLocation - (this._endLocation - this._startLocation) * bulletLocationY;\n    } else {\n      return _super.prototype.getAdjustedXLocation.call(this, dataItem, field);\n    }\n  };\n  /**\r\n   * @ignore Exclude from docs\r\n   */\n\n\n  ColumnSeries.prototype.fixVerticalCoordinate = function (coordinate) {\n    var paddingBottom = this.columns.template.pixelPaddingBottom;\n    var paddingTop = this.columns.template.pixelPaddingTop;\n    var minY = -paddingTop;\n    var maxY = this.yAxis.axisLength + paddingBottom;\n    return $math.fitToRange(coordinate, minY, maxY);\n  };\n  /**\r\n   * @ignore Exclude from docs\r\n   */\n\n\n  ColumnSeries.prototype.fixHorizontalCoordinate = function (coordinate) {\n    var paddingLeft = this.columns.template.pixelPaddingLeft;\n    var paddingRight = this.columns.template.pixelPaddingRight;\n    var minX = -paddingLeft;\n    var maxX = this.xAxis.axisLength + paddingRight;\n    return $math.fitToRange(coordinate, minX, maxX);\n  };\n  /**\r\n   * @ignore\r\n   */\n\n\n  ColumnSeries.prototype.disposeData = function () {\n    _super.prototype.disposeData.call(this);\n\n    this.columns.clear();\n  };\n\n  return ColumnSeries;\n}(XYSeries);\n\nexport { ColumnSeries };\n/**\r\n * Register class in system, so that it can be instantiated using its name from\r\n * anywhere.\r\n *\r\n * @ignore\r\n */\n\nregistry.registeredClasses[\"ColumnSeries\"] = ColumnSeries;\nregistry.registeredClasses[\"ColumnSeriesDataItem\"] = ColumnSeriesDataItem;","map":null,"metadata":{},"sourceType":"module"}