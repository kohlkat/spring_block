{"ast":null,"code":"/**\r\n * Map series module\r\n */\nimport * as tslib_1 from \"tslib\";\n/**\r\n * ============================================================================\r\n * IMPORTS\r\n * ============================================================================\r\n * @hidden\r\n */\n\nimport { Series, SeriesDataItem } from \"../series/Series\";\nimport { registry } from \"../../core/Registry\";\nimport * as $type from \"../../core/utils/Type\";\nimport * as $math from \"../../core/utils/Math\";\nimport * as d3geo from \"d3-geo\";\n/**\r\n * ============================================================================\r\n * DATA ITEM\r\n * ============================================================================\r\n * @hidden\r\n */\n\n/**\r\n * Defines a [[DataItem]] for [[MapSeries]].\r\n *\r\n * @see {@link DataItem}\r\n */\n\nvar MapSeriesDataItem =\n/** @class */\nfunction (_super) {\n  tslib_1.__extends(MapSeriesDataItem, _super);\n  /**\r\n   * Constructor\r\n   */\n\n\n  function MapSeriesDataItem() {\n    var _this = _super.call(this) || this;\n\n    _this.className = \"MapSeriesDataItem\";\n    _this.values.value = {};\n\n    _this.applyTheme();\n\n    return _this;\n  }\n\n  Object.defineProperty(MapSeriesDataItem.prototype, \"value\", {\n    /**\r\n     * @return Value\r\n     */\n    get: function () {\n      return this.values.value.value;\n    },\n\n    /**\r\n     * Numeric value of the data item.\r\n     *\r\n     * Value may be used in heat-map calculations.\r\n     *\r\n     * @param value  Value\r\n     */\n    set: function (value) {\n      this.setValue(\"value\", value);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(MapSeriesDataItem.prototype, \"zoomLevel\", {\n    /**\r\n     * @return Zoom level\r\n     */\n    get: function () {\n      return this.properties[\"zoomLevel\"];\n    },\n\n    /**\r\n     * When `zoomToMapObject()` is called the map will either calculate suitable\r\n     * zoom level itself or use object's `zoomLevel` if set.\r\n     *\r\n     * @param value  Zoom level\r\n     */\n    set: function (value) {\n      this.setProperty(\"zoomLevel\", value);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(MapSeriesDataItem.prototype, \"zoomGeoPoint\", {\n    /**\r\n     * @return Zoom geo point\r\n     */\n    get: function () {\n      return this.properties[\"zoomGeoPoint\"];\n    },\n\n    /**\r\n     * When `zoomToMapObject()` is called the map will either calculate suitable\r\n     * center position itself or use object's `zoomGeoPoint` if set.\r\n     *\r\n     * @param value  Zoom geo point\r\n     */\n    set: function (value) {\n      this.setProperty(\"zoomGeoPoint\", value);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(MapSeriesDataItem.prototype, \"east\", {\n    /**\r\n     * Longitude of the East-most point of the element.\r\n     */\n    get: function () {\n      return this._east;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(MapSeriesDataItem.prototype, \"west\", {\n    /**\r\n     * Longitude of the West-most point of the element.\r\n     */\n    get: function () {\n      return this._west;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(MapSeriesDataItem.prototype, \"south\", {\n    /**\r\n     * Latitude of the South-most point of the element.\r\n     */\n    get: function () {\n      return this._south;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(MapSeriesDataItem.prototype, \"north\", {\n    /**\r\n     * Latitude of the North-most point of the element.\r\n     */\n    get: function () {\n      return this._north;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\r\n   * Updates the item's bounding coordinates: coordinates of the East, West,\r\n   * North, and South-most points.\r\n   *\r\n   * @ignore Exclude from docs\r\n   */\n\n  MapSeriesDataItem.prototype.updateExtremes = function () {\n    var geometry = this.getFeature().geometry;\n\n    if (geometry) {\n      var bounds = d3geo.geoBounds(geometry);\n      var west = bounds[0][0];\n      var south = bounds[0][1];\n      var north = bounds[1][1];\n      var east = bounds[1][0];\n      var changed = false;\n\n      if (north != this.north) {\n        this._north = $math.round(north, 6);\n        changed = true;\n      }\n\n      if (south != this.south) {\n        this._south = $math.round(south, 6);\n        changed = true;\n      }\n\n      if (east != this.east) {\n        this._east = $math.round(east, 6);\n        changed = true;\n      }\n\n      if (west != this.west) {\n        this._west = $math.round(west, 6);\n        changed = true;\n      } // solves single russia prob\n\n\n      if (this._east < this._west) {\n        this._east = 180;\n        this._west = -180;\n      }\n\n      if (changed) {\n        this.component.invalidateDataItems();\n      }\n    }\n  };\n\n  MapSeriesDataItem.prototype.getFeature = function () {\n    return {};\n  };\n\n  return MapSeriesDataItem;\n}(SeriesDataItem);\n\nexport { MapSeriesDataItem };\n/**\r\n * ============================================================================\r\n * MAIN CLASS\r\n * ============================================================================\r\n * @hidden\r\n */\n\n/**\r\n * A base class for series of map objects.\r\n *\r\n * @see {@link IMapSeriesEvents} for a list of available Events\r\n * @see {@link IMapSeriesAdapters} for a list of available Adapters\r\n * @important\r\n */\n\nvar MapSeries =\n/** @class */\nfunction (_super) {\n  tslib_1.__extends(MapSeries, _super);\n  /**\r\n   * Constructor\r\n   */\n\n\n  function MapSeries() {\n    var _this = // Init\n    _super.call(this) || this;\n\n    _this.className = \"MapSeries\"; // Set defaults\n\n    _this.isMeasured = false;\n    _this.nonScalingStroke = true; // Set data fields\n\n    _this.dataFields.value = \"value\";\n    _this.ignoreBounds = false;\n\n    if (_this.tooltip) {\n      _this.tooltip.showInViewport = true;\n    } // Apply theme\n\n\n    _this.applyTheme();\n\n    return _this;\n  }\n  /**\r\n   * Returns a new/empty DataItem of the type appropriate for this object.\r\n   *\r\n   * @see {@link DataItem}\r\n   * @return Data Item\r\n   */\n\n\n  MapSeries.prototype.createDataItem = function () {\n    return new MapSeriesDataItem();\n  };\n  /**\r\n   * Checks whether object should be included in series.\r\n   *\r\n   * @param includes  A list of explicitly included ids\r\n   * @param excludes  A list of explicitly excluded ids\r\n   * @param id        Id of the object\r\n   * @return Include?\r\n   */\n\n\n  MapSeries.prototype.checkInclude = function (includes, excludes, id) {\n    if (includes) {\n      if (includes.length == 0) {\n        return false;\n      } else {\n        if (includes.indexOf(id) == -1) {\n          return false;\n        }\n      }\n    }\n\n    if (excludes && excludes.length > 0) {\n      if (excludes.indexOf(id) != -1) {\n        return false;\n      }\n    }\n\n    return true;\n  };\n\n  Object.defineProperty(MapSeries.prototype, \"useGeodata\", {\n    /**\r\n     * @return Use GeoJSON data?\r\n     */\n    get: function () {\n      return this.getPropertyValue(\"useGeodata\");\n    },\n\n    /**\r\n     * Should the map extract all the data about element from the GeoJSON?\r\n     *\r\n     * This is especially relevant for [[MapPolygonSeries]]. If not set to `true`\r\n     * polygon series will need to contain geographical data in itself in order\r\n     * to be drawn.\r\n     *\r\n     * If this is set to `true`, series will try to extract data for its objects\r\n     * from either chart-level `geodata` or from series' `geodata` which holds\r\n     * map infor in GeoJSON format.\r\n     *\r\n     * @default false\r\n     * @param value  Use GeoJSON data?\r\n     */\n    set: function (value) {\n      if (this.setPropertyValue(\"useGeodata\", value)) {\n        this.invalidateData();\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(MapSeries.prototype, \"include\", {\n    /**\r\n     * @return Included objects\r\n     */\n    get: function () {\n      return this.getPropertyValue(\"include\");\n    },\n\n    /**\r\n     * A list of object ids that should be explictly included in the series.\r\n     *\r\n     * If this is not set, the series will automatically include all of the\r\n     * objects, available in the GeoJSON map. (minus the ones listed in\r\n     * `exclude`)\r\n     *\r\n     * If you need to display only specific objects, use `include`. E.g.:\r\n     *\r\n     * `include = [\"FR\", \"ES\", \"DE\"];`\r\n     *\r\n     * The above will show only France, Spain, and Germany out of the whole map.\r\n     *\r\n     * @param value  Included objects\r\n     */\n    set: function (value) {\n      if (this.setPropertyValue(\"include\", value)) {\n        this.processIncExc();\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\r\n   * @ignore\r\n   */\n\n  MapSeries.prototype.processIncExc = function () {\n    //this.data = [];\n    this.invalidateData();\n  };\n\n  Object.defineProperty(MapSeries.prototype, \"ignoreBounds\", {\n    /**\r\n     * @return Ignore bounds?\r\n     */\n    get: function () {\n      return this.getPropertyValue(\"ignoreBounds\");\n    },\n\n    /**\r\n     * Should this series be included when calculating bounds of the map?\r\n     *\r\n     * This affects initial zoom as well as limits for zoom/pan.\r\n     *\r\n     * By default, `MapPolygonSeries` included (true), while `MapImageSeries` and\r\n     * `MapLineSeries` are not (`false`).\r\n     *\r\n     * @since 4.3.0\r\n     * @param  value  Ignore bounds?\r\n     */\n    set: function (value) {\n      if (this.setPropertyValue(\"ignoreBounds\", value)) {\n        if (this.chart) {\n          this.chart.updateExtremes();\n        }\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(MapSeries.prototype, \"exclude\", {\n    /**\r\n     * @return Excluded ids\r\n     */\n    get: function () {\n      return this.getPropertyValue(\"exclude\");\n    },\n\n    /**\r\n     * A list of object ids that should be excluded from the series.\r\n     *\r\n     * E.g. you want to include all of the areas from a GeoJSON map, except\r\n     * Antarctica.\r\n     *\r\n     * You'd leave `include` empty, and set `exclude = [\"AQ\"]`.\r\n     *\r\n     * @param value  Excluded ids\r\n     */\n    set: function (value) {\n      if (this.setPropertyValue(\"exclude\", value)) {\n        this.processIncExc();\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\r\n   * Decorates a newly added object.\r\n   *\r\n   * @param event [description]\r\n   */\n\n  MapSeries.prototype.handleObjectAdded = function (event) {\n    var mapObject = event.newValue;\n    mapObject.parent = this;\n    mapObject.series = this;\n    mapObject.strokeWidth = mapObject.strokeWidth;\n  };\n\n  Object.defineProperty(MapSeries.prototype, \"geodata\", {\n    /**\r\n     * @return GeoJSON data\r\n     */\n    get: function () {\n      return this._geodata;\n    },\n\n    /**\r\n     * Map data in GeoJSON format.\r\n     *\r\n     * The series supports the following GeoJSON objects: `Point`, `LineString`,\r\n     * `Polygon`, `MultiPoint`, `MultiLineString`, and `MultiPolygon`.\r\n     *\r\n     * @see {@link http://geojson.org/} Official GeoJSON format specification\r\n     * @param geoJSON GeoJSON data\r\n     */\n    set: function (geodata) {\n      if (geodata != this._geodata) {\n        this._geodata = geodata;\n\n        for (var i = this.data.length - 1; i >= 0; i--) {\n          if (this.data[i].madeFromGeoData == true) {\n            this.data.splice(i, 1);\n          }\n        }\n\n        this.disposeData();\n        this.invalidateData();\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(MapSeries.prototype, \"geodataSource\", {\n    /**\r\n     * Returns a [[DataSource]] specifically for loading Component's data.\r\n     *\r\n     * @return Data source\r\n     */\n    get: function () {\n      if (!this._dataSources[\"geodata\"]) {\n        this.getDataSource(\"geodata\");\n      }\n\n      return this._dataSources[\"geodata\"];\n    },\n\n    /**\r\n     * Sets a [[DataSource]] to be used for loading Component's data.\r\n     *\r\n     * @param value Data source\r\n     */\n    set: function (value) {\n      var _this = this;\n\n      if (this._dataSources[\"geodata\"]) {\n        this.removeDispose(this._dataSources[\"geodata\"]);\n      }\n\n      this._dataSources[\"geodata\"] = value;\n      this._dataSources[\"geodata\"].component = this;\n      this.events.on(\"inited\", function () {\n        _this.loadData(\"geodata\");\n      }, undefined, false);\n      this.setDataSourceEvents(value, \"geodata\");\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\r\n   * @ignore\r\n   */\n\n  MapSeries.prototype.getFeatures = function () {\n    return;\n  };\n  /**\r\n   * @ignore\r\n   */\n\n\n  MapSeries.prototype.validateDataItems = function () {\n    _super.prototype.validateDataItems.call(this);\n\n    this.updateExtremes();\n  };\n  /**\r\n   * @ignore\r\n   */\n\n\n  MapSeries.prototype.updateExtremes = function () {\n    var north;\n    var south;\n    var east;\n    var west;\n    this.dataItems.each(function (dataItem) {\n      if (dataItem.north > north || !$type.isNumber(north)) {\n        north = dataItem.north;\n      }\n\n      if (dataItem.south < south || !$type.isNumber(south)) {\n        south = dataItem.south;\n      }\n\n      if (dataItem.west < west || !$type.isNumber(west)) {\n        west = dataItem.west;\n      }\n\n      if (dataItem.east > east || !$type.isNumber(east)) {\n        east = dataItem.east;\n      }\n    });\n\n    if (this._mapObjects) {\n      this._mapObjects.each(function (mapObject) {\n        if (mapObject.north > north || !$type.isNumber(north)) {\n          north = mapObject.north;\n        }\n\n        if (mapObject.south < south || !$type.isNumber(south)) {\n          south = mapObject.south;\n        }\n\n        if (mapObject.west < west || !$type.isNumber(west)) {\n          west = mapObject.west;\n        }\n\n        if (mapObject.east > east || !$type.isNumber(east)) {\n          east = mapObject.east;\n        }\n      });\n    }\n\n    if (this.north != north || this.east != east || this.south != south || this.west != west) {\n      this._north = north;\n      this._east = east;\n      this._west = west;\n      this._south = south;\n      this.dispatch(\"geoBoundsChanged\");\n\n      if (!this.ignoreBounds) {\n        this.chart.updateExtremes();\n      }\n    }\n  };\n\n  Object.defineProperty(MapSeries.prototype, \"north\", {\n    /**\r\n     * @return Latitude\r\n     */\n    get: function () {\n      if ($type.isNumber(this._northDefined)) {\n        return this._northDefined;\n      }\n\n      return this._north;\n    },\n\n    /**\r\n     * North-most latitude of the series.\r\n     *\r\n     * By default, this holds auto-calculated latitude of the extremity.\r\n     *\r\n     * It can be overridden manually.\r\n     *\r\n     * @param  value  Latitude\r\n     */\n    set: function (value) {\n      this._northDefined = value;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(MapSeries.prototype, \"south\", {\n    /**\r\n     * @return Latitude\r\n     */\n    get: function () {\n      if ($type.isNumber(this._southDefined)) {\n        return this._southDefined;\n      }\n\n      return this._south;\n    },\n\n    /**\r\n     * South-most latitude of the series.\r\n     *\r\n     * By default, this holds auto-calculated latitude of the extremity.\r\n     *\r\n     * It can be overridden manually.\r\n     *\r\n     * @param  value  Latitude\r\n     */\n    set: function (value) {\n      this._southDefined = value;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(MapSeries.prototype, \"west\", {\n    /**\r\n     * @return Longitude\r\n     */\n    get: function () {\n      if ($type.isNumber(this._westDefined)) {\n        return this._westDefined;\n      }\n\n      return this._west;\n    },\n\n    /**\r\n     * West-most longitude of the series.\r\n     *\r\n     * By default, this holds auto-calculated longitude of the extremity.\r\n     *\r\n     * It can be overridden manually.\r\n     *\r\n     * @param  value  Longitude\r\n     */\n    set: function (value) {\n      this._westDefined = value;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(MapSeries.prototype, \"east\", {\n    /**\r\n     * @return Longitude\r\n     */\n    get: function () {\n      if ($type.isNumber(this._eastDefined)) {\n        return this._eastDefined;\n      }\n\n      return this._east;\n    },\n\n    /**\r\n     * East-most longitude of the series.\r\n     *\r\n     * By default, this holds auto-calculated longitude of the extremity.\r\n     *\r\n     * It can be overridden manually.\r\n     *\r\n     * @param  value  Longitude\r\n     */\n    set: function (value) {\n      this._eastDefined = value;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\r\n   * Processes JSON-based config before it is applied to the object.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param config  Config\r\n   */\n\n  MapSeries.prototype.processConfig = function (config) {\n    if ($type.hasValue(config[\"geodata\"]) && $type.isString(config[\"geodata\"])) {\n      var name_1 = config[\"geodata\"]; // Check if there's a map loaded by such name\n\n      if ($type.hasValue(window[\"am4geodata_\" + config[\"geodata\"]])) {\n        config[\"geodata\"] = window[\"am4geodata_\" + config[\"geodata\"]];\n      } // Nope. Let's try maybe we got JSON as string?\n      else {\n          try {\n            config[\"geodata\"] = JSON.parse(config[\"geodata\"]);\n          } catch (e) {\n            // No go again. Error out.\n            throw Error(\"MapChart error: Geodata `\" + name_1 + \"` is not loaded or is incorrect.\");\n          }\n        }\n    }\n\n    _super.prototype.processConfig.call(this, config);\n  };\n  /**\r\n   * Adds `projection` to \"as is\" fields.\r\n   *\r\n   * @param field  Field name\r\n   * @return Assign as is?\r\n   */\n\n\n  MapSeries.prototype.asIs = function (field) {\n    return field == \"geodata\" || _super.prototype.asIs.call(this, field);\n  };\n  /**\r\n   * @ignore\r\n   */\n\n\n  MapSeries.prototype.updateTooltipBounds = function () {\n    if (this.tooltip && this.topParent) {\n      this.tooltip.setBounds({\n        x: 10,\n        y: 10,\n        width: this.topParent.maxWidth - 20,\n        height: this.topParent.maxHeight - 20\n      });\n    }\n  };\n\n  return MapSeries;\n}(Series);\n\nexport { MapSeries };\n/**\r\n * Register class in system, so that it can be instantiated using its name from\r\n * anywhere.\r\n *\r\n * @ignore\r\n */\n\nregistry.registeredClasses[\"MapSeries\"] = MapSeries;\nregistry.registeredClasses[\"MapSeriesDataItem\"] = MapSeriesDataItem;","map":null,"metadata":{},"sourceType":"module"}