{"ast":null,"code":"/**\r\n * A collection of functions that deals with path calculations.\r\n */\nimport * as $math from \"../utils/Math\";\nimport * as $type from \"../utils/Type\";\nimport { getGhostPaper } from \"../rendering/Paper\";\nimport { options } from \"../Options\";\n/**\r\n * ============================================================================\r\n * PATH FUNCTIONS\r\n * ============================================================================\r\n * @hidden\r\n */\n\n/**\r\n * Returns an SVG path from a number of points.\r\n *\r\n * @ignore Exclude from docs\r\n * @param points  An array of line elbow points\r\n * @return SVG path\r\n */\n\nexport function polyline(points) {\n  var path = lineTo(points[0]);\n  var prevPoint = {\n    x: 0,\n    y: 0\n  };\n  var minStep = options.minPolylineStep;\n\n  if (!$type.isNumber(minStep)) {\n    minStep = 0.5;\n  }\n\n  for (var i = 0, len = points.length; i < len; i++) {\n    var point = points[i];\n\n    if ($math.getDistance(point, prevPoint) > minStep) {\n      path += lineTo(point);\n      prevPoint = point;\n    }\n  }\n\n  return path;\n}\n/**\r\n * Returns a starting point of an SVG path.\r\n *\r\n * @ignore Exclude from docs\r\n * @param point  Starting point\r\n * @return SVG path\r\n */\n\nexport function moveTo(point) {\n  return \" M\" + $math.round(point.x, 4) + \",\" + $math.round(point.y, 4) + \" \";\n}\n/**\r\n * Returns a line part of SVG path.\r\n *\r\n * @ignore Exclude from docs\r\n * @param point  SVG path\r\n * @return SVG path\r\n */\n\nexport function lineTo(point) {\n  return \" L\" + $math.round(point.x, 4) + \",\" + $math.round(point.y, 4) + \" \";\n}\n/**\r\n * Returns a quadratic curve part of an SVG path.\r\n *\r\n * @ignore Exclude from docs\r\n * @param point         End point of the curve\r\n * @param controlPoint  Control point\r\n * @return SVG path\r\n */\n\nexport function quadraticCurveTo(point, controlPoint) {\n  return \" Q\" + $math.round(controlPoint.x, 4) + \",\" + $math.round(controlPoint.y, 4) + \" \" + $math.round(point.x, 4) + \",\" + $math.round(point.y, 4);\n}\n/**\r\n * Returns a cubic curve part of an SVG path.\r\n *\r\n * @ignore Exclude from docs\r\n * @param point          End point of the curve\r\n * @param controlPointA  Control point A\r\n * @param controlPointB  Control point B\r\n * @return SVG path\r\n */\n\nexport function cubicCurveTo(point, controlPointA, controlPointB) {\n  return \" C\" + $math.round(controlPointA.x, 4) + \",\" + $math.round(controlPointA.y, 4) + \" \" + $math.round(controlPointB.x, 4) + \",\" + $math.round(controlPointB.y, 4) + \" \" + $math.round(point.x, 4) + \",\" + $math.round(point.y, 4);\n}\n/**\r\n * Returns a terminator for an SVG path.\r\n *\r\n * @ignore Exclude from docs\r\n * @return SVG path\r\n */\n\nexport function closePath() {\n  return \" Z\";\n}\n/**\r\n * Returns an arc part of an SVG path.\r\n *\r\n * @ignore Exclude from docs\r\n * @todo Better parameter descriptions\r\n * @param startAngle  Starting angle\r\n * @param arc         Arc\r\n * @param radius      Radius\r\n * @param radiusY     Vertical radius\r\n * @return SVG path\r\n */\n\nexport function arcTo(startAngle, arc, radius, radiusY) {\n  if (arc == 0) {\n    return \"\";\n  }\n\n  if (!$type.isNumber(radiusY)) {\n    radiusY = radius;\n  }\n\n  var path = \"\";\n  var c = \",\";\n  var segments = Math.ceil(Math.abs(arc) / 180);\n  var l = 1;\n\n  if (arc < 0) {\n    l = 0;\n  } // previous, as we use a not A\n\n\n  var pax = 0;\n  var pay = 0; // center\n\n  var cx = -$math.cos(startAngle) * radius;\n  var cy = -$math.sin(startAngle) * radiusY; // foir very short angles and big radius, solves artefacts\n\n  if (arc < 0.5 && radius > 3000) {\n    var endAngle = startAngle + arc;\n    var ax = $math.round($math.cos(endAngle) * radius, 4);\n    var ay = $math.round($math.sin(endAngle) * radiusY, 4);\n    return lineTo({\n      x: ax,\n      y: ay\n    });\n  }\n\n  for (var i = 0; i < segments; i++) {\n    var endAngle = startAngle + arc / segments * (i + 1);\n    var ax = $math.round($math.cos(endAngle) * radius + cx - pax, 4);\n    var ay = $math.round($math.sin(endAngle) * radiusY + cy - pay, 4);\n    path += \" a\" + radius + c + radiusY + c + 0 + c + 0 + c + l + c + ax + c + ay;\n    pax = ax;\n    pay = ay;\n  }\n\n  return path;\n}\n/**\r\n * Creates an arc path.\r\n *\r\n * @ignore Exclude from docs\r\n * @todo Description\r\n * @param startAngle         [description]\r\n * @param arc                [description]\r\n * @param radius             [description]\r\n * @param innerRadius        [description]\r\n * @param radiusY            [description]\r\n * @param cornerRadius       [description]\r\n * @param innerCornerRadius  [description]\r\n * @return SVG path\r\n */\n\nexport function arc(startAngle, arc, radius, innerRadius, radiusY, cornerRadius, innerCornerRadius) {\n  if (arc == 0) {\n    return \"\";\n  }\n\n  if (!$type.isNumber(innerRadius)) {\n    innerRadius = 0;\n  }\n\n  if (radius == 0 && innerRadius <= 0) {\n    return \"\";\n  }\n\n  if (radius < innerRadius) {\n    var temp = radius;\n    radius = innerRadius;\n    innerRadius = temp;\n\n    if ($type.isNumber(radiusY)) {\n      radiusY = radiusY / innerRadius * radius;\n    }\n  }\n\n  arc = $math.min(arc, 360);\n\n  if (arc == 360) {\n    cornerRadius = 0;\n    innerCornerRadius = 0;\n  }\n\n  var endAngle = startAngle + arc;\n  var crSin = $math.sin($math.min(arc, 45) / 2);\n  radiusY = $type.isNumber(radiusY) ? radiusY : radius;\n  cornerRadius = cornerRadius || 0;\n  innerCornerRadius = $type.isNumber(innerCornerRadius) ? innerCornerRadius : cornerRadius;\n  var innerRadiusY = radiusY / radius * innerRadius;\n  var cornerRadiusY = radiusY / radius * cornerRadius;\n  var innerCornerRadiusY = radiusY / radius * innerCornerRadius;\n  cornerRadius = $math.fitToRange(cornerRadius, 0, (radius - innerRadius) / 2);\n  cornerRadiusY = $math.fitToRange(cornerRadiusY, 0, (radiusY - innerRadiusY) / 2);\n  innerCornerRadius = $math.fitToRange(innerCornerRadius, 0, (radius - innerRadius) / 2);\n  innerCornerRadiusY = $math.fitToRange(innerCornerRadiusY, 0, (radiusY - innerRadiusY) / 2);\n  cornerRadius = $math.round($math.fitToRange(cornerRadius, 0, radius * crSin), 4);\n  cornerRadiusY = $math.round($math.fitToRange(cornerRadiusY, 0, radiusY * crSin), 4);\n  innerCornerRadius = $math.round($math.fitToRange(innerCornerRadius, 0, innerRadius * crSin), 4);\n  innerCornerRadiusY = $math.round($math.fitToRange(innerCornerRadiusY, 0, innerRadiusY * crSin), 4);\n  var crAngle = Math.asin(cornerRadius / radius / 2) * $math.DEGREES * 2;\n  var crAngleY = Math.asin(cornerRadiusY / radiusY / 2) * $math.DEGREES * 2;\n\n  if (innerRadius < innerCornerRadius) {\n    innerRadius = innerCornerRadius;\n  }\n\n  if (innerRadiusY < innerCornerRadiusY) {\n    innerRadiusY = innerCornerRadiusY;\n  }\n\n  var crInnerAngle = Math.asin(innerCornerRadius / innerRadius / 2) * $math.DEGREES * 2;\n  var crInnerAngleY = Math.asin(innerCornerRadiusY / innerRadiusY / 2) * $math.DEGREES * 2;\n\n  if (!$type.isNumber(crInnerAngle)) {\n    crInnerAngle = 0;\n  }\n\n  if (!$type.isNumber(crInnerAngleY)) {\n    crInnerAngleY = 0;\n  }\n\n  var middleAngle = startAngle + arc / 2;\n  var mPoint = {\n    x: $math.round($math.cos(middleAngle) * innerRadius, 4),\n    y: $math.sin(middleAngle) * innerRadiusY\n  };\n  var a0 = {\n    x: $math.cos(startAngle) * (innerRadius + innerCornerRadius),\n    y: $math.sin(startAngle) * (innerRadiusY + innerCornerRadiusY)\n  };\n  var b0 = {\n    x: $math.cos(startAngle) * (radius - cornerRadius),\n    y: $math.sin(startAngle) * (radiusY - cornerRadiusY)\n  };\n  var c0 = {\n    x: $math.cos(endAngle) * (radius - cornerRadius),\n    y: $math.sin(endAngle) * (radiusY - cornerRadiusY)\n  };\n  var d0 = {\n    x: $math.cos(endAngle) * (innerRadius + innerCornerRadius),\n    y: $math.sin(endAngle) * (innerRadiusY + innerCornerRadiusY)\n  };\n  var b1 = {\n    x: $math.cos(startAngle + crAngle) * radius,\n    y: $math.sin(startAngle + crAngleY) * radiusY\n  };\n  var d1 = {\n    x: $math.cos(endAngle - crInnerAngle) * innerRadius,\n    y: $math.sin(endAngle - crInnerAngleY) * innerRadiusY\n  }; // some magic math\n\n  innerCornerRadius += innerCornerRadius * $math.sin(crInnerAngle / 2);\n  innerCornerRadiusY += innerCornerRadiusY * $math.sin(crInnerAngleY / 2);\n\n  if (crInnerAngle > (endAngle - startAngle) / 2) {\n    d1 = mPoint;\n  }\n\n  var path = \"\"; // start from b if this is full circle\n\n  if (arc == 360) {\n    path = moveTo(b0);\n  } // otherwise start from a\n  else {\n      path = moveTo(a0);\n      path += lineTo(b0);\n      path += arcToPoint(b1, cornerRadius, cornerRadiusY, true);\n    } // draw arc\n\n\n  path += arcTo(startAngle + crAngle, arc - 2 * crAngle, radius, radiusY); // draw inner arc\n\n  if ($type.isNumber(innerRadius) && innerRadius != 0) {\n    // move to B if this is full circle\n    if (arc == 360 && cornerRadius == 0) {\n      path += moveTo(d0);\n    } // draw line otherwise\n    else {\n        path += arcToPoint(c0, cornerRadius, cornerRadiusY, true);\n        path += lineTo(d0);\n        path += arcToPoint(d1, innerCornerRadius, innerCornerRadiusY, true);\n      }\n\n    path += arcTo(endAngle - crInnerAngle, -(arc - 2 * crInnerAngle), innerRadius, innerRadiusY);\n\n    if (arc < 360 || cornerRadius > 0) {\n      path += arcToPoint(a0, innerCornerRadius, innerCornerRadiusY, true);\n    }\n\n    path += lineTo(a0);\n  } else {\n    path += arcToPoint(c0, cornerRadius, cornerRadiusY, true);\n\n    if (arc < 360) {\n      path += lineTo(a0);\n    }\n  }\n\n  return path;\n}\n/**\r\n * Creates a path for an arc to specific coordinate.\r\n *\r\n * @ignore Exclude from docs\r\n * @todo Description\r\n * @param point         Reference point\r\n * @param radius        Radius\r\n * @param radiusY       Vertical radius (for skewed arcs)\r\n * @param sweepFlag     [description]\r\n * @param largeArcFlag  [description]\r\n * @param xAxisRotation [description]\r\n * @return Arc path\r\n */\n\nexport function arcToPoint(point, radius, radiusY, sweepFlag, largeArcFlag, xAxisRotation) {\n  if (radius == 0) {\n    return \"\";\n  }\n\n  xAxisRotation = xAxisRotation || 0;\n  largeArcFlag = Boolean(largeArcFlag);\n  sweepFlag = Boolean(sweepFlag);\n  var c = \",\";\n  var sweepFlagValue = +sweepFlag; // converts to 1 or 0\n\n  var largeArcFlagValue = +largeArcFlag; // converts to 1 or 0\n\n  return \" A\" + radius + c + radiusY + c + xAxisRotation + c + largeArcFlagValue + c + sweepFlagValue + c + $math.round(point.x, 4) + c + $math.round(point.y, 4);\n}\n/**\r\n * Creates a new rectangle.\r\n *\r\n * @ignore Exclude from docs\r\n * @param width   Width (px)\r\n * @param height  Height (px)\r\n * @param x       X position\r\n * @param y       Y position\r\n * @return Rectangle\r\n */\n\nexport function rectangle(width, height, x, y) {\n  if (!$type.isNumber(x)) {\n    x = 0;\n  }\n\n  if (!$type.isNumber(y)) {\n    y = 0;\n  }\n\n  return moveTo({\n    x: x,\n    y: y\n  }) + lineTo({\n    x: x + width,\n    y: y\n  }) + lineTo({\n    x: x + width,\n    y: y + height\n  }) + lineTo({\n    x: x,\n    y: y + height\n  }) + closePath();\n}\n/**\r\n * Converts a rectangle to an SVG path.\r\n *\r\n * @ignore Exclude from docs\r\n * @param rect  Rectangle\r\n * @param ccw   Counter-clockwise?\r\n * @return SVG path\r\n */\n\nexport function rectToPath(rect, ccw) {\n  var c = \",\";\n  var L = \" L\";\n\n  if (ccw) {\n    return \"M\" + rect.x + c + rect.y + L + rect.x + c + (rect.y + rect.height) + L + (rect.x + rect.width) + c + (rect.y + rect.height) + L + (rect.x + rect.width) + c + rect.y + L + rect.x + c + rect.y;\n  } else {\n    return \"M\" + rect.x + c + rect.y + L + (rect.x + rect.width) + c + rect.y + L + (rect.x + rect.width) + c + (rect.y + rect.height) + L + rect.x + c + (rect.y + rect.height) + L + rect.x + c + rect.y;\n  }\n}\n/**\r\n * Converts SVG path to array of points.\r\n *\r\n * Note, this is experimental feature based on method which is deprecated\r\n * on some browsers and some browsers do not support it at all.\r\n *\r\n * You can save the output of this function, but not rely on it completely.\r\n */\n\nexport function pathToPoints(path, pointCount) {\n  var paper = getGhostPaper();\n  var svgPath = paper.add(\"path\").node;\n  svgPath.setAttribute(\"d\", path);\n\n  if (svgPath.getPointAtLength && svgPath.getTotalLength) {\n    var length_1 = svgPath.getTotalLength();\n    var toPoints = [];\n\n    for (var i = 0; i < pointCount; i++) {\n      var point = svgPath.getPointAtLength(i / pointCount * length_1);\n      toPoints.push({\n        x: point.x,\n        y: point.y\n      });\n    }\n\n    return toPoints;\n  }\n\n  svgPath.remove();\n}\nexport function spiralPoints(cx, cy, radius, radiusY, innerRadius, step, radiusStep, startAngle, endAngle) {\n  if (!$type.isNumber(startAngle)) {\n    startAngle = 0;\n  }\n\n  if (!$type.isNumber(startAngle)) {\n    endAngle = startAngle;\n  }\n\n  var r = innerRadius + 0.01;\n  var angle = startAngle * $math.RADIANS;\n  var points = [];\n\n  while (r < radius + radiusStep) {\n    var stepSize = step;\n\n    if (stepSize / 2 > r) {\n      stepSize = 2 * r;\n    }\n\n    angle += 2 * Math.asin(stepSize / 2 / r);\n\n    if (angle * $math.DEGREES > endAngle + (radius - innerRadius) / radiusStep * 360) {\n      break;\n    }\n\n    var degrees = angle * $math.DEGREES;\n    var point = {\n      x: cx + r * Math.cos(angle),\n      y: cy + r * radiusY / radius * Math.sin(angle)\n    };\n    points.push(point);\n    r = innerRadius + degrees / 360 * radiusStep;\n  }\n\n  points.shift();\n  return points;\n}\nexport function pointsToPath(points) {\n  if (!points || points.length == 0) {\n    return \"\";\n  }\n\n  var path = moveTo(points[0]);\n\n  if (points && points.length > 0) {\n    for (var i = 1; i < points.length; i++) {\n      path += lineTo(points[i]);\n    }\n  }\n\n  return path;\n}","map":null,"metadata":{},"sourceType":"module"}