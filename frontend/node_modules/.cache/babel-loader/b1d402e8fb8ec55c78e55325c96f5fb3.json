{"ast":null,"code":"/**\r\n * Map line module\r\n */\nimport * as tslib_1 from \"tslib\";\n/**\r\n * ============================================================================\r\n * IMPORTS\r\n * ============================================================================\r\n * @hidden\r\n */\n\nimport { MapObject } from \"./MapObject\";\nimport { MapLineObject } from \"./MapLineObject\";\nimport { MapImage } from \"./MapImage\";\nimport { MapImageSeries } from \"./MapImageSeries\";\nimport { Triangle } from \"../../core/elements/Triangle\";\nimport { ListTemplate, ListDisposer } from \"../../core/utils/List\";\nimport { Polyline } from \"../../core/elements/Polyline\";\nimport { registry } from \"../../core/Registry\";\nimport { color } from \"../../core/utils/Color\";\nimport { InterfaceColorSet } from \"../../core/utils/InterfaceColorSet\";\nimport { percent, Percent } from \"../../core/utils/Percent\";\nimport * as $type from \"../../core/utils/Type\";\nimport * as $iter from \"../../core/utils/Iterator\";\nimport * as $geo from \"./Geo\";\nimport * as $mapUtils from \"./MapUtils\";\n/**\r\n * ============================================================================\r\n * MAIN CLASS\r\n * ============================================================================\r\n * @hidden\r\n */\n\n/**\r\n * Used to draw a line on the map.\r\n *\r\n * @see {@link IMapLineEvents} for a list of available events\r\n * @see {@link IMapLineAdapters} for a list of available Adapters\r\n */\n\nvar MapLine =\n/** @class */\nfunction (_super) {\n  tslib_1.__extends(MapLine, _super);\n  /**\r\n   * Constructor\r\n   */\n\n\n  function MapLine() {\n    var _this = // Init\n    _super.call(this) || this;\n    /**\r\n     * A list of event disposers for images.\r\n     */\n\n\n    _this._imageListeners = {};\n    _this.className = \"MapLine\";\n\n    _this.createLine();\n\n    _this.line.stroke = color();\n    _this.line.parent = _this;\n    _this.strokeOpacity = 1;\n    var interfaceColors = new InterfaceColorSet();\n    _this.stroke = interfaceColors.getFor(\"grid\");\n    _this.shortestDistance = true; // Apply theme\n\n    _this.applyTheme();\n\n    return _this;\n  }\n  /**\r\n   * @ignore\r\n   */\n\n\n  MapLine.prototype.createLine = function () {\n    this.line = new Polyline();\n  };\n  /**\r\n   * Converts a position within the line (0-1) to a physical point\r\n   * coordinates.\r\n   *\r\n   * 0 indicates start of the line, 0.5 - middle, while 1 indicates the end.\r\n   *\r\n   * @param position  Position (0-1)\r\n   * @return Coordinates\r\n   */\n\n\n  MapLine.prototype.positionToPoint = function (position) {\n    if (this.shortestDistance) {\n      return this.series.chart.projection.positionToPoint(this.multiGeoLine, position);\n    } else {\n      if (this.line) {\n        return this.line.positionToPoint(position);\n      }\n    }\n\n    return {\n      x: 0,\n      y: 0,\n      angle: 0\n    };\n  };\n\n  Object.defineProperty(MapLine.prototype, \"multiGeoLine\", {\n    /**\r\n     * @return Coordinates\r\n     */\n    get: function () {\n      var multiGeoLine = this.getPropertyValue(\"multiGeoLine\");\n\n      if (!multiGeoLine && this.dataItem && this.dataItem.multiGeoLine) {\n        multiGeoLine = this.dataItem.multiGeoLine;\n      }\n\n      return multiGeoLine;\n    },\n\n    /**\r\n     * A collection of X/Y coordinates for a multi-segment line. E.g.:\r\n     *\r\n     * ```JSON\r\n     * [\r\n     *   // Segment 1\r\n     *   [\r\n     *     { longitude: 3.121, latitude: 0.58 },\r\n     *     { longitude: -5.199, latitude: 21.223 }\r\n     *   ],\r\n     *\r\n     *   // Segment 2\r\n     *   [\r\n     *     { longitude: -5.199, latitude: 21.223 },\r\n     *     { longitude: -12.9, latitude: 25.85 }\r\n     *   ]\r\n     * ]\r\n     * ```\r\n     *\r\n     * @see {@link https://tools.ietf.org/html/rfc7946#section-3.1.5} GeoJSON MultiLineString reference\r\n     * @param multiGeoLine  Coordinates\r\n     */\n    set: function (multiGeoLine) {\n      if (multiGeoLine && multiGeoLine.length > 0) {\n        this.setPropertyValue(\"multiGeoLine\", $geo.normalizeMultiline(multiGeoLine), true);\n        var multiLine = $mapUtils.multiGeoLineToMultiLine(multiGeoLine);\n        this.setPropertyValue(\"multiLine\", multiLine);\n        this.updateExtremes();\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(MapLine.prototype, \"multiLine\", {\n    /**\r\n     * @return Coordinates\r\n     */\n    get: function () {\n      var multiLine = this.getPropertyValue(\"multiLine\");\n\n      if (!multiLine && this.dataItem && this.dataItem.multiLine) {\n        multiLine = this.dataItem.multiLine;\n      }\n\n      return multiLine;\n    },\n\n    /**\r\n     * A collection of X/Y coordinates for a multi-segment line. E.g.:\r\n     *\r\n     * ```JSON\r\n     * [\r\n     *   // Segment 1\r\n     *   [\r\n     *     [ 100, 150 ],\r\n     *     [ 120, 200 ]\r\n     *   ],\r\n     *\r\n     *   // Segment 2\r\n     *   [\r\n     *     [ 120, 200 ],\r\n     *     [ 150, 100 ]\r\n     *   ]\r\n     * ]\r\n     * ```\r\n     *\r\n     * @param multiLine  Coordinates\r\n     */\n    set: function (multiLine) {\n      this.setPropertyValue(\"multiLine\", multiLine);\n      this.multiGeoLine = $mapUtils.multiLineToGeo(multiLine);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(MapLine.prototype, \"imagesToConnect\", {\n    /**\r\n     * @return {MapImages[]}\r\n     */\n    get: function () {\n      return this.getPropertyValue(\"imagesToConnect\");\n    },\n\n    /**\r\n     * Instead of setting longitudes/latitudes you can set an array of images\r\n     * which will be connected by the line.\r\n     *\r\n     * Parameter is an array that can hold string `id`'s to of the images, or\r\n     * references to actual [[MapImage]] objects.\r\n     *\r\n     * @param images  Images\r\n     */\n    set: function (images) {\n      this.setPropertyValue(\"imagesToConnect\", images, true);\n      this.handleImagesToConnect();\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  MapLine.prototype.handleImagesToConnect = function () {\n    var _this = this;\n\n    if (this.imagesToConnect) {\n      var segment = [];\n      var multiGeoLine = [segment];\n\n      var _loop_1 = function (image) {\n        if ($type.isString(image)) {\n          var chart = this_1.series.chart;\n\n          if (chart) {\n            chart.series.each(function (series) {\n              if (series instanceof MapImageSeries) {\n                var img = series.getImageById(image);\n\n                if (img) {\n                  image = img;\n                }\n              }\n            });\n          }\n        }\n\n        if (image instanceof MapImage) {\n          segment.push({\n            longitude: image.longitude,\n            latitude: image.latitude\n          });\n\n          if (!this_1._imageListeners[image.uid]) {\n            var disposer = image.events.on(\"propertychanged\", function (event) {\n              if (event.property == \"longitude\" || event.property == \"latitude\") {\n                _this.handleImagesToConnect();\n\n                _this.invalidate();\n              }\n            }, this_1, false);\n            this_1._imageListeners[image.uid] = disposer;\n\n            this_1._disposers.push(disposer);\n          }\n        }\n      };\n\n      var this_1 = this;\n\n      try {\n        for (var _a = tslib_1.__values(this.imagesToConnect), _b = _a.next(); !_b.done; _b = _a.next()) {\n          var image = _b.value;\n\n          _loop_1(image);\n        }\n      } catch (e_1_1) {\n        e_1 = {\n          error: e_1_1\n        };\n      } finally {\n        try {\n          if (_b && !_b.done && (_c = _a.return)) _c.call(_a);\n        } finally {\n          if (e_1) throw e_1.error;\n        }\n      }\n\n      this.multiGeoLine = multiGeoLine;\n    }\n\n    var e_1, _c;\n  };\n  /**\r\n   * (Re)validates the line, effectively forcing it to redraw.\r\n   *\r\n   * @ignore Exclude from docs\r\n   */\n\n\n  MapLine.prototype.validate = function () {\n    var chart = this.series.chart;\n\n    if (this.multiLine) {\n      if (!this.shortestDistance) {\n        var convertedPoints = [];\n\n        for (var i = 0, len = this.multiLine.length; i < len; i++) {\n          var segment = this.multiLine[i];\n          var convertedSegmentPoints = [];\n\n          for (var s = 0, slen = segment.length; s < slen; s++) {\n            var geoPoint = segment[s];\n            var point = this.series.chart.projection.convert({\n              longitude: geoPoint[0],\n              latitude: geoPoint[1]\n            });\n            convertedSegmentPoints.push(point);\n          }\n\n          convertedPoints.push(convertedSegmentPoints);\n        }\n\n        this.line.segments = convertedPoints;\n      } else {\n        chart.projection.d3Projection.precision(0.1);\n        this.line.path = chart.projection.d3Path(this.getFeature());\n      }\n\n      if (this._arrow) {\n        this._arrow.validatePosition();\n      }\n\n      $iter.each(this.lineObjects.iterator(), function (x) {\n        x.validatePosition();\n      });\n      this.handleGlobalScale();\n    } else if (this.imagesToConnect) {\n      this.handleImagesToConnect();\n    }\n\n    _super.prototype.validate.call(this);\n  };\n  /**\r\n   * @ignore\r\n   */\n\n\n  MapLine.prototype.getFeature = function () {\n    if (this.multiLine && this.multiLine.length > 0 && this.multiLine[0] && this.multiLine[0].length > 0) {\n      return {\n        \"type\": \"Feature\",\n        geometry: {\n          type: \"MultiLineString\",\n          coordinates: this.multiLine\n        }\n      };\n    }\n  };\n  /**\r\n   * @ignore Exclude from docs\r\n   */\n\n\n  MapLine.prototype.measureElement = function () {// Overriding, just to avoid extra measure\n  };\n\n  Object.defineProperty(MapLine.prototype, \"shortestDistance\", {\n    /**\r\n     * @return Real path?\r\n     */\n    get: function () {\n      return this.getPropertyValue(\"shortestDistance\");\n    },\n\n    /**\r\n     * The line should take the shortest path over the globe.\r\n     *\r\n     * Enabling this will make the line look differently in different\r\n     * projections. Only `MapLine` supports this setting, `MapArc` and\r\n     * `MapSplice` don't.\r\n     *\r\n     * @default false\r\n     * @param value  Real path?\r\n     */\n    set: function (value) {\n      this.setPropertyValue(\"shortestDistance\", value, true);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(MapLine.prototype, \"lineObjects\", {\n    /**\r\n     * List of separate line objects the line consists of.\r\n     *\r\n     * @readonly\r\n     * @return List of line objects\r\n     */\n    get: function () {\n      if (!this._lineObjects) {\n        this._lineObjects = new ListTemplate(new MapLineObject());\n\n        this._lineObjects.events.on(\"inserted\", this.handleLineObjectAdded, this, false);\n\n        this._disposers.push(new ListDisposer(this._lineObjects));\n\n        this._disposers.push(this._lineObjects.template);\n      }\n\n      return this._lineObjects;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\r\n   * Decorate a [[LineObject]] when it is added to the line.\r\n   *\r\n   * @param event  Event\r\n   */\n\n  MapLine.prototype.handleLineObjectAdded = function (event) {\n    var mapLineObject = event.newValue;\n    mapLineObject.mapLine = this;\n    mapLineObject.shouldClone = false;\n    mapLineObject.parent = this;\n  };\n\n  Object.defineProperty(MapLine.prototype, \"arrow\", {\n    /**\r\n     * @return Arrow element\r\n     */\n    get: function () {\n      if (!this._arrow) {\n        var arrow = this.createChild(MapLineObject);\n        arrow.shouldClone = false;\n        arrow.width = 8;\n        arrow.height = 10;\n        arrow.mapLine = this;\n        arrow.position = 0.5;\n        var triangle = arrow.createChild(Triangle); //triangle.shouldClone = false;\n\n        triangle.fillOpacity = 1;\n        triangle.width = percent(100);\n        triangle.height = percent(100);\n        triangle.rotation = 90;\n        triangle.horizontalCenter = \"middle\";\n        triangle.verticalCenter = \"middle\";\n        this._arrow = arrow;\n      }\n\n      return this._arrow;\n    },\n\n    /**\r\n     * A [[MapLineObject]] to use as an option arrowhead on the line.\r\n     *\r\n     * Just accessing this property will create a default arrowhead on the line\r\n     * automatically.\r\n     *\r\n     * @param arrow  Arrow element\r\n     */\n    set: function (arrow) {\n      this._arrow = arrow;\n      arrow.mapLine = this;\n      arrow.parent = this;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\r\n   * Copies line properties and other attributes, like arrow, from another\r\n   * instance of [[MapLine]].\r\n   *\r\n   * @param source  Source map line\r\n   */\n\n  MapLine.prototype.copyFrom = function (source) {\n    _super.prototype.copyFrom.call(this, source);\n\n    this.line.copyFrom(source.line);\n    this.lineObjects.copyFrom(source.lineObjects);\n\n    if (source._arrow) {\n      this.arrow = source.arrow.clone();\n    }\n  };\n\n  Object.defineProperty(MapLine.prototype, \"latitude\", {\n    /**\r\n     * Latitude of the line center.\r\n     *\r\n     * @readonly\r\n     * @return Latitude\r\n     */\n    get: function () {\n      return this.north + (this.south - this.north) / 2;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(MapLine.prototype, \"longitude\", {\n    /**\r\n     * Longitude of the line center.\r\n     *\r\n     * @readonly\r\n     * @return Latitude\r\n     */\n    get: function () {\n      return this.east + (this.west - this.east) / 2;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\r\n   * X coordinate for the slice tooltip.\r\n   *\r\n   * @ignore\r\n   * @return X\r\n   */\n\n  MapLine.prototype.getTooltipX = function () {\n    var x = this.tooltipX;\n\n    if (!(x instanceof Percent)) {\n      x = percent(50);\n    }\n\n    return this.positionToPoint(x.value).x;\n  };\n  /**\r\n   * Y coordinate for the slice tooltip.\r\n   *\r\n   * @ignore\r\n   * @return Y\r\n   */\n\n\n  MapLine.prototype.getTooltipY = function () {\n    var y = this.tooltipY;\n\n    if (!(y instanceof Percent)) {\n      y = percent(50);\n    }\n\n    return this.positionToPoint(y.value).y;\n  };\n\n  return MapLine;\n}(MapObject);\n\nexport { MapLine };\n/**\r\n * Register class in system, so that it can be instantiated using its name from\r\n * anywhere.\r\n *\r\n * @ignore\r\n */\n\nregistry.registeredClasses[\"MapLine\"] = MapLine;","map":null,"metadata":{},"sourceType":"module"}