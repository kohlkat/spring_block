{"ast":null,"code":"/**\r\n * [[Chart]] class provides base functionality for all chart types to inherit.\r\n */\nimport * as tslib_1 from \"tslib\";\n/**\r\n * ============================================================================\r\n * IMPORTS\r\n * ============================================================================\r\n * @hidden\r\n */\n\nimport { registry } from \"../core/Registry\";\nimport { Component } from \"../core/Component\";\nimport { MutableValueDisposer } from \"../core/utils/Disposer\";\nimport { ListTemplate, ListDisposer } from \"../core/utils/List\";\nimport { Container } from \"../core/Container\";\nimport { Label } from \"../core/elements/Label\";\nimport { Grip } from \"../core/elements/Grip\";\nimport { DataItem } from \"../core/DataItem\";\nimport { percent } from \"../core/utils/Percent\";\nimport * as $iter from \"../core/utils/Iterator\";\nimport * as $type from \"../core/utils/Type\";\nimport { defaultRules, ResponsiveBreakpoints } from \"../core/utils/Responsive\";\n/**\r\n * ============================================================================\r\n * DATA ITEM\r\n * ============================================================================\r\n * @hidden\r\n */\n\n/**\r\n * Defines a [[DataItem]] for [[Chart]].\r\n *\r\n * @see {@link DataItem}\r\n */\n\nvar ChartDataItem =\n/** @class */\nfunction (_super) {\n  tslib_1.__extends(ChartDataItem, _super);\n  /**\r\n   * Constructor\r\n   */\n\n\n  function ChartDataItem() {\n    var _this = _super.call(this) || this;\n\n    _this.className = \"ChartDataItem\";\n\n    _this.applyTheme();\n\n    return _this;\n  }\n\n  return ChartDataItem;\n}(DataItem);\n\nexport { ChartDataItem };\n/**\r\n * ============================================================================\r\n * MAIN CLASS\r\n * ============================================================================\r\n * @hidden\r\n */\n\n/**\r\n * A base class for all Charts.\r\n *\r\n * @see {@link IChartEvents} for a list of available Events\r\n * @see {@link IChartAdapters} for a list of available Adapters\r\n */\n\nvar Chart =\n/** @class */\nfunction (_super) {\n  tslib_1.__extends(Chart, _super);\n  /**\r\n   * Constructor\r\n   */\n\n\n  function Chart() {\n    var _this = // Init\n    _super.call(this) || this;\n    /**\r\n     * A reference to chart's [[Legend]].\r\n     * @ignore\r\n     */\n\n\n    _this._legend = new MutableValueDisposer();\n\n    if (_this.constructor === Chart) {\n      throw new Error(\"'Chart' cannot be instantiated directly. Please use a specific chart type.\");\n    }\n\n    _this.className = \"Chart\"; // Create a list of titles\n\n    var template = new Label();\n    _this.titles = new ListTemplate(template);\n\n    _this._disposers.push(new ListDisposer(_this.titles));\n\n    _this._disposers.push(template); // Chart component is also a container. it holds _chartAndLegendCont and titles\n\n\n    _this.width = percent(100);\n    _this.height = percent(100);\n    _this.layout = \"vertical\"; // Chart and legend\n\n    var chartAndLegendContainer = _this.createChild(Container);\n\n    chartAndLegendContainer.shouldClone = false;\n    chartAndLegendContainer.layout = \"vertical\";\n    chartAndLegendContainer.width = percent(100);\n    chartAndLegendContainer.height = percent(100);\n    _this.chartAndLegendContainer = chartAndLegendContainer; // Chart container holds all the elements of a chart, extept titles and legend\n\n    var chartContainer = chartAndLegendContainer.createChild(Container);\n    chartContainer.shouldClone = false;\n    chartContainer.width = percent(100);\n    chartContainer.height = percent(100);\n    _this.chartContainer = chartContainer;\n    _this.showOnInit = true;\n\n    _this._disposers.push(_this._legend); // Add title list events to apply certain formatting options and to make\n    // the chart reference them as accessible screen reader labels\n\n\n    _this.titles.events.on(\"inserted\", function (label) {\n      _this.processTitle(label);\n\n      _this.updateReaderTitleReferences();\n    }, _this, false);\n\n    _this.titles.events.on(\"removed\", function (label) {\n      _this.updateReaderTitleReferences();\n    }, _this, false); // Accessibility\n    // It seems we can't set focusable on the whole chart because it seems to\n    // mess up the whole focus event system - getting a focus on an inside\n    // object also trigger focus on parent\n    //this.focusable = true;\n\n\n    _this.role = \"widget\";\n    _this.defaultState.transitionDuration = 1; // Apply theme\n\n    _this.applyTheme();\n\n    return _this;\n  }\n  /**\r\n   * Sets defaults that instantiate some objects that rely on parent, so they\r\n   * cannot be set in constructor.\r\n   */\n\n\n  Chart.prototype.applyInternalDefaults = function () {\n    _super.prototype.applyInternalDefaults.call(this);\n\n    if (!$type.hasValue(this.readerTitle)) {\n      this.readerTitle = this.language.translate(\"Chart\");\n    }\n  };\n  /**\r\n   * Initiates drawing of the chart.\r\n   *\r\n   * @ignore Exclude from docs\r\n   */\n\n\n  Chart.prototype.draw = function () {\n    this.fixLayout();\n\n    _super.prototype.draw.call(this);\n  };\n  /**\r\n   * Updates legend's hierarchy based on the position.\r\n   */\n\n\n  Chart.prototype.fixLayout = function () {\n    var legend = this.legend;\n\n    if (legend) {\n      var chartAndLegendContainer = this.chartAndLegendContainer;\n      var chartContainer = this.chartContainer;\n      chartContainer.x = undefined;\n      chartContainer.y = undefined;\n      legend.x = undefined;\n      legend.y = undefined;\n\n      switch (legend.position) {\n        case \"left\":\n          chartAndLegendContainer.layout = \"horizontal\";\n\n          if (!$type.isNumber(legend.width)) {\n            legend.width = 200;\n          } //legend.maxWidth = legend.width;\n\n\n          legend.toBack();\n          break;\n\n        case \"right\":\n          chartAndLegendContainer.layout = \"horizontal\";\n\n          if (!$type.isNumber(legend.width)) {\n            legend.width = 200;\n          } //legend.maxWidth = legend.width;\n\n\n          legend.toFront();\n          break;\n\n        case \"top\":\n          chartAndLegendContainer.layout = \"vertical\";\n          legend.maxWidth = undefined;\n          legend.width = percent(100);\n          legend.toBack();\n          break;\n\n        case \"bottom\":\n          chartAndLegendContainer.layout = \"vertical\";\n          legend.maxWidth = undefined;\n          legend.width = percent(100);\n          legend.toFront();\n      }\n    }\n  };\n  /**\r\n   * Setups the legend to use the chart's data.\r\n   */\n\n\n  Chart.prototype.feedLegend = function () {// Nothing here. This method is provided only as a \"placeholder\" for\n    // extending classes to override\n  };\n  /**\r\n   * Adds a new title to the chart when it is inserted into chart's titles\r\n   * list.\r\n   * @param event  An event object which is triggered when inserting into titles list\r\n   * @return Label object\r\n   */\n\n\n  Chart.prototype.processTitle = function (event) {\n    var title = event.newValue;\n    title.parent = this;\n    title.toBack();\n    title.shouldClone = false;\n    title.align = \"center\"; // Need to explicitly apply the `id` attribute so it can be referenced by\n    // `aria-labelledby`\n\n    title.uidAttr();\n    return title;\n  };\n  /**\r\n   * Checks if chart has any title elements. If it does, we will use them in an\r\n   * `aria-labelledby` attribute so that screen readers can use them to properly\r\n   * describe the chart when it is focused or hovered.\r\n   *\r\n   * @ignore Exclude from docs\r\n   */\n\n\n  Chart.prototype.updateReaderTitleReferences = function () {\n    if (this.titles.length) {\n      var titleIds_1 = [];\n      $iter.each(this.titles.iterator(), function (title) {\n        titleIds_1.push(title.uid);\n      });\n      this.setSVGAttribute({\n        \"aria-labelledby\": titleIds_1.join(\" \")\n      });\n    } else {\n      this.removeSVGAttribute(\"aria-labelledby\");\n    }\n  };\n\n  Object.defineProperty(Chart.prototype, \"legend\", {\n    /**\r\n     * @return Legend\r\n     */\n    get: function () {\n      return this._legend.get();\n    },\n\n    /**\r\n     * Holds the instance of chart's [[Leged]].\r\n     *\r\n     * @see {@link https://www.amcharts.com/docs/v4/concepts/legend/} for more information about legends\r\n     * @param Legend\r\n     */\n    set: function (legend) {\n      this.setLegend(legend);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\r\n   * Prepares the legend instance for use in this chart.\r\n   *\r\n   * @param legend  Legend\r\n   */\n\n  Chart.prototype.setLegend = function (legend) {\n    var _this = this;\n\n    if (this._legend.get() !== legend) {\n      if (legend) {\n        // Set legend options\n        legend.parent = this.chartAndLegendContainer;\n\n        this._legend.set(legend, legend.events.on(\"propertychanged\", function (event) {\n          if (event.property == \"position\" || event.property == \"width\") {\n            _this.fixLayout();\n          }\n        }, undefined, false));\n      } else {\n        this._legend.reset();\n      }\n\n      this.feedLegend();\n    }\n  };\n  /**\r\n   * Destroys this object and all related data.\r\n   */\n\n\n  Chart.prototype.dispose = function () {\n    // otherwise there might be some errors when disposing chart which was just inited\n    if (this.legend) {\n      this.legend.dispose();\n    }\n\n    _super.prototype.dispose.call(this);\n  };\n  /**\r\n   * Processes JSON-based config before it is applied to the object.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param config  Config\r\n   */\n\n\n  Chart.prototype.processConfig = function (config) {\n    if (config) {\n      // Set up legend\n      if ($type.hasValue(config.legend) && !$type.hasValue(config.legend.type)) {\n        config.legend.type = \"Legend\";\n      }\n    }\n\n    _super.prototype.processConfig.call(this, config);\n  };\n  /**\r\n   * Copies all properties from another instance of [[Series]].\r\n   *\r\n   * @param source  Source series\r\n   */\n\n\n  Chart.prototype.copyFrom = function (source) {\n    this.titles.copyFrom(source.titles);\n\n    if (source.legend) {\n      this.legend = source.legend.clone();\n      this.legend.removeChildren();\n    }\n\n    _super.prototype.copyFrom.call(this, source);\n  };\n\n  Object.defineProperty(Chart.prototype, \"dragGrip\", {\n    /**\r\n     * @return Grip\r\n     */\n    get: function () {\n      var _this = this;\n\n      if (!this._dragGrip) {\n        var grip_1 = this.tooltipContainer.createChild(Grip);\n        grip_1.align = \"right\";\n        grip_1.valign = \"middle\";\n        grip_1.hide(0);\n        grip_1.events.on(\"down\", function (ev) {\n          if (ev.touch) {\n            _this.interactionsEnabled = false;\n          }\n        });\n        grip_1.events.on(\"up\", function (ev) {\n          _this.interactionsEnabled = true;\n        });\n        this.events.on(\"down\", function (ev) {\n          if (ev.touch) {\n            grip_1.show();\n          }\n        });\n        this._dragGrip = grip_1;\n      }\n\n      return this._dragGrip;\n    },\n\n    /**\r\n     * An instance of [[Grip]] which serves as a grip point which appears on\r\n     * touch and allows scrolling whole page even if chart is occupying the\r\n     * whole of the screen and would otherwise prevent scrolling.\r\n     *\r\n     * @since 4.4.0\r\n     * @see {@link https://www.amcharts.com/docs/v4/concepts/touch/} For more information.\r\n     * @param  value  Grip\r\n     */\n    set: function (value) {\n      this._dragGrip = value;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Chart.prototype, \"focusable\", {\n    get: function () {\n      return this.parent.focusable;\n    },\n    set: function (value) {\n      this.parent.focusable = true;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  return Chart;\n}(Component);\n\nexport { Chart };\n/**\r\n * Register class in system, so that it can be instantiated using its name from\r\n * anywhere.\r\n *\r\n * @ignore\r\n */\n\nregistry.registeredClasses[\"Chart\"] = Chart;\n/**\r\n * Add default responsive rules\r\n */\n\n/**\r\n * Reduce horizontal margins\r\n */\n\ndefaultRules.push({\n  relevant: ResponsiveBreakpoints.widthXS,\n  state: function (target, stateId) {\n    if (target instanceof Chart) {\n      var state = target.states.create(stateId);\n\n      if (target.pixelPaddingLeft > 10) {\n        state.properties.paddingLeft = 10;\n      }\n\n      if (target.pixelPaddingRight > 10) {\n        state.properties.paddingRight = 10;\n      }\n\n      return state;\n    }\n\n    return null;\n  }\n});\n/**\r\n * Reduce vertical margins\r\n */\n\ndefaultRules.push({\n  relevant: ResponsiveBreakpoints.heightXS,\n  state: function (target, stateId) {\n    if (target instanceof Chart) {\n      var state = target.states.create(stateId);\n\n      if (target.pixelPaddingTop > 10) {\n        state.properties.paddingTop = 10;\n      }\n\n      if (target.pixelPaddingBottom > 10) {\n        state.properties.paddingBottom = 10;\n      }\n\n      return state;\n    }\n\n    return null;\n  }\n});\n/**\r\n * Remove horizontal padding\r\n */\n\ndefaultRules.push({\n  relevant: ResponsiveBreakpoints.widthXXS,\n  state: function (target, stateId) {\n    if (target instanceof Chart) {\n      var state = target.states.create(stateId);\n      state.properties.paddingLeft = 0;\n      state.properties.paddingRight = 0;\n      return state;\n    }\n\n    return null;\n  }\n});\n/**\r\n * Remove vertical padding\r\n */\n\ndefaultRules.push({\n  relevant: ResponsiveBreakpoints.heightXXS,\n  state: function (target, stateId) {\n    if (target instanceof Chart) {\n      var state = target.states.create(stateId);\n      state.properties.paddingTop = 0;\n      state.properties.paddingBottom = 0;\n      return state;\n    }\n\n    return null;\n  }\n});","map":null,"metadata":{},"sourceType":"module"}