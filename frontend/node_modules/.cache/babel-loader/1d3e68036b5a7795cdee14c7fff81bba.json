{"ast":null,"code":"/**\r\n * Text class deals with all text placed on chart.\r\n */\nimport * as tslib_1 from \"tslib\";\n/**\r\n * ============================================================================\r\n * IMPORTS\r\n * ============================================================================\r\n * @hidden\r\n */\n\nimport { Container } from \"../Container\";\nimport { registry } from \"../Registry\";\nimport { getTextFormatter } from \"../formatters/TextFormatter\";\nimport { MultiDisposer } from \"../utils/Disposer\";\nimport { InterfaceColorSet } from \"../../core/utils/InterfaceColorSet\";\nimport * as $math from \"../utils/Math\";\nimport * as $utils from \"../utils/Utils\";\nimport * as $type from \"../utils/Type\";\nimport * as $dom from \"../utils/DOM\";\nimport { defaultRules, ResponsiveBreakpoints } from \"../utils/Responsive\";\n;\n/**\r\n * ============================================================================\r\n * MAIN CLASS\r\n * ============================================================================\r\n * @hidden\r\n */\n\n/**\r\n * Text is used to display highly configurable, data-enabled textual elements.\r\n *\r\n * ## Data Binding\r\n *\r\n * A Text element can dynamically parse and populate its contents with values\r\n * from a [[DataItem]].\r\n *\r\n * To activate such binding, set element's `dataItem` property.\r\n *\r\n * When activated, text contents will be parsed for special tags, e.g.:\r\n *\r\n * ```TypeScript\r\n * label.dataItem = myDataItem;\r\n * label.text = \"The title is: {title}\";\r\n * ```\r\n * ```JavaScript\r\n * label.dataItem = myDataItem;\r\n * label.text = \"The title is: {title}\";\r\n * ```\r\n *\r\n * The above will automatically replace \"{title}\" in the string with the\r\n * actual data value from `myDataItem`.\r\n *\r\n * Note, that most often dataItem is set by the Component.\r\n *\r\n *\r\n * @see {@link ILabelEvents} for a list of available events\r\n * @see {@link ILabelAdapters} for a list of available Adapters\r\n * @see {@link https://www.amcharts.com/docs/v4/concepts/formatters/formatting-strings/} for info on string formatting and data binding\r\n * @todo Vertical align\r\n * @important\r\n */\n\nvar Label =\n/** @class */\nfunction (_super) {\n  tslib_1.__extends(Label, _super);\n  /**\r\n   * Constructor\r\n   */\n\n\n  function Label() {\n    var _this = // Execute super's constructor\n    _super.call(this) || this;\n    /**\r\n     * Indicates if the whole text does not fit into max dimenstions set for it.\r\n     */\n\n\n    _this.isOversized = false; // Set this class name\n\n    _this.className = \"Label\";\n    _this.fill = new InterfaceColorSet().getFor(\"text\"); // not good to set this, as then these will appear on each label and values set on container won't be applied.\n    //this.textDecoration = \"none\";\n    //this.fontWeight = \"normal\";\n    // Set defaults\n\n    _this.wrap = false;\n    _this.truncate = false;\n    _this.fullWords = true;\n    _this.ellipsis = \"...\";\n    _this.textAlign = \"start\";\n    _this.textValign = \"top\";\n    _this.layout = \"absolute\";\n    _this.baseLineRatio = -0.27; // Add events to watch for maxWidth/maxHeight changes so that we can\n    // invalidate this\n\n    _this.events.on(\"maxsizechanged\", function () {\n      if (_this.inited) {\n        _this.handleMaxSize();\n      }\n    }, _this, false); // this solves strange bug when text just added to svg is 0x0\n\n\n    _this.events.once(\"validated\", _this.handleValidate, _this, false); // Aply theme\n\n\n    _this.applyTheme();\n\n    return _this;\n  }\n  /**\r\n   * A placeholder method that is called **after** element finishes drawing\r\n   * itself.\r\n   *\r\n   * @ignore Exclude from docs\r\n   */\n\n\n  Label.prototype.afterDraw = function () {\n    // since we removed validatePosition from sprite, we still need it here to handle rotated text\n    _super.prototype.afterDraw.call(this);\n\n    this.validatePosition();\n  };\n  /**\r\n   * Sets [[Paper]] instance to use to draw elements.\r\n   * @ignore\r\n   * @param paper Paper\r\n   * @return true if paper was changed, false, if it's the same\r\n   */\n\n\n  Label.prototype.setPaper = function (paper) {\n    var changed = _super.prototype.setPaper.call(this, paper);\n\n    if (changed) {\n      this.hardInvalidate();\n    }\n\n    return changed;\n  };\n  /**\r\n   * @ignore\r\n   */\n\n\n  Label.prototype.handleValidate = function () {\n    if ((this.currentText || this.text) && (this.bbox.width == 0 || this.bbox.height == 0)) {\n      registry.events.once(\"exitframe\", this.hardInvalidate, this);\n    }\n  };\n  /**\r\n   * @ignore\r\n   */\n\n\n  Label.prototype.handleMaxSize = function () {\n    if (this.bbox.width > this.availableWidth || this.bbox.width < this.availableWidth && (this.isOversized || this.truncate) || this.bbox.height > this.availableHeight || this.bbox.height < this.availableHeight && this.isOversized) {\n      this.invalidate();\n    } else {\n      this.alignSVGText();\n    }\n  };\n  /**\r\n   * [arrange description]\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @todo Description\r\n   */\n\n\n  Label.prototype.arrange = function () {};\n  /**\r\n   * Updates current text according to data item and supported features.\r\n   * Returns `true` if current text has changed.\r\n   *\r\n   * @return Text changed?\r\n   */\n\n\n  Label.prototype.updateCurrentText = function () {\n    // Determine output format\n    var output, text;\n\n    if ($utils.isNotEmpty(this.html) && this.paper.supportsForeignObject()) {\n      // We favor HTML text if it's set and browser supports `foreignObject`\n      output = \"html\";\n      text = this.html;\n    } else {\n      output = \"svg\";\n      text = this.text;\n    } // Need to toString source?\n\n\n    if ($type.isObject(text)) {\n      text = text.toString();\n    } // Need to format text all the time\n\n\n    if ($type.hasValue(text) && text !== \"\") {\n      text = this.populateString(text, this.dataItem);\n    }\n\n    if (output == \"html\") {\n      if (this._adapterO) {\n        text = this._adapterO.apply(\"htmlOutput\", text);\n      }\n    } else {\n      if (this._adapterO) {\n        text = this._adapterO.apply(\"textOutput\", text);\n      }\n    } // Update the text\n\n\n    var changed = text != this.currentText || output != this._currentFormat;\n    this.currentText = text;\n    this._currentFormat = output;\n    return changed;\n  };\n  /**\r\n   * Hard invalidate means the text will be redrawn even if it hasn't changed.\r\n   * This is used when we change `fontSize`, `fontFamily`, or for some other\r\n   * reasons.\r\n   */\n\n\n  Label.prototype.hardInvalidate = function () {\n    this._prevStatus = \"\";\n    this.invalidate();\n  };\n  /**\r\n   * Gets line bbox, uses caching to save cpu\r\n   * @ignore\r\n   */\n\n\n  Label.prototype.getLineBBox = function (lineInfo) {\n    //let cacheKey = lineInfo.text + lineInfo.style;\n    //let lineBBox = this.getCache(cacheKey);\n    //if (!lineBBox) {\n    //lineBBox = lineInfo.element.getBBox();\n    //if (lineBBox.width != 0 && lineBBox.height != 0) {\n    //\tthis.setCache(cacheKey, lineBBox, 5000);\n    //}\n    //}\n    var element = lineInfo && lineInfo.element;\n    var node = element && element.node; // Check for the parent Node to avoid FF from throwing errors\n\n    if (node && node.parentNode) {\n      lineInfo.bbox = element.getBBox();\n    }\n  };\n  /**\r\n   * Draws the textual label.\r\n   *\r\n   * @ignore Exclude from docs\r\n   */\n\n\n  Label.prototype.draw = function () {\n    // Draw super\n    _super.prototype.draw.call(this);\n\n    var oldW = this.bbox.width;\n    var oldH = this.bbox.height;\n    var topParent = this.topParent;\n\n    if (topParent) {\n      if (!topParent.maxWidth || !topParent.maxHeight) {\n        topParent.events.once(\"maxsizechanged\", this.hardInvalidate, this, false);\n        return;\n      }\n    } // Calculate max width and height\n\n\n    var maxWidth = $math.max(this.availableWidth - this.pixelPaddingLeft - this.pixelPaddingRight, 0);\n    var maxHeight = $math.max(this.availableHeight - this.pixelPaddingTop - this.pixelPaddingBottom, 0); // save\n\n    var status = maxHeight + \",\" + maxWidth + this.wrap + this.truncate + this.fullWords + this.rtl + this.ellipsis; // Update text\n\n    if (!this.updateCurrentText() && this.inited && this._prevStatus == status) {\n      return;\n    }\n\n    this._measuredWidth = 0;\n    this._measuredHeight = 0; // Reset\n\n    this.isOversized = false; // Determine output format\n\n    var output = this._currentFormat;\n    var text = this.currentText; // Empty string\n\n    if (!$type.hasValue(text) || text == \"\") {\n      this.element.attr({\n        display: \"none\"\n      });\n      return;\n    } // Chop up text into lines\n    // We're still processing SVG and HTML in the same way for now\n\n\n    var lines = text.split(\"\\n\"); // Do we need to go through the trouble of measuring lines\n    //let measure: boolean = true;// (lines.length > 1) || this.wrap;\n\n    this._prevStatus = status;\n    this.textAlign = this.textAlign; // need this to measure\n\n    var display = this.group.getAttr(\"display\");\n\n    if (display == \"none\") {\n      this.group.removeAttr(\"display\");\n    }\n\n    if (this.textPathElement) {\n      this.textPathElement.removeChildren();\n    } // SVG or HTML?\n\n\n    if (output === \"svg\") {\n      /**\r\n       * SVG\r\n       */\n      this.element.removeAttr(\"display\"); // Clear the element\n\n      var group = this.element;\n      this.resetBBox(); // Init state variables\n\n      var currentHeight = 0;\n      var currentFormat = \"\"; // Process each line\n\n      for (var i = 0; i < lines.length; i++) {\n        // Get line\n        var line = lines[i]; // Check if line is empty\n\n        if (line == \"\") {\n          // It is, let's just update currentHeight and go to the next one\n          // If it's the first line, we'll have to use arbirary line height,\n          // since there's nothing to measure. For subsequent lines we can take\n          // previous line's height\n          var tempElement = this.getSVGLineElement(\"\", 0);\n          tempElement.add(this.getSvgElement(\".\", getTextFormatter().translateStyleShortcuts(currentFormat)));\n          group.add(tempElement);\n          var offset = Math.ceil(tempElement.getBBox().height);\n\n          if (offset > 0) {\n            currentHeight += offset;\n          }\n\n          group.removeElement(tempElement);\n          continue;\n        } // Chunk up the line and process each chunk\n\n\n        var chunks = getTextFormatter().chunk(line, null, this.ignoreFormatting);\n        var currentLineHeight = 0;\n        var firstChunk = true;\n        var skipTextChunks = false; // Create line element or grab it from cache\n\n        var lineInfo = this.getLineInfo(i);\n\n        if (lineInfo) {\n          // Empty line\n          lineInfo.element.textContent = \"\";\n        } else {\n          // Init new line info\n          lineInfo = {\n            \"element\": this.getSVGLineElement(\"\", 0),\n            \"complex\": false\n          }; // Create the line element\n          //lineInfo.element = this.getSVGLineElement(\"\", 0);\n          //lineElement = this.getSVGLineElement(\"\", 0);\n\n          group.add(lineInfo.element);\n        }\n\n        lineInfo.element.removeAttr(\"display\");\n        lineInfo.element.removeChildren(); // memory leak without this\n\n        if (this.textPathElement) {\n          lineInfo.element.add(this.textPathElement);\n        }\n        /*// @todo not needed anymore\r\n        if (this.rtl) {\r\n            chunks.reverse();\r\n        }*/\n        // Process each chunk\n\n\n        for (var x = 0; x < chunks.length; x++) {\n          // If there's more than one chunk, means the line is \"complex\"\n          if (x) {\n            lineInfo.complex = true;\n          } // Get chunk\n\n\n          var chunk = chunks[x]; // Is this chunk format or text?\n\n          if (chunk.type === \"format\") {\n            // Log current format, so that we can apply it to multiple lines if\n            // necessary\n            currentFormat = chunk.text;\n          } else {\n            // It's text block\n            // Need to skip?\n            // We do this when truncating. We can't just simply go ahead and\n            // abandon chunk processing as they might have formatting\n            // instructions in them that are relevant for subsequent lines\n            if (skipTextChunks) {\n              continue;\n            } // Add chunk to the current element\n            //lineInfo.element.content += $utils.trim(getTextFormatter().format(currentFormat + chunk.text, output));\n\n\n            lineInfo.text = chunk.text;\n            lineInfo.style = getTextFormatter().translateStyleShortcuts(currentFormat);\n            var tspan = this.getSvgElement(lineInfo.text, lineInfo.style);\n\n            if (this.textPathElement) {\n              this.textPathElement.add(tspan);\n            } else {\n              lineInfo.element.add(tspan);\n            }\n\n            this.getLineBBox(lineInfo);\n            lineInfo.bbox.width = Math.ceil(lineInfo.bbox.width); // Updated current line height\n\n            if (currentLineHeight < lineInfo.bbox.height) {\n              currentLineHeight = lineInfo.bbox.height;\n            } // Wrapping?\n\n\n            if ((this.wrap || this.truncate) && lineInfo.bbox.width > maxWidth) {\n              // Set oversized\n              this.isOversized = true; // Take temporary measurements\n\n              var lineText = lineInfo.element.textContent;\n              var avgCharWidth = lineInfo.bbox.width / lineText.length; // * .9;\n              // Calculate average number of symbols / width\n\n              var excessChars = $math.min(Math.ceil((lineInfo.bbox.width - maxWidth) / avgCharWidth), lineText.length); // Are we truncating or auto-wrapping text?\n\n              if (this.truncate) {\n                /**\r\n                 * Processing line truncation\r\n                 * With the addition of each text chunk we measure if current\r\n                 * line does not exceed maxWidth. If it does, we will stop\r\n                 * addition of further chunks as well as try to truncate\r\n                 * current or any number of previous chunks with an added\r\n                 * ellipsis\r\n                 */\n                // Indicator whether we need to add ellipsis to the current\n                // element, even if it fits. This is needed to indicate\n                // whether we have already removed some subsequent chunks in\n                // which case we need to add ellipsis.\n                var addEllipsis = false; // Process each child in the temporary line, until the whole\n                // line fits, preferably with an ellipsis\n                // TODO use iterator instead\n\n                var node_1 = lineInfo.element.node;\n\n                if (node_1 && node_1.childNodes) {\n                  for (var e = lineInfo.element.node.childNodes.length - 1; e >= 0; e--) {\n                    // Get current element\n                    var node_2 = lineInfo.element.node.childNodes[e]; // Add ellipsis only if previous chunk was removed in full\n                    // and this chunk already fits\n                    //if (addEllipsis && (bbox.width <= maxWidth)) {\n\n                    if (addEllipsis && lineInfo.bbox.width <= maxWidth) {\n                      // Add ellipsis\n                      node_2.textContent += \" \" + this.ellipsis; // Measure again (we need to make sure ellipsis fits)\n\n                      lineInfo.bbox = lineInfo.element.getBBox();\n                      lineInfo.bbox.width = Math.floor(lineInfo.bbox.width); // If it fits, we're done here\n                      // If it doesn't we continue rolling\n\n                      if (lineInfo.bbox.width <= maxWidth) {\n                        break;\n                      }\n                    }\n\n                    addEllipsis = false; // Get element text\n\n                    var elementText = node_2.textContent; // Calculate average number of symbols / width\n\n                    lineText = lineInfo.element.textContent;\n                    excessChars = $math.min(Math.ceil((lineInfo.bbox.width - maxWidth) / avgCharWidth), lineText.length); // Do this until we fit\n\n                    while (lineInfo.bbox.width > maxWidth && excessChars <= lineText.length && excessChars > 0) {\n                      // Calculate max available chars\n                      var maxChars = $math.max(elementText.length - excessChars - this.ellipsis.length, 1); // Is there anything left?\n\n                      if (maxChars <= 1) {\n                        // Nope, let's jump to the previous item\n                        // Set excess characters to zero so that this loop does\n                        // not repeat when it over\n                        excessChars = 0; // Add ellipsis to previous item\n                        // Subsequent iterations will check if the ellipsis fits\n\n                        if (e > 0) {\n                          // Indicating to add ellipsis to previous item\n                          addEllipsis = true; // Removing this node\n\n                          lineInfo.element.node.removeChild(node_2);\n                        }\n                      } // Truncate the text\n\n\n                      elementText = $utils.truncateWithEllipsis(elementText, maxChars, this.ellipsis, this.fullWords, this.rtl);\n\n                      if (elementText.length > maxChars && this.fullWords) {\n                        // Still too long?\n                        // Let's try truncating breaking words anyway\n                        elementText = $utils.truncateWithEllipsis(elementText, maxChars, this.ellipsis, false, this.rtl);\n                      } // Set truncated text\n\n\n                      node_2.textContent = elementText; // Measure again\n\n                      lineInfo.bbox = lineInfo.element.getBBox();\n                      lineInfo.bbox.width = Math.floor(lineInfo.bbox.width); // Increase excess characters count, just in case it still\n                      // doesn't fit and we have to go at it again\n\n                      excessChars = Math.ceil(excessChars * 1.1);\n                    } // Do not process further chunks\n\n\n                    skipTextChunks = true;\n                  }\n                }\n              } else {\n                /**\r\n                 * Processign auto-wrap\r\n                 * In this case we're going to be adding text chunks until\r\n                 * they don't fit into current line. Once that happens we will\r\n                 * inject the rest of the chunks to the next line\r\n                 */\n                // Get last node added and measure it\n                var node_3 = lineInfo.element.node;\n\n                if (node_3) {\n                  var lastNode = lineInfo.element.node.lastChild; // Init split lines\n\n                  var splitLines = void 0;\n\n                  while (lineInfo.bbox.width > maxWidth && excessChars <= lineText.length && excessChars > 0) {\n                    // Calculate max available chars\n                    var maxChars = $math.max(chunk.text.length - excessChars, 1); // Don't split the words mid-word if it's not the first chunk\n                    // in the line\n\n                    if (firstChunk) {\n                      // Split mid-word if necessary\n                      splitLines = $utils.splitTextByCharCount(chunk.text, maxChars, true, this.rtl);\n                    } else {\n                      // Don't split mid-word\n                      splitLines = $utils.splitTextByCharCount(chunk.text, maxChars, true, this.rtl); // Check if the first word is too long\n\n                      if (splitLines[0].length > maxChars || maxChars === 1) {\n                        // Yes - move the whole chunk to the next line\n                        // Remove the element we just added\n                        lineInfo.element.node.removeChild(lastNode); // Break out of the while on next cycle\n\n                        excessChars = 0;\n                      }\n                    } // Use the first line to update last item\n\n\n                    if (excessChars > 0) {\n                      lastNode.textContent = getTextFormatter().cleanUp($utils.trim(splitLines.shift()));\n                    } // Measure again, just in case\n\n\n                    lineInfo.bbox = lineInfo.element.getBBox();\n                    lineInfo.bbox.width = Math.floor(lineInfo.bbox.width); // Increase excess characters count, just in case it still\n                    // doesn't fit and we have to go at it again\n\n                    excessChars = Math.ceil(excessChars * 1.1);\n                  } // Construct the rest of the line\n\n\n                  if (splitLines.length > 0) {\n                    var restOfLine = \"\"; // Add leftovers from splitting the current chunk\n\n                    if ($type.hasValue(splitLines)) {\n                      if (this.rtl) {\n                        restOfLine += splitLines.join(\"\") + currentFormat;\n                      } else {\n                        restOfLine += currentFormat + splitLines.join(\"\").replace(/([\\[\\]]{1})/g, \"$1$1\");\n                      }\n                    } // Add the rest of the chunks\n\n\n                    for (var c = x + 1; c < chunks.length; c++) {\n                      if (chunks[c].type == \"value\") {\n                        // We're escaping single square brackets that were\n                        // cleaned up by chunk() back to double square brackets\n                        // so that they are not being treated as format on\n                        // next pass.\n                        restOfLine += chunks[c].text.replace(/([\\[\\]]{1})/g, \"$1$1\");\n                      } else {\n                        restOfLine += chunks[c].text;\n                      }\n                    } // Inject the rest of the lines as chunks for subsequent\n\n\n                    lines.splice(i + 1, 0, restOfLine);\n                  } // Skip processing the rest of the chunks\n\n\n                  skipTextChunks = true;\n                }\n              }\n            } // Let's update the text's bbox with the line's one\n\n\n            if (this.bbox.width < lineInfo.bbox.width) {\n              this.bbox.width = lineInfo.bbox.width;\n            } // commented to avoid bug (seen on sankey link) where text is incorrectly aligned\n            //if (this.bbox.x > lineInfo.bbox.x) {\n            //this.bbox.x = lineInfo.bbox.x;\n            //}\n\n\n            this.bbox.height = currentHeight + currentLineHeight; // Position current line\n\n            if (!this.textPathElement) {\n              lineInfo.element.attr({\n                \"x\": \"0\",\n                \"y\": currentHeight + currentLineHeight,\n                \"dy\": $math.round(this.baseLineRatio * currentLineHeight, 3).toString()\n              });\n            } else {\n              lineInfo.element.attr({\n                \"dy\": -this.paddingBottom.toString()\n              });\n            }\n\n            firstChunk = false;\n          }\n        } // Trim the last item\n\n\n        var node = lineInfo.element.node;\n\n        if (node) {\n          var lastNode = node.lastChild;\n\n          if (lastNode) {\n            lastNode.textContent = this.rtl ? $utils.ltrim(lastNode.textContent) : $utils.rtrim(lastNode.textContent);\n          }\n        } // Increment collective height\n\n\n        currentHeight += currentLineHeight; // Save line cache\n\n        this.addLineInfo(lineInfo, i);\n      } // Check if maybe we need to hide the whole label if it doesn't fit\n\n\n      this.maybeHideOversized();\n      this.measureFailed = false;\n\n      if (this.bbox.width == 0 || this.bbox.height == 0) {\n        this.measureFailed = true;\n      } // Updated measured dims\n\n\n      this._measuredWidth = $math.max(this.bbox.width, this.pixelWidth - this.pixelPaddingLeft - this.pixelPaddingRight);\n      this._measuredHeight = $math.max(this.bbox.height, this.pixelHeight - this.pixelPaddingTop - this.pixelPaddingBottom); // Align the lines\n\n      this.alignSVGText();\n      this.bbox.width = this._measuredWidth;\n      this.bbox.height = this._measuredHeight;\n\n      if (oldH != this._measuredHeight || oldW != this._measuredWidth) {\n        this.dispatch(\"transformed\");\n      }\n\n      this.hideUnused(lines.length);\n    } else {\n      /**\r\n       * HTML\r\n       */\n      this.element.removeAttr(\"display\");\n      this.resetBBox(); // Clear the element\n\n      var group = this.element;\n      group.removeChildren(); // Create a ForeignObject to use as HTML container\n\n      var fo = this.paper.foreignObject();\n      group.add(fo); // Set widths on foreignObject so that autosizing measurements work\n      // This will bet reset to actual content width/height\n\n      if (this.maxWidth) {\n        fo.attr({\n          width: this.maxWidth\n        });\n      }\n\n      if (this.maxHeight) {\n        fo.attr({\n          height: this.maxHeight\n        });\n      } // Create line element\n      //let lineElement: HTMLElement = this.getHTMLLineElement(getTextFormatter().format(this.html, output));\n\n\n      var lineElement = this.getHTMLLineElement(text);\n      fo.node.appendChild(lineElement); // Temporarily set to inline-block so we can measure real width and height\n\n      lineElement.style.display = \"inline-block\";\n      var clientWidth = lineElement.clientWidth;\n      var clientHeight = lineElement.clientHeight;\n      lineElement.style.display = \"block\";\n      this._bbox = {\n        x: 0,\n        y: 0,\n        width: clientWidth,\n        height: clientHeight\n      }; // Set exact dimensions of foreignObject so it is sized exactly as\n      // the content within\n\n      fo.attr({\n        width: clientWidth,\n        height: clientHeight\n      }); // Check if maybe we need to hide the whole label if it doesn't fit\n\n      this.maybeHideOversized(); // Set measurements and update bbox\n\n      this._measuredWidth = $math.max(this.bbox.width, this.pixelWidth - this.pixelPaddingLeft - this.pixelPaddingRight);\n      this._measuredHeight = $math.max(this.bbox.height, this.pixelHeight - this.pixelPaddingTop - this.pixelPaddingBottom);\n      this.bbox.width = this._measuredWidth;\n      this.bbox.height = this._measuredHeight; // Don't let labels bleed out of the alotted area\n\n      if (this.truncate) {\n        lineElement.style.overflow = \"hidden\";\n      }\n\n      if (clientWidth > maxWidth || clientHeight > maxHeight) {\n        this.isOversized = true;\n      }\n    } // Set applicable styles\n\n\n    this.setStyles();\n    this.updateCenter();\n    this.updateBackground();\n\n    if (display == \"none\") {\n      this.group.attr({\n        display: \"none\"\n      });\n    }\n\n    if (this.pathElement) {\n      this.paper.appendDef(this.pathElement);\n    }\n  };\n  /**\r\n   * Hides element if it does not fit into available space\r\n   */\n\n\n  Label.prototype.maybeHideOversized = function () {\n    if (this.hideOversized) {\n      if (this.availableWidth < this.bbox.width || this.availableHeight < this.bbox.height) {\n        this.element.attr({\n          display: \"none\"\n        });\n        this.isOversized = true;\n      } else {\n        this.element.removeAttr(\"display\");\n        this.isOversized = false;\n      }\n    }\n  };\n  /**\r\n   * Aligns the lines horizontally ant vertically, based on properties.\r\n   *\r\n   * @ignore Exclude from docs\r\n   */\n\n\n  Label.prototype.alignSVGText = function () {\n    // Get Group\n    var group = this.element;\n    var children = group.node.children || group.node.childNodes; // Is there anything to align?\n\n    if (!children || children && children.length == 0) {\n      return;\n    }\n\n    var width = this._measuredWidth;\n    var height = this._measuredHeight; // TODO maybe these aren't needed ?\n\n    $utils.used(this.pixelPaddingLeft);\n    $utils.used(this.pixelPaddingRight);\n    $utils.used(this.pixelPaddingTop);\n    $utils.used(this.pixelPaddingBottom); // Process each line\n    //$iter.each(group.children.backwards().iterator(), (element) => {\n\n    for (var i = children.length - 1; i >= 0; i--) {\n      // Align horizontally\n      // Since we are using `text-anchor` for horizontal alignment, all we need\n      // to do here is move the `x` position\n      var node = children[i];\n      node.setAttribute(\"text-anchor\", this.textAlign);\n\n      if (this.textPathElement) {\n        node.removeAttribute(\"x\");\n        node.removeAttribute(\"y\");\n      } else {\n        switch (this.textAlign) {\n          case \"middle\":\n            node.setAttribute(\"x\", (width / 2).toString() + \"px\");\n            break;\n\n          case \"end\":\n            if (this.rtl) {} else {\n              node.setAttribute(\"x\", width.toString());\n            }\n\n            break;\n\n          default:\n            if (this.rtl) {\n              node.setAttribute(\"x\", width.toString());\n            } else {\n              node.removeAttribute(\"text-anchor\");\n            }\n\n            break;\n        }\n\n        var y = $type.toNumber(node.getAttribute(\"y\"));\n\n        switch (this.textValign) {\n          case \"middle\":\n            node.setAttribute(\"y\", (y + (height - this.bbox.height) / 2).toString());\n            break;\n\n          case \"bottom\":\n            node.setAttribute(\"y\", (y + height - this.bbox.height).toString());\n            break;\n\n          default:\n            node.setAttribute(\"y\", y.toString());\n            break;\n        }\n      }\n    }\n  };\n  /**\r\n   * Produces an SVG line element with formatted text.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param text    Text to wrap into line\r\n   * @param y       Current line vertical position\r\n   * @return A DOM element\r\n   * @todo Implement HTML support\r\n   */\n\n\n  Label.prototype.getSVGLineElement = function (text, y) {\n    // Create a <text> node and set text\n    var element = this.paper.addGroup(\"text\");\n    element.textContent = text; // Set parameters\n\n    element.attr({\n      \"x\": \"0\" //\"alignment-baseline\": \"hanging\",\n      //\"baseline-shift\": \"-20%\",\n      //\"text-anchor\": \"center\"\n\n    }); // Set `y` position\n\n    if ($type.hasValue(y)) {\n      element.attr({\n        \"y\": y.toString()\n      });\n    } // Don't let labels blled out of the alotted area\n\n\n    if (this.truncate || this.wrap) {\n      element.attr({\n        \"overflow\": \"hidden\"\n      });\n    } // Add RTL?\n\n\n    if (this.rtl) {\n      element.attr({\n        \"direction\": \"rtl\"\n      });\n    }\n\n    return element;\n  };\n  /**\r\n   * Resets cached BBox.\r\n   *\r\n   * @ignore Exclude from docs\r\n   */\n\n\n  Label.prototype.resetBBox = function () {\n    this._bbox = {\n      x: 0,\n      y: 0,\n      width: 0,\n      height: 0\n    };\n  };\n  /**\r\n   * Creates and returns an HTML line element (`<div>`).\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param text  Text to add\r\n   * @return `<div>` element reference\r\n   */\n\n\n  Label.prototype.getHTMLLineElement = function (text) {\n    // Create the <div> element\n    var div = document.createElement(\"div\");\n    div.innerHTML = text; // Set text alignment\n\n    switch (this.textAlign) {\n      case \"middle\":\n        div.style.textAlign = \"center\";\n        break;\n\n      case \"end\":\n        div.style.textAlign = \"right\";\n        break;\n    } // Disable or enable wrapping\n\n\n    if (this.wrap) {\n      div.style.wordWrap = \"break-word\";\n    } else {\n      div.style.whiteSpace = \"nowrap\";\n    } // Don't let labels bleed out of the alotted area\n    // Moved to `draw()` because setting \"hidden\" kills all measuring\n\n    /*if (this.truncate) {\r\n        div.style.overflow = \"hidden\";\r\n    }*/\n    // Set RTL-related styles\n\n\n    if (this.rtl) {\n      div.style.direction = \"rtl\"; //div.style.unicodeBidi = \"bidi-override\";\n    } // Translate some of the SVG styles into CSS\n\n\n    if ($type.hasValue(this.fill)) {\n      div.style.color = this.fill.toString();\n    }\n\n    return div;\n  };\n  /**\r\n   * Applies specific styles to text to make it not selectable, unless it is\r\n   * explicitly set as `selectable`.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @todo Set styles via AMElement\r\n   */\n\n\n  Label.prototype.setStyles = function () {\n    var group = this.element;\n\n    if (!this.selectable || this.draggable || this.resizable || this.swipeable) {\n      group.addStyle({\n        \"webkitUserSelect\": \"none\",\n        \"msUserSelect\": \"none\"\n      });\n    } else if (this.selectable) {\n      group.removeStyle(\"webkitUserSelect\");\n      group.removeStyle(\"msUserSelect\");\n    }\n  };\n  /**\r\n   * Hides unused lines\r\n   */\n\n\n  Label.prototype.hideUnused = function (index) {\n    this.initLineCache();\n    var lines = this.getCache(\"lineInfo\");\n\n    if (lines.length >= index) {\n      for (var i = index; i < lines.length; i++) {\n        var line = lines[i];\n\n        if (line && line.element) {\n          line.element.attr({\n            \"display\": \"none\"\n          });\n        }\n      }\n    }\n  };\n\n  Object.defineProperty(Label.prototype, \"text\", {\n    /**\r\n     * @return SVG text\r\n     */\n    get: function () {\n      return this.getPropertyValue(\"text\");\n    },\n\n    /**\r\n     * An SVG text.\r\n     *\r\n     * Please note that setting `html` will override this setting if browser\r\n     * supports `foreignObject` in SGV, such as most modern browsers excluding\r\n     * IEs.\r\n     *\r\n     * @param value  SVG Text\r\n     */\n    set: function (value) {\n      //this.setPropertyValue(\"html\", undefined);\n      this.setPropertyValue(\"text\", value, true);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Label.prototype, \"path\", {\n    /**\r\n     * @return Path\r\n     */\n    get: function () {\n      return this.getPropertyValue(\"path\");\n    },\n\n    /**\r\n     * An SVG path string to position text along. If set, the text will follow\r\n     * the curvature of the path.\r\n     *\r\n     * Location along the path can be set using `locationOnPath`.\r\n     *\r\n     * IMPORTANT: Only SVG text can be put on path. If you are using HTML text\r\n     * this setting will be ignored.\r\n     *\r\n     * @since 4.1.2\r\n     * @param  value  Path\r\n     */\n    set: function (value) {\n      if (this.setPropertyValue(\"path\", value, true)) {\n        if (this.pathElement) {\n          this.pathElement.dispose();\n        }\n\n        if (this.textPathElement) {\n          this.textPathElement.dispose();\n        }\n\n        this.pathElement = this.paper.add(\"path\");\n        this.pathElement.attr({\n          \"d\": value\n        });\n        this.pathElement.attr({\n          \"id\": \"text-path-\" + this.uid\n        });\n\n        this._disposers.push(this.pathElement);\n\n        this.textPathElement = this.paper.addGroup(\"textPath\");\n        this.textPathElement.attrNS($dom.XLINK, \"xlink:href\", \"#text-path-\" + this.uid); // TODO remove after https://bugzilla.mozilla.org/show_bug.cgi?id=455986 is fixed\n\n        this.textPathElement.attr({\n          \"path\": value\n        });\n\n        this._disposers.push(this.textPathElement);\n\n        this.hardInvalidate();\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Label.prototype, \"locationOnPath\", {\n    /**\r\n     * @return Relatvie location on path\r\n     */\n    get: function () {\n      return this.getPropertyValue(\"locationOnPath\");\n    },\n\n    /**\r\n     * Relative label location on `path`. Value range is from 0 (beginning)\r\n     * to 1 (end).\r\n     *\r\n     * Works only if you set `path` setting to an SVG path.\r\n     *\r\n     * @since 4.1.2\r\n     * @default 0\r\n     * @param  value  Relatvie location on path\r\n     */\n    set: function (value) {\n      this.setPropertyValue(\"locationOnPath\", value);\n\n      if (this.textPathElement) {\n        this.textPathElement.attr({\n          \"startOffset\": value * 100 + \"%\"\n        });\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Label.prototype, \"baseLineRatio\", {\n    /**\r\n     * @return Base line ratio\r\n     */\n    get: function () {\n      return this.getPropertyValue(\"baseLineRatio\");\n    },\n\n    /**\r\n     * A ratio to calculate text baseline. Ralative distance from the bottom of\r\n     * the label.\r\n     *\r\n     * @since 4.4.2\r\n     * @default -0.27\r\n     * @param  value  Base line ratio\r\n     */\n    set: function (value) {\n      this.setPropertyValue(\"baseLineRatio\", value);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Label.prototype, \"wrap\", {\n    /**\r\n     * @return Auto-wrap enabled or not\r\n     */\n    get: function () {\n      return this.getPropertyValue(\"wrap\");\n    },\n\n    /**\r\n     * Enables or disables autowrapping of text.\r\n     *\r\n     * @param value  Auto-wrapping enabled\r\n     */\n    set: function (value) {\n      this.resetBBox();\n      this.setPropertyValue(\"wrap\", value, true);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Label.prototype, \"truncate\", {\n    /**\r\n     * @return Truncate text?\r\n     */\n    get: function () {\n      return this.getPropertyValue(\"truncate\");\n    },\n\n    /**\r\n     * Indicates if text lines need to be truncated if they do not fit, using\r\n     * configurable `ellipsis` string.\r\n     *\r\n     * `truncate` overrides `wrap` if both are set to `true`.\r\n     *\r\n     * NOTE: For HTML text, this setting **won't** trigger a parser and actual\r\n     * line truncation with ellipsis. It will just hide everything that goes\r\n     * outside the label.\r\n     *\r\n     * @param value  trincate text?\r\n     */\n    set: function (value) {\n      this.resetBBox();\n      this.setPropertyValue(\"truncate\", value, true);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Label.prototype, \"fullWords\", {\n    /**\r\n     * @return Truncate on full words?\r\n     */\n    get: function () {\n      return this.getPropertyValue(\"fullWords\");\n    },\n\n    /**\r\n     * If `truncate` is enabled, should Label try to break only on full words\r\n     * (`true`), or whenever needed, including middle of the word. (`false`)\r\n     *\r\n     * @default true\r\n     * @param value  Truncate on full words?\r\n     */\n    set: function (value) {\n      this.setPropertyValue(\"fullWords\", value, true);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Label.prototype, \"ellipsis\", {\n    /**\r\n     * @return Ellipsis string\r\n     */\n    get: function () {\n      return this.getPropertyValue(\"ellipsis\");\n    },\n\n    /**\r\n     * Ellipsis character to use if `truncate` is enabled.\r\n     *\r\n     * @param value Ellipsis string\r\n     * @default \"...\"\r\n     */\n    set: function (value) {\n      this.setPropertyValue(\"ellipsis\", value, true);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Label.prototype, \"selectable\", {\n    /**\r\n     * @return Text selectable?\r\n     */\n    get: function () {\n      return this.getPropertyValue(\"selectable\");\n    },\n\n    /**\r\n     * Forces the text to be selectable. This setting will be ignored if the\r\n     * object has some kind of interaction attached to it, such as it is\r\n     * `draggable`, `swipeable`, `resizable`.\r\n     *\r\n     * @param value  Text selectable?\r\n     * @default false\r\n     */\n    set: function (value) {\n      this.setPropertyValue(\"selectable\", value, true);\n      this.setStyles();\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Label.prototype, \"textAlign\", {\n    /**\r\n     * @return Alignment\r\n     */\n    get: function () {\n      return this.getPropertyValue(\"textAlign\");\n    },\n\n    /**\r\n     * Horizontal text alignment.\r\n     *\r\n     * Available choices:\r\n     * * \"start\"\r\n     * * \"middle\"\r\n     * * \"end\"\r\n     *\r\n     * @param value  Alignment\r\n     */\n    set: function (value) {\n      this.setPropertyValue(\"textAlign\", value, true);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Label.prototype, \"textValign\", {\n    /**\r\n     * @ignore Exclude from docs (not used)\r\n     * @return Alignment\r\n     * @deprecated\r\n     */\n    get: function () {\n      return this.getPropertyValue(\"textValign\");\n    },\n\n    /**\r\n     * Vertical text alignment.\r\n     *\r\n     * @ignore Exclude from docs (not used)\r\n     * @param value  Alignment\r\n     * @deprecated\r\n     */\n    set: function (value) {\n      this.setPropertyValue(\"textValign\", value, true);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Label.prototype, \"html\", {\n    /**\r\n     * @return HTML content\r\n     */\n    get: function () {\n      return this.getPropertyValue(\"html\");\n    },\n\n    /**\r\n     * Raw HTML to be used as text.\r\n     *\r\n     * NOTE: HTML text is subject to browser support. It relies on browsers\r\n     * supporting SVG `foreignObject` nodes. Some browsers (read IEs) do not\r\n     * support it. On those browsers, the text will fall back to basic SVG text,\r\n     * striping out all HTML markup and styling that goes with it.\r\n     *\r\n     * For more information about `foreignObject` and its browser compatibility\r\n     * refer to [this page](https://developer.mozilla.org/en/docs/Web/SVG/Element/foreignObject#Browser_compatibility).\r\n     *\r\n     * @param value HTML text\r\n     */\n    set: function (value) {\n      this.setPropertyValue(\"html\", value, true);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Label.prototype, \"hideOversized\", {\n    /**\r\n     * @return Hide if text does not fit?\r\n     */\n    get: function () {\n      return this.getPropertyValue(\"hideOversized\");\n    },\n\n    /**\r\n     * Indicates whether the whole text should be hidden if it does not fit into\r\n     * its allotted space.\r\n     *\r\n     * @param value  Hide if text does not fit?\r\n     */\n    set: function (value) {\n      this.setPropertyValue(\"hideOversized\", value, true);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Label.prototype, \"ignoreFormatting\", {\n    /**\r\n     * @return Ignore formatting?\r\n     */\n    get: function () {\n      return this.getPropertyValue(\"ignoreFormatting\");\n    },\n\n    /**\r\n     * If set to `true` square-bracket formatting blocks will be treated as\r\n     * regular text.\r\n     *\r\n     * @default false\r\n     * @param value  Ignore formatting?\r\n     */\n    set: function (value) {\n      this.setPropertyValue(\"ignoreFormatting\", value, true);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\r\n   * Override `mesaureElement` so it does not get measure again, because\r\n   * internal `_bbox` is being updated by measuring routines in Text itself.\r\n   */\n\n  Label.prototype.measureElement = function () {};\n  /**\r\n   * Returns information about a line element.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param index  Line index\r\n   * @return Line info object\r\n   */\n\n\n  Label.prototype.getLineInfo = function (index) {\n    this.initLineCache();\n    var lines = this.getCache(\"lineInfo\");\n    return lines.length > index ? lines[index] : undefined;\n  };\n  /**\r\n   * Adds a line to line info cache.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param line     Line info object\r\n   * @param index    Insert at specified index\r\n   */\n\n\n  Label.prototype.addLineInfo = function (line, index) {\n    this.initLineCache();\n    this.getCache(\"lineInfo\")[index] = line;\n  };\n  /**\r\n   * Checks if line cache is initialized and initializes it.\r\n   */\n\n\n  Label.prototype.initLineCache = function () {\n    if (!$type.hasValue(this.getCache(\"lineInfo\"))) {\n      this.setCache(\"lineInfo\", [], 0);\n    }\n  };\n  /**\r\n   * Sets a [[DataItem]] to use for populating dynamic sections of the text.\r\n   *\r\n   * Check the description for [[Text]] class, for data binding.\r\n   *\r\n   * @param dataItem Data item\r\n   */\n\n\n  Label.prototype.setDataItem = function (dataItem) {\n    if (this._sourceDataItemEvents) {\n      this._sourceDataItemEvents.dispose();\n    }\n\n    if (dataItem) {\n      this._sourceDataItemEvents = new MultiDisposer([dataItem.events.on(\"valuechanged\", this.invalidate, this, false), dataItem.events.on(\"workingvaluechanged\", this.invalidate, this, false), dataItem.events.on(\"calculatedvaluechanged\", this.invalidate, this, false), dataItem.events.on(\"propertychanged\", this.invalidate, this, false)]);\n    }\n\n    _super.prototype.setDataItem.call(this, dataItem);\n  };\n\n  Object.defineProperty(Label.prototype, \"availableWidth\", {\n    /**\r\n     * Returns available horizontal space.\r\n     *\r\n     * @ignore Exclude from docs\r\n     * @return Available width (px)\r\n     */\n    get: function () {\n      return $type.hasValue(this.maxWidth) ? this.maxWidth : this.pixelWidth;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Label.prototype, \"availableHeight\", {\n    /**\r\n     * Returns available vertical space.\r\n     *\r\n     * @return Available height (px)\r\n     */\n    get: function () {\n      return $type.hasValue(this.maxHeight) ? this.maxHeight : this.pixelHeight;\n    },\n    enumerable: true,\n    configurable: true\n  }); // temp, replacing textFormatter method\n\n  Label.prototype.getSvgElement = function (text, style) {\n    var element = this.paper.add(\"tspan\");\n    element.textContent = text;\n\n    if (style) {\n      element.node.setAttribute(\"style\", style);\n    }\n\n    return element;\n  };\n  /**\r\n   * Invalidates the whole element, including layout AND all its child\r\n   * elements.\r\n   */\n\n\n  Label.prototype.deepInvalidate = function () {\n    _super.prototype.deepInvalidate.call(this);\n\n    this.hardInvalidate();\n  };\n\n  Object.defineProperty(Label.prototype, \"readerTitle\", {\n    /**\r\n     * @return Title\r\n     */\n    get: function () {\n      var title = this.getPropertyValue(\"readerTitle\");\n\n      if (!title) {\n        title = this.populateString($utils.plainText($utils.isNotEmpty(this.html) ? this.html : this.text));\n      }\n\n      return title;\n    },\n\n    /**\r\n     * Screen reader title of the element.\r\n     *\r\n     * @param value Title\r\n     */\n    set: function (value) {\n      value = $type.toText(value);\n\n      if (this.setPropertyValue(\"readerTitle\", value)) {\n        this.applyAccessibility();\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  return Label;\n}(Container);\n\nexport { Label };\n/**\r\n * Register class in system, so that it can be instantiated using its name from\r\n * anywhere.\r\n *\r\n * @ignore\r\n */\n\nregistry.registeredClasses[\"Label\"] = Label;\n/**\r\n * Add default responsive rules\r\n */\n\n/**\r\n * Hide labels added directly to chart, like titles if chart is short.\r\n */\n\ndefaultRules.push({\n  relevant: ResponsiveBreakpoints.heightXS,\n  state: function (target, stateId) {\n    if (target instanceof Label && target.parent && target.parent.isBaseSprite) {\n      var state = target.states.create(stateId);\n      state.properties.disabled = true;\n      return state;\n    }\n\n    return null;\n  }\n});","map":null,"metadata":{},"sourceType":"module"}