{"ast":null,"code":"/**\r\n * Provides functionality used to build scrollbars.\r\n */\nimport * as tslib_1 from \"tslib\";\n/**\r\n * ============================================================================\r\n * IMPORTS\r\n * ============================================================================\r\n * @hidden\r\n */\n\nimport { Container } from \"../Container\";\nimport { ResizeButton } from \"../elements/ResizeButton\";\nimport { Button } from \"../elements/Button\";\nimport { getInteraction } from \"../interaction/Interaction\";\nimport { MouseCursorStyle } from \"../interaction/Mouse\";\nimport { RoundedRectangle } from \"../elements/RoundedRectangle\";\nimport { registry } from \"../Registry\";\nimport { keyboard } from \"../utils/Keyboard\";\nimport { InterfaceColorSet } from \"../../core/utils/InterfaceColorSet\";\nimport { percent, Percent } from \"../utils/Percent\";\nimport * as $math from \"../utils/Math\";\nimport * as $ease from \"../utils/Ease\";\nimport * as $type from \"../utils/Type\";\nimport * as $utils from \"../utils/Utils\";\n;\n/**\r\n * ============================================================================\r\n * MAIN CLASS\r\n * ============================================================================\r\n * @hidden\r\n */\n\n/**\r\n * Scrollbar is a generic control allowing to select a range of values or pan\r\n * the selection.\r\n *\r\n * @see {@link IScrollbarEvents} for a list of available events\r\n * @see {@link IScrollbarAdapters} for a list of available Adapters\r\n */\n\nvar Scrollbar =\n/** @class */\nfunction (_super) {\n  tslib_1.__extends(Scrollbar, _super);\n  /**\r\n   * Construtor\r\n   */\n\n\n  function Scrollbar() {\n    var _this = _super.call(this) || this;\n    /**\r\n     * Previously selected lower (start) value.\r\n     */\n\n\n    _this._previousStart = 0;\n    /**\r\n     * Previously selected upper (end) value.\r\n     */\n\n    _this._previousEnd = 1;\n    /**\r\n     * A value of previously selected lower value, used for doubleclick function.\r\n     */\n\n    _this._prevStart = 0;\n    /**\r\n     * A value of previously selected upper value, used for doubleclick function.\r\n     */\n\n    _this._prevEnd = 1;\n    /**\r\n     * Indicates if the Scrollbar is currently \"busy\" (animating and or\r\n     * performing zoom by user interaction).\r\n     */\n\n    _this._isBusy = false;\n    /**\r\n     * [_skipRangeEvents description]\r\n     *\r\n     * @todo Description\r\n     */\n\n    _this._skipRangeEvents = false;\n    /**\r\n     * Update the selection when dragging the grips.\r\n     *\r\n     * If set to `false` selection will be updated only when the grip is\r\n     * released.\r\n     *\r\n     * @default true\r\n     */\n\n    _this.updateWhileMoving = true;\n    _this.className = \"Scrollbar\";\n    _this.minHeight = 12;\n    _this.minWidth = 12;\n    _this.animationDuration = 0;\n    _this.animationEasing = $ease.cubicOut;\n\n    _this.margin(10, 10, 10, 10);\n\n    var interfaceColors = new InterfaceColorSet(); // background is also container as it might contain graphs, grid, etc\n\n    var background = _this.background;\n    background.cornerRadius(10, 10, 10, 10);\n    background.fill = interfaceColors.getFor(\"fill\");\n    background.fillOpacity = 0.5; // Make system tooltips appear by default\n\n    _this.showSystemTooltip = true;\n    _this.startGrip = new ResizeButton();\n    _this.endGrip = new ResizeButton(); // Default orientation...\n    // ... is set in `applyInternalDefaults()` because it accesses `language`\n    // and should only be started to access when parent is set\n    // Set events\n\n    _this.events.on(\"transformed\", _this.updateThumb, _this, false); // Initial positions\n\n\n    _this.start = 0;\n    _this.end = 1; // Set roles\n\n    _this.role = \"scrollbar\";\n    _this.thumb.role = \"slider\";\n    _this.thumb.readerLive = \"polite\";\n    _this.startGrip.role = \"slider\";\n    _this.endGrip.role = \"slider\"; // otherwise range changed wont' be registered\n\n    _this.events.once(\"inited\", function () {\n      _this._previousStart = undefined;\n\n      _this.dispatchRangeChange();\n    }, undefined, false);\n\n    _this.hideGrips = false;\n    _this.orientation = \"horizontal\";\n\n    _this.applyTheme();\n\n    return _this;\n  }\n  /**\r\n   * Sets defaults that instantiate some objects that rely on parent, so they\r\n   * cannot be set in constructor.\r\n   */\n\n\n  Scrollbar.prototype.applyInternalDefaults = function () {\n    _super.prototype.applyInternalDefaults.call(this); // Set screen reader tetxt accordingly\n\n\n    if (this.orientation === \"horizontal\") {\n      if (!$type.hasValue(this.readerTitle)) {\n        this.readerTitle = this.language.translate(\"Use TAB to select grip buttons or left and right arrows to change selection\");\n      }\n\n      if (!$type.hasValue(this.thumb.readerDescription)) {\n        this.thumb.readerDescription = this.language.translate(\"Use left and right arrows to move selection\");\n      }\n\n      if (!$type.hasValue(this.startGrip.readerDescription)) {\n        this.startGrip.readerDescription = this.language.translate(\"Use left and right arrows to move left selection\");\n      }\n\n      if (!$type.hasValue(this.endGrip.readerDescription)) {\n        this.endGrip.readerDescription = this.language.translate(\"Use left and right arrows to move right selection\");\n      }\n    } else {\n      if (!$type.hasValue(this.readerTitle)) {\n        this.readerTitle = this.language.translate(\"Use TAB select grip buttons or up and down arrows to change selection\");\n      }\n\n      if (!$type.hasValue(this.thumb.readerDescription)) {\n        this.thumb.readerDescription = this.language.translate(\"Use up and down arrows to move selection\");\n      }\n\n      if (!$type.hasValue(this.startGrip.readerDescription)) {\n        this.startGrip.readerDescription = this.language.translate(\"Use up and down arrows to move upper selection\");\n      }\n\n      if (!$type.hasValue(this.endGrip.readerDescription)) {\n        this.endGrip.readerDescription = this.language.translate(\"Use up and down arrows to move lower selection\");\n      }\n    }\n  };\n  /**\r\n   * Validates the layout of the scrollbar's elements.\r\n   *\r\n   * @ignore Exclude from docs\r\n   */\n\n\n  Scrollbar.prototype.validateLayout = function () {\n    this.updateSize();\n\n    _super.prototype.validateLayout.call(this); // when size changes, need to update extremes\n\n\n    this.updateExtremes();\n  };\n  /**\r\n   * Update background for the scrollbar.\r\n   *\r\n   * @ignore Exclude from docs\r\n   */\n\n\n  Scrollbar.prototype.processBackground = function () {\n    _super.prototype.processBackground.call(this);\n\n    var background = this.background;\n    background.clickable = true;\n    background.events.on(\"hit\", this.handleBgHit, this, undefined);\n  };\n  /**\r\n   * Zooms to the particular place when clicked/tapped on the scrollbar\r\n   * background.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param event  Event\r\n   */\n\n\n  Scrollbar.prototype.handleBgHit = function (event) {\n    this.makeBusy();\n    var point = event.spritePoint;\n    point = $utils.spritePointToSprite(point, this.background, this);\n    var thumb = this.thumb;\n\n    if (this.orientation == \"horizontal\") {\n      var thumbX = point.x - thumb.pixelWidth / 2;\n      thumbX = $math.fitToRange(thumbX, 0, this.innerWidth - thumb.pixelWidth);\n      this._thumbAnimation = thumb.animate({\n        property: \"x\",\n        to: thumbX\n      }, this.animationDuration, this.animationEasing);\n    } else {\n      var thumbY = point.y - thumb.pixelHeight / 2;\n      thumbY = $math.fitToRange(thumbY, 0, this.innerHeight - thumb.pixelHeight);\n      this._thumbAnimation = thumb.animate({\n        property: \"y\",\n        to: thumbY\n      }, this.animationDuration, this.animationEasing);\n    }\n\n    if (this.animationDuration > 0) {\n      this._thumbAnimation.events.on(\"animationended\", this.makeUnbusy, this, false);\n    } else {\n      this._thumb.validate();\n\n      this.makeUnbusy();\n    }\n  };\n  /**\r\n   * Set scrollbar as busy. (currently zooming)\r\n   *\r\n   * @ignore Exclude from docs\r\n   */\n\n\n  Scrollbar.prototype.makeBusy = function () {\n    this._isBusy = true;\n    this._skipRangeEvents = false;\n\n    if (this._unbusyTimeout) {\n      this.removeDispose(this._unbusyTimeout);\n    }\n\n    this._unbusyTimeout = undefined;\n    this.stopAnimations();\n  };\n  /**\r\n   * Stops all animations, currently playing for the scrollbar.\r\n   *\r\n   * @ignore Exclude from docs\r\n   */\n\n\n  Scrollbar.prototype.stopAnimations = function () {\n    if (this._thumbAnimation) {\n      this._thumbAnimation.stop(true);\n    }\n\n    if (this._zoomAnimation) {\n      this._zoomAnimation.stop(true);\n    }\n  };\n  /**\r\n   * Cancels \"busy\" status of the Scrollbar.\r\n   *\r\n   * @ignore Exclude from docs\r\n   */\n\n\n  Scrollbar.prototype.makeUnbusy = function () {\n    /**\r\n     * We cannot make Scrollbar not busy right after release, because then axes\r\n     * will take over controll and Scrollbar will start to animate.\r\n     * Theorethically, it's not right to set timeout by `animationDuration`,\r\n     * however we can not know all the durations of elements we scroll, so we\r\n     * assume that animation duration will be the same as\r\n     * `interpolationDuration` or `rangeChange` duration.\r\n     */\n    this._unbusyTimeout = this.setTimeout(this.makeUnbusyReal.bind(this), this.animationDuration * 1.1);\n  };\n  /**\r\n   * [makeUnbusyReal description]\r\n   *\r\n   * @todo Description\r\n   * @ignore Exclude from docs\r\n   */\n\n\n  Scrollbar.prototype.makeUnbusyReal = function () {\n    this._usingGrip = undefined;\n    this._isBusy = false;\n\n    if (!this.updateWhileMoving) {\n      this.dispatchRangeChange();\n    }\n  };\n  /**\r\n   * Disptatches rangechanged event if it really changed\r\n   *\r\n   * @ignore Exclude from docs\r\n   */\n\n\n  Scrollbar.prototype.dispatchRangeChange = function () {\n    if (this._previousEnd != this.end || this._previousStart != this.start) {\n      this._previousStart = this.start;\n      this._previousEnd = this.end;\n      this.dispatch(\"rangechanged\");\n    }\n  };\n  /**\r\n   * Updates the \"thumb\" element. A draggable element between the grips.\r\n   */\n\n\n  Scrollbar.prototype.updateThumb = function () {\n    if (!this.parent) {\n      return;\n    }\n\n    var thumb = this.thumb;\n    var start = this.start;\n    var end = this.end;\n    var startGrip = this.startGrip;\n    var endGrip = this.endGrip;\n\n    if (this.orientation == \"horizontal\") {\n      var innerWidth_1 = this.innerWidth;\n      thumb.width = innerWidth_1 * (end - start);\n      thumb.maxX = innerWidth_1 - thumb.pixelWidth;\n      thumb.x = start * innerWidth_1;\n      startGrip.moveTo({\n        x: thumb.pixelX,\n        y: 0\n      }, undefined, undefined, true); // overrides dragging\n\n      endGrip.moveTo({\n        x: thumb.pixelX + thumb.pixelWidth,\n        y: 0\n      }, undefined, undefined, true);\n      startGrip.readerTitle = this.language.translate(\"From %1\", undefined, this.adapter.apply(\"positionValue\", {\n        value: Math.round(start * 100) + \"%\",\n        position: start\n      }).value);\n      endGrip.readerTitle = this.language.translate(\"To %1\", undefined, this.adapter.apply(\"positionValue\", {\n        value: Math.round(end * 100) + \"%\",\n        position: end\n      }).value);\n    } else {\n      var innerHeight_1 = this.innerHeight;\n      thumb.height = innerHeight_1 * (end - start);\n      thumb.maxY = innerHeight_1 - thumb.pixelHeight;\n      thumb.y = (1 - end) * innerHeight_1;\n      startGrip.moveTo({\n        x: 0,\n        y: thumb.pixelY + thumb.pixelHeight\n      }, undefined, undefined, true);\n      endGrip.moveTo({\n        x: 0,\n        y: thumb.pixelY\n      }, undefined, undefined, true);\n      startGrip.readerTitle = this.language.translate(\"To %1\", undefined, this.adapter.apply(\"positionValue\", {\n        value: Math.round((1 - start) * 100) + \"%\",\n        position: 1 - start\n      }).value);\n      endGrip.readerTitle = this.language.translate(\"From %1\", undefined, this.adapter.apply(\"positionValue\", {\n        value: Math.round((1 - end) * 100) + \"%\",\n        position: 1 - end\n      }).value);\n    } // Add accessibility\n\n\n    thumb.readerTitle = this.language.translate(\"From %1 to %2\", undefined, this.adapter.apply(\"positionValue\", {\n      value: Math.round(start * 100) + \"%\",\n      position: start\n    }).value, this.adapter.apply(\"positionValue\", {\n      value: Math.round(end * 100) + \"%\",\n      position: end\n    }).value);\n\n    if (!this._skipRangeEvents && this.updateWhileMoving) {\n      this.dispatchRangeChange();\n    }\n  };\n  /**\r\n   * Updates extremes of the scrollbar.\r\n   */\n\n\n  Scrollbar.prototype.updateExtremes = function () {\n    var orientation = this.orientation;\n    var minX = 0;\n    var minY = 0;\n    var maxX = 0;\n    var maxY = 0;\n\n    if (orientation == \"horizontal\") {\n      maxX = this.innerWidth;\n      minY = maxY = this.innerHeight / 2;\n    } else {\n      maxY = this.innerHeight;\n      minX = maxX = this.innerWidth / 2;\n    }\n\n    var startGrip = this.startGrip;\n    startGrip.minX = minX;\n    startGrip.maxX = maxX;\n    startGrip.minY = minY;\n    startGrip.maxY = maxY;\n    var endGrip = this.endGrip;\n    endGrip.minX = minX;\n    endGrip.maxX = maxX;\n    endGrip.minY = minY;\n    endGrip.maxY = maxY;\n    var thumb = this.thumb;\n    thumb.minX = minX;\n    thumb.maxX = maxX;\n    thumb.minY = minY;\n    thumb.maxY = maxY;\n  };\n  /**\r\n   * Updates size of the scrollbar.\r\n   */\n\n\n  Scrollbar.prototype.updateSize = function () {\n    var orientation = this.orientation;\n    var startGrip = this.startGrip;\n\n    if (startGrip) {\n      startGrip.orientation = orientation;\n    }\n\n    if (this.endGrip) {\n      this.endGrip.orientation = orientation;\n    }\n\n    var thumb = this.thumb;\n\n    if (thumb) {\n      if (orientation == \"horizontal\") {\n        if (!$type.isNumber(this._pixelWidth)) {\n          if (!(this.width instanceof Percent)) {\n            this.width = percent(100);\n          }\n        } // this teorethically might be wrong, if user indeed sets height of a horizontal scrollbar in percent\n        // however without this height might be equal to 100% if previous orientation was set to horizontal\n        // so this is ok solution, in case user really wants to have scrollbar height set in percent,\n        // he should do this after orientation.\n\n\n        if ($type.hasValue(this.percentHeight)) {\n          this.height = this.minHeight;\n        }\n\n        thumb.height = this.innerHeight;\n        thumb.verticalCenter = \"middle\";\n        thumb.horizontalCenter = \"left\";\n      } else {\n        if (!$type.isNumber(this._pixelHeight)) {\n          if (!(this.height instanceof Percent)) {\n            this.height = percent(100);\n          }\n        } // same as above with percentHeight\n\n\n        if ($type.hasValue(this.percentWidth)) {\n          this.width = this.minWidth;\n        }\n\n        thumb.width = this.innerWidth;\n        thumb.verticalCenter = \"top\";\n        thumb.horizontalCenter = \"middle\";\n      }\n    }\n  };\n\n  Object.defineProperty(Scrollbar.prototype, \"start\", {\n    /**\r\n     * @return Position (0-1)\r\n     */\n    get: function () {\n      return Math.min(this.getPosition(this._start), this.getPosition(this._end));\n    },\n\n    /**\r\n     * ==========================================================================\r\n     * POSITIONS\r\n     * ==========================================================================\r\n     * @hidden\r\n     */\n\n    /**\r\n     * Relative position (0-1) of the start grip.\r\n     *\r\n     * @param position  Position (0-1)\r\n     */\n    set: function (position) {\n      if (!this._isBusy) {\n        this.__start = position;\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Scrollbar.prototype, \"__start\", {\n    /**\r\n     * @return [description]\r\n     */\n    get: function () {\n      return this._start;\n    },\n\n    /**\r\n     * [__start description]\r\n     *\r\n     * @todo Description\r\n     * @param position [description]\r\n     */\n    set: function (position) {\n      this._start = this.getPosition(position);\n      this.updateThumb();\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Scrollbar.prototype, \"end\", {\n    /**\r\n     * @return Position (0-1)\r\n     */\n    get: function () {\n      return Math.max(this.getPosition(this._start), this.getPosition(this._end));\n    },\n\n    /**\r\n     * Relative position (0-1) of the end grip.\r\n     *\r\n     * @param position  Position (0-1)\r\n     */\n    set: function (position) {\n      if (!this._isBusy) {\n        this.__end = position;\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Scrollbar.prototype, \"__end\", {\n    /**\r\n     * @return [description]\r\n     */\n    get: function () {\n      return this._end;\n    },\n\n    /**\r\n     * [__end description]\r\n     *\r\n     * @todo Description\r\n     * @param position [description]\r\n     */\n    set: function (position) {\n      this._end = this.getPosition(position);\n      this.updateThumb();\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Scrollbar.prototype, \"range\", {\n    /**\r\n     * Current selection range.\r\n     *\r\n     * @readonly\r\n     * @return Range\r\n     */\n    get: function () {\n      return {\n        start: this.start,\n        end: this.end,\n        priority: this._usingGrip\n      };\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\r\n   * Disables range change events.\r\n   *\r\n   * @ignore Exclude from docs\r\n   */\n\n  Scrollbar.prototype.skipRangeEvents = function () {\n    if (!this._isBusy) {\n      this._skipRangeEvents = true;\n    }\n  };\n  /**\r\n   * [fixRange description]\r\n   *\r\n   * @todo Description\r\n   * @ignore Exclude from docs\r\n   * @param range  Range\r\n   */\n\n\n  Scrollbar.prototype.fixRange = function (range) {\n    if (range.start != $math.round(this._start, 2) || range.end != $math.round(this._end, 2)) {\n      this._start = range.start;\n      this._end = range.end;\n      this._skipRangeEvents = true;\n      this.updateThumb();\n      this._skipRangeEvents = false;\n      this.thumb.validate();\n      this.thumb.background.validate();\n    }\n  };\n  /**\r\n   * [getPosition description]\r\n   *\r\n   * @todo Description\r\n   * @param position  [description]\r\n   * @return [description]\r\n   */\n\n\n  Scrollbar.prototype.getPosition = function (position) {\n    return $math.fitToRange($math.round(position, 4), 0, 1);\n  };\n\n  Object.defineProperty(Scrollbar.prototype, \"orientation\", {\n    /**\r\n     * @return Orientation\r\n     */\n    get: function () {\n      return this.getPropertyValue(\"orientation\");\n    },\n\n    /**\r\n     * ==========================================================================\r\n     * MISC\r\n     * ==========================================================================\r\n     * @hidden\r\n     */\n\n    /**\r\n     * Orientation of the scrollbar.\r\n     *\r\n     * Available options: \"horizontal\" (default) and \"vertical\".\r\n     *\r\n     * @default \"horizontal\"\r\n     * @param value  Orientation\r\n     */\n    set: function (value) {\n      if (this.setPropertyValue(\"orientation\", value)) {\n        // Set mouse cursors and screen reader tetxt accordingly\n        if (value === \"horizontal\") {\n          // Mouse styles\n          this.startGrip.cursorOverStyle = MouseCursorStyle.horizontalResize;\n          this.endGrip.cursorOverStyle = MouseCursorStyle.horizontalResize; // Reader text\n\n          /*this.readerTitle = this.language.translate(\"Use TAB to select grip buttons or left and right arrows to change selection\");\r\n          this.thumb.readerDescription = this.language.translate(\"Use left and right arrows to move selection\");\r\n          this.startGrip.readerDescription = this.language.translate(\"Use left and right arrows to move left selection\");\r\n          this.endGrip.readerDescription = this.language.translate(\"Use left and right arrows to move right selection\");*/\n        } else {\n          // Mouse styles\n          this.startGrip.cursorOverStyle = MouseCursorStyle.verticalResize;\n          this.endGrip.cursorOverStyle = MouseCursorStyle.verticalResize; // Reader text\n\n          /*this.readerTitle = this.language.translate(\"Use TAB select grip buttons or up and down arrows to change selection\");\r\n          this.thumb.readerDescription = this.language.translate(\"Use up and down arrows to move selection\");\r\n          this.startGrip.readerDescription = this.language.translate(\"Use up and down arrows to move upper selection\");\r\n          this.endGrip.readerDescription = this.language.translate(\"Use up and down arrows to move lower selection\");*/\n        }\n\n        this.updateByOrientation();\n        this.invalidate();\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\r\n   * @ignore\r\n   */\n\n  Scrollbar.prototype.updateByOrientation = function () {};\n\n  Object.defineProperty(Scrollbar.prototype, \"startGrip\", {\n    /**\r\n     * @return Grip element\r\n     */\n    get: function () {\n      return this._startGrip;\n    },\n\n    /**\r\n     * ==========================================================================\r\n     * GRIPS\r\n     * ==========================================================================\r\n     * @hidden\r\n     */\n\n    /**\r\n     * Start grip element. (button)\r\n     *\r\n     * @param button  Grip element\r\n     */\n    set: function (button) {\n      if (this._startGrip) {\n        this.removeDispose(this._startGrip);\n      }\n\n      this._startGrip = button;\n      this.processGrip(button);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Scrollbar.prototype, \"endGrip\", {\n    /**\r\n     * @return Grip element\r\n     */\n    get: function () {\n      return this._endGrip;\n    },\n\n    /**\r\n     * End grip element. (button)\r\n     *\r\n     * @param button  Grip element\r\n     */\n    set: function (button) {\n      if (this._endGrip) {\n        this.removeDispose(this._endGrip);\n      }\n\n      this._endGrip = button;\n      this.processGrip(button);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\r\n   * Decorates the grip button with properties and events.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param button Grip button\r\n   */\n\n  Scrollbar.prototype.processGrip = function (button) {\n    button.parent = this;\n    button.isMeasured = false;\n    button.focusable = true;\n    button.shouldClone = false; // Set button defaults\n    //button.showSystemTooltip = true; // setting this here is not right because we break inheritance\n\n    button.zIndex = 100;\n    button.events.on(\"drag\", this.handleGripDrag, this, false);\n    button.events.on(\"dragstop\", this.makeUnbusy, this, false);\n    button.events.on(\"down\", this.makeBusy, this, false);\n\n    this._disposers.push(button);\n  };\n  /**\r\n   * Updates positions of related elements after grip element is dragged.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param event  Event\r\n   */\n\n\n  Scrollbar.prototype.handleGripDrag = function (event) {\n    this.makeBusy();\n\n    if (event.target === this._startGrip) {\n      this._usingGrip = \"start\";\n    } else {\n      this._usingGrip = \"end\";\n    }\n\n    if (this.orientation == \"horizontal\") {\n      this._start = this.startGrip.pixelX / this.innerWidth;\n      this._end = this.endGrip.pixelX / this.innerWidth;\n    } else {\n      this._start = 1 - this.startGrip.pixelY / this.innerHeight;\n      this._end = 1 - this.endGrip.pixelY / this.innerHeight;\n    }\n\n    this.updateThumb();\n  };\n\n  Object.defineProperty(Scrollbar.prototype, \"thumb\", {\n    /**\r\n     * @return Thumb element\r\n     */\n    get: function () {\n      if (!this._thumb) {\n        // Create scrollbar controls (setters will handle adding disposers)\n        var thumb = new Button();\n        thumb.background.cornerRadius(10, 10, 10, 10);\n        thumb.padding(0, 0, 0, 0);\n        this.thumb = thumb;\n      }\n\n      return this._thumb;\n    },\n\n    /**\r\n     * A \"thumb\" element.\r\n     *\r\n     * It's a draggable square space between the grips, that can be used to\r\n     * pan the selection.\r\n     *\r\n     * @param thumb  Thumb element\r\n     */\n    set: function (thumb) {\n      var _this = this;\n\n      if (thumb) {\n        if (this._thumb) {\n          this.removeDispose(this._thumb);\n        }\n\n        this._thumb = thumb;\n        thumb.parent = this;\n        thumb.isMeasured = false;\n        thumb.inert = true;\n        thumb.draggable = true;\n        thumb.clickable = true;\n        thumb.hoverable = true;\n        thumb.focusable = true;\n        thumb.shouldClone = false;\n        thumb.zIndex = 0; // TODO remove closures ?\n        // Add events\n        // Add cursor styles to thumb\n\n        thumb.cursorOverStyle = MouseCursorStyle.grab;\n        thumb.cursorDownStyle = MouseCursorStyle.grabbing;\n        thumb.events.on(\"dragstart\", this.makeBusy, this, false);\n        thumb.events.on(\"dragstop\", this.makeUnbusy, this, false);\n        thumb.events.on(\"positionchanged\", this.handleThumbPosition, this, false);\n        thumb.events.on(\"sizechanged\", this.handleThumbPosition, this, false);\n        thumb.events.on(\"doublehit\", this.handleDoubleClick, this, false); // Add event for space and ENTER to toggle full zoom out and back\n        // (same as doubleclick)\n\n        this._disposers.push(getInteraction().body.events.on(\"keyup\", function (ev) {\n          if (keyboard.isKey(ev.event, [\"space\", \"enter\"]) && _this.thumb.isFocused) {\n            ev.event.preventDefault();\n\n            _this.handleDoubleClick();\n          }\n        }));\n\n        this._disposers.push(this._thumb);\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\r\n   * Zooms-in and out the selection on double-click of the thumb.\r\n   *\r\n   * @ignore Exclude from docs\r\n   */\n\n  Scrollbar.prototype.handleDoubleClick = function () {\n    this.makeBusy();\n    var newStart = 0;\n    var newEnd = 1;\n\n    if (this.start != 0 || this.end != 1) {\n      this._prevStart = this.start;\n      this._prevEnd = this.end;\n    } else {\n      newStart = this._prevStart;\n      newEnd = this._prevEnd;\n    }\n\n    var zoomAnimation = this.animate([{\n      property: \"__start\",\n      to: newStart\n    }, {\n      property: \"__end\",\n      to: newEnd\n    }], this.animationDuration, this.animationEasing);\n\n    if (zoomAnimation && !zoomAnimation.isFinished()) {\n      zoomAnimation.events.on(\"animationended\", this.makeUnbusy, this, false);\n      this._zoomAnimation = zoomAnimation;\n    } else {\n      this.makeUnbusy();\n    }\n  };\n  /**\r\n   * Updates positions of other elements when thumb is moved.\r\n   *\r\n   * @ignore Exclude from docs\r\n   */\n\n\n  Scrollbar.prototype.handleThumbPosition = function () {\n    var thumb = this.thumb;\n\n    if (this.orientation == \"horizontal\") {\n      var innerWidth_2 = this.innerWidth;\n      var w = thumb.innerWidth;\n      var x = thumb.pixelX;\n      this._start = x / innerWidth_2;\n      this._end = (x + w) / innerWidth_2;\n      this.updateThumb();\n    } else {\n      var innerHeight_2 = this.innerHeight;\n      var h = thumb.innerHeight;\n      var y = thumb.pixelY;\n      this._start = 1 - (y + h) / innerHeight_2;\n      this._end = 1 - y / innerHeight_2;\n      this.updateThumb();\n    }\n  };\n  /**\r\n   * Creates a background element for the scrollbar.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @return Background\r\n   */\n\n\n  Scrollbar.prototype.createBackground = function () {\n    return new RoundedRectangle();\n  };\n\n  Object.defineProperty(Scrollbar.prototype, \"hideGrips\", {\n    /**\r\n     * @return Show only on hover?\r\n     */\n    get: function () {\n      return this._hideGrips;\n    },\n\n    /**\r\n     * Use this property to set whether grips should be always visible (`false`),\r\n     * or they should just appear on scrollbar hover (`true`).\r\n     *\r\n     * @param value  Show only on hover?\r\n     */\n    set: function (value) {\n      var _this = this;\n\n      this._hideGrips = value;\n\n      if (this._overDisposer) {\n        this.removeDispose(this._overDisposer);\n      }\n\n      if (this._outDisposer) {\n        this.removeDispose(this._outDisposer);\n      }\n\n      if (value) {\n        this._overDisposer = this.events.on(\"over\", function () {\n          _this.startGrip.show();\n\n          _this.endGrip.show();\n        }, undefined, false);\n        this._outDisposer = this.events.on(\"out\", function () {\n          _this.startGrip.hide();\n\n          _this.endGrip.hide();\n        }, undefined, false);\n        this.startGrip.hide();\n        this.endGrip.hide();\n      } else {\n        this.startGrip.show();\n        this.endGrip.show();\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Scrollbar.prototype, \"animationDuration\", {\n    /**\r\n     * @return Orientation\r\n     */\n    get: function () {\n      return this.getPropertyValue(\"animationDuration\");\n    },\n\n    /**\r\n     * Duration in milliseconds of scrollbar animation (happens when user clicks on a background of a scrollbar)\r\n     * @default 0\r\n     * @param value number\r\n     */\n    set: function (value) {\n      this.setPropertyValue(\"animationDuration\", value);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Scrollbar.prototype, \"animationEasing\", {\n    /**\r\n     * @return {Function}\r\n     */\n    get: function () {\n      return this.getPropertyValue(\"animationEasing\");\n    },\n\n    /**\r\n     * Animation easing function.\r\n     * @todo: review description and default\r\n     * @default $ease.cubicOut\r\n     * @param value (value: number) => number\r\n     */\n    set: function (value) {\n      this.setPropertyValue(\"animationEasing\", value);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\r\n   * Adds easing functions to \"function\" fields.\r\n   *\r\n   * @param field  Field name\r\n   * @return Assign as function?\r\n   */\n\n  Scrollbar.prototype.asFunction = function (field) {\n    return field == \"animationEasing\" || _super.prototype.asIs.call(this, field);\n  };\n\n  return Scrollbar;\n}(Container);\n\nexport { Scrollbar };\n/**\r\n * Register class in system, so that it can be instantiated using its name from\r\n * anywhere.\r\n *\r\n * @ignore\r\n */\n\nregistry.registeredClasses[\"Scrollbar\"] = Scrollbar;","map":null,"metadata":{},"sourceType":"module"}