{"ast":null,"code":"/**\r\n * Number formatting-related functionality.\r\n */\nimport * as tslib_1 from \"tslib\";\nimport { Language } from \"../utils/Language\";\nimport { BaseObject } from \"../Base\";\nimport { getTextFormatter } from \"../formatters/TextFormatter\";\nimport { registry } from \"../Registry\";\nimport * as $strings from \"../utils/Strings\";\nimport * as $object from \"../utils/Object\";\nimport * as $utils from \"../utils/Utils\";\nimport * as $type from \"../utils/Type\";\n/**\r\n * NumberFormatter class. Formats numbers according to specified formats.\r\n *\r\n * @todo Apply translations to suffixes/prefixes\r\n */\n\nvar NumberFormatter =\n/** @class */\nfunction (_super) {\n  tslib_1.__extends(NumberFormatter, _super);\n  /**\r\n   * Constructor\r\n   */\n\n\n  function NumberFormatter() {\n    var _this = _super.call(this) || this;\n    /**\r\n     * A base value for negative numbers. Will treat all numbers below this value\r\n     * as negative numbers.\r\n     */\n\n\n    _this._negativeBase = 0;\n    /**\r\n     * Holds number format.\r\n     *\r\n     * @default #,###.#####\r\n     */\n\n    _this._numberFormat = \"#,###.#####\";\n    /**\r\n     * Output format to produce. If the format calls for applying color to the\r\n     * formatted value, this setting will determine what markup to use: SVG or\r\n     * HTML.\r\n     *\r\n     * Available options: svg, html.\r\n     *\r\n     * @default \"svg\"\r\n     */\n\n    _this._outputFormat = \"svg\";\n    /**\r\n     * Any number smaller than this will be considered \"small\" number, which will\r\n     * trigger special formatting if \"a\" format modifier is used.\r\n     */\n\n    _this._smallNumberThreshold = 1.00;\n    _this.className = \"NumberFormatter\";\n\n    _this.applyTheme();\n\n    return _this;\n  }\n\n  NumberFormatter.prototype.dispose = function () {\n    _super.prototype.dispose.call(this);\n\n    if (this.language) {\n      this.language.dispose();\n    }\n  };\n\n  Object.defineProperty(NumberFormatter.prototype, \"language\", {\n    /**\r\n     * @return Language\r\n     */\n    get: function () {\n      if (!this._language) {\n        if (this.sprite) {\n          this._language = this.sprite.language;\n        } else {\n          this._language = new Language();\n        }\n      }\n\n      return this._language;\n    },\n\n    /**\r\n     * A reference to [[Language]] instance.\r\n     *\r\n     * Formatter will use language to translate various items, like number\r\n     * suffixes, etc.\r\n     *\r\n     * @param value  Language\r\n     */\n    set: function (value) {\n      this._language = value;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\r\n   * Formats the number according to specific format.\r\n   *\r\n   * @param value   Value to format\r\n   * @param format  Format to apply\r\n   * @return Formatted number\r\n   */\n\n  NumberFormatter.prototype.format = function (value, format) {\n    // no format passed in or \"Number\"\n    if (typeof format === \"undefined\" || $type.isString(format) && format.toLowerCase() === \"number\") {\n      format = this._numberFormat;\n    } // Init return value\n\n\n    var formatted; // Cast to number just in case\n    // TODO: maybe use better casting\n\n    var source = Number(value); // Is it a built-in format or Intl.NumberFormatOptions\n\n    if (format instanceof Object) {\n      if (this.intlLocales) {\n        return new Intl.NumberFormat(this.intlLocales, format).format(source);\n      } else {\n        return new Intl.NumberFormat(undefined, format).format(source);\n      }\n    } else {\n      // Clean format\n      format = $utils.cleanFormat(format); // Get format info (it will also deal with parser caching)\n\n      var info = this.parseFormat(format, this.language); // format and replace the number\n\n      var details = void 0;\n\n      if (source > this._negativeBase) {\n        details = info.positive;\n      } else if (source < this._negativeBase) {\n        details = info.negative;\n      } else {\n        details = info.zero;\n      } // Format\n\n\n      formatted = details.template.split($strings.PLACEHOLDER).join(this.applyFormat(source, details));\n    }\n\n    return formatted;\n  };\n  /**\r\n   * Parses supplied format into structured object which can be used to format\r\n   * the number.\r\n   *\r\n   * @param format Format string, i.e. \"#,###.00\"\r\n   * @param language Language\r\n   */\n\n\n  NumberFormatter.prototype.parseFormat = function (format, language) {\n    var _this = this; // Check cache\n\n\n    var cached = this.getCache(format);\n\n    if ($type.hasValue(cached)) {\n      return cached;\n    } // init format parse info holder\n\n\n    var info = {\n      \"positive\": {\n        \"thousands\": {\n          \"active\": -1,\n          \"passive\": -1,\n          \"interval\": -1,\n          \"separator\": language.translateEmpty(\"_thousandSeparator\")\n        },\n        \"decimals\": {\n          \"active\": -1,\n          \"passive\": -1,\n          \"separator\": language.translateEmpty(\"_decimalSeparator\")\n        },\n        \"template\": \"\",\n        \"source\": \"\",\n        \"parsed\": false\n      },\n      \"negative\": {\n        \"thousands\": {\n          \"active\": -1,\n          \"passive\": -1,\n          \"interval\": -1,\n          \"separator\": language.translateEmpty(\"_thousandSeparator\")\n        },\n        \"decimals\": {\n          \"active\": -1,\n          \"passive\": -1,\n          \"separator\": language.translateEmpty(\"_decimalSeparator\")\n        },\n        \"template\": \"\",\n        \"source\": \"\",\n        \"parsed\": false\n      },\n      \"zero\": {\n        \"thousands\": {\n          \"active\": -1,\n          \"passive\": -1,\n          \"interval\": -1,\n          \"separator\": language.translateEmpty(\"_thousandSeparator\")\n        },\n        \"decimals\": {\n          \"active\": -1,\n          \"passive\": -1,\n          \"separator\": language.translateEmpty(\"_decimalSeparator\")\n        },\n        \"template\": \"\",\n        \"source\": \"\",\n        \"parsed\": false\n      }\n    }; // Escape double vertical bars (that mean display one vertical bar)\n\n    format = format.replace(\"||\", $strings.PLACEHOLDER2); // Split it up and deal with different formats\n\n    var parts = format.split(\"|\");\n    info.positive.source = parts[0];\n\n    if (typeof parts[2] === \"undefined\") {\n      info.zero = info.positive;\n    } else {\n      info.zero.source = parts[2];\n    }\n\n    if (typeof parts[1] === \"undefined\") {\n      info.negative = info.positive;\n    } else {\n      info.negative.source = parts[1];\n    } // Parse each\n\n\n    $object.each(info, function (part, item) {\n      // Already parsed\n      if (item.parsed) {\n        return;\n      } // Check cached\n\n\n      if (typeof _this.getCache(item.source) !== \"undefined\") {\n        info[part] = _this.getCache(item.source);\n        return;\n      } // Begin parsing\n\n\n      var partFormat = item.source; // Just \"Number\"?\n\n      if (partFormat.toLowerCase() === \"number\") {\n        partFormat = $type.isString(_this._numberFormat) ? _this._numberFormat : \"#,###.#####\";\n      } // Let TextFormatter split into chunks\n\n\n      var chunks = getTextFormatter().chunk(partFormat, true);\n\n      for (var i = 0; i < chunks.length; i++) {\n        var chunk = chunks[i]; // replace back double vertical bar\n\n        chunk.text = chunk.text.replace($strings.PLACEHOLDER2, \"|\");\n\n        if (chunk.type === \"value\") {\n          // Parse format\n          // Look for codes\n          var matches = chunk.text.match(/[#0.,]+[ ]?[abesABES%!]?[abesABES‰!]?/);\n\n          if (matches) {\n            if (matches === null || matches[0] === \"\") {\n              // no codes here - assume string\n              // nothing to do here\n              item.template += chunk.text;\n            } else {\n              // look for the format modifiers at the end\n              var mods = matches[0].match(/[abesABES%‰!]{2}|[abesABES%‰]{1}$/);\n\n              if (mods) {\n                item.mod = mods[0].toLowerCase();\n                item.modSpacing = matches[0].match(/[ ]{1}[abesABES%‰!]{1}$/) ? true : false;\n              } // break the format up\n\n\n              var a = matches[0].split(\".\"); // Deal with thousands\n\n              if (a[0] === \"\") {// No directives for thousands\n                // Leave default settings (no formatting)\n              } else {\n                // Counts\n                item.thousands.active = (a[0].match(/0/g) || []).length;\n                item.thousands.passive = (a[0].match(/\\#/g) || []).length + item.thousands.active; // Separator interval\n\n                var b = a[0].split(\",\");\n\n                if (b.length === 1) {// No thousands separators\n                  // Do nothing\n                } else {\n                  // Use length fo the last chunk as thousands length\n                  item.thousands.interval = $type.getValue(b.pop()).length;\n\n                  if (item.thousands.interval === 0) {\n                    item.thousands.interval = -1;\n                  }\n                }\n              } // Deal with decimals\n\n\n              if (typeof a[1] === \"undefined\") {// No directives for decimals\n                // Leave at defaults (no formatting)\n              } else {\n                // Counts\n                item.decimals.active = (a[1].match(/0/g) || []).length;\n                item.decimals.passive = (a[1].match(/\\#/g) || []).length + item.decimals.active;\n              } // Add special code to template\n\n\n              item.template += chunk.text.split(matches[0]).join($strings.PLACEHOLDER);\n            }\n          }\n        } else {\n          // Quoted string - take it as it is\n          item.template += chunk.text;\n        }\n      } // Apply style formatting\n      //item.template = getTextFormatter().format(item.template, this.outputFormat);\n      // Save cache\n\n\n      _this.setCache(item.source, item); // Mark this as parsed\n\n\n      item.parsed = true;\n    }); // Save cache (the whole thing)\n\n    this.setCache(format, info);\n    return info;\n  };\n  /**\r\n   * Applies parsed format to a numeric value.\r\n   *\r\n   * @param value    Value\r\n   * @param details  Parsed format as returned by parseFormat()\r\n   * @return Formatted number\r\n   */\n\n\n  NumberFormatter.prototype.applyFormat = function (value, details) {\n    // Use absolute values\n    var negative = value < 0;\n    value = Math.abs(value); // Recalculate according to modifier\n\n    var prefix = \"\",\n        suffix = \"\";\n    var mods = details.mod ? details.mod.split(\"\") : [];\n\n    if (mods.indexOf(\"b\") !== -1) {\n      var a_1 = this.applyPrefix(value, this.bytePrefixes, mods.indexOf(\"!\") !== -1);\n      value = a_1[0];\n      prefix = a_1[1];\n      suffix = a_1[2];\n\n      if (details.modSpacing) {\n        suffix = \" \" + suffix;\n      }\n    } else if (mods.indexOf(\"a\") !== -1) {\n      var a_2 = this.applyPrefix(value, value < this.smallNumberThreshold ? this.smallNumberPrefixes : this.bigNumberPrefixes, mods.indexOf(\"!\") !== -1);\n      value = a_2[0];\n      prefix = a_2[1];\n      suffix = a_2[2];\n\n      if (details.modSpacing) {\n        suffix = \" \" + suffix;\n      }\n    } else if (mods.indexOf(\"%\") !== -1) {\n      var ol = value.toString().length;\n      value *= 100;\n      value = parseFloat(value.toPrecision(ol + 2));\n      suffix = \"%\";\n    } else if (mods.indexOf(\"‰\") !== -1) {\n      var ol = value.toString().length;\n      value *= 1000;\n      value = parseFloat(value.toPrecision(ol + 3));\n      suffix = \"‰\";\n    } // Round to passive\n\n\n    if (mods.indexOf(\"e\") !== -1) {\n      // convert the value to exponential\n      var exp = void 0;\n\n      if (details.decimals.passive >= 0) {\n        exp = value.toExponential(details.decimals.passive).split(\"e\");\n      } else {\n        exp = value.toExponential().split(\"e\");\n      }\n\n      value = Number(exp[0]);\n      suffix = \"e\" + exp[1];\n\n      if (details.modSpacing) {\n        suffix = \" \" + suffix;\n      }\n    } else if (details.decimals.passive === 0) {\n      value = Math.round(value);\n    } else if (details.decimals.passive > 0) {\n      var d = Math.pow(10, details.decimals.passive);\n      value = Math.round(value * d) / d;\n    } // Init return value\n\n\n    var res = \"\"; // Calc integer and decimal parts\n\n    var a = $utils.numberToString(value).split(\".\"); // Format integers\n\n    var ints = a[0]; // Pad integers to active length\n\n    if (ints.length < details.thousands.active) {\n      ints = Array(details.thousands.active - ints.length + 1).join(\"0\") + ints;\n    } // Insert thousands separators\n\n\n    if (details.thousands.interval > 0) {\n      var ip = [];\n      var intsr = ints.split(\"\").reverse().join(\"\");\n\n      for (var i = 0, len = ints.length; i <= len; i += details.thousands.interval) {\n        var c = intsr.substr(i, details.thousands.interval).split(\"\").reverse().join(\"\");\n\n        if (c !== \"\") {\n          ip.unshift(c);\n        }\n      }\n\n      ints = ip.join(details.thousands.separator);\n    } // Add integers\n\n\n    res += ints; // Add decimals\n\n    if (a.length === 1) {\n      a.push(\"\");\n    }\n\n    var decs = a[1]; // Fill zeros?\n\n    if (decs.length < details.decimals.active) {\n      decs += Array(details.decimals.active - decs.length + 1).join(\"0\");\n    }\n\n    if (decs !== \"\") {\n      res += details.decimals.separator + decs;\n    } // Can't have empty return value\n\n\n    if (res === \"\") {\n      res = \"0\";\n    } // Add minus sign back\n\n\n    if (value !== 0 && negative && mods.indexOf(\"s\") === -1) {\n      res = \"-\" + res;\n    } // Add suffixes/prefixes\n\n\n    if (prefix) {\n      res = prefix + res;\n    }\n\n    if (suffix) {\n      res += suffix;\n    }\n\n    return res;\n  };\n  /**\r\n   * Chooses appropriate prefix and suffix based on the passed in rules.\r\n   *\r\n   * @param  value     Value\r\n   * @param  prefixes  Prefix array\r\n   * @param  force     Force application of a first prefix (@sice 4.5.4)\r\n   * @return Result\r\n   */\n\n\n  NumberFormatter.prototype.applyPrefix = function (value, prefixes, force) {\n    if (force === void 0) {\n      force = false;\n    }\n\n    var newvalue = value;\n    var prefix = \"\";\n    var suffix = \"\";\n    var applied = false;\n    var k = 1;\n\n    for (var i = 0, len = prefixes.length; i < len; i++) {\n      if (prefixes[i].number <= value) {\n        if (prefixes[i].number === 0) {\n          newvalue = 0;\n        } else {\n          newvalue = value / prefixes[i].number;\n          k = prefixes[i].number;\n        }\n\n        prefix = prefixes[i].prefix;\n        suffix = prefixes[i].suffix;\n        applied = true;\n      }\n    }\n\n    if (!applied && force && prefixes.length && value != 0) {\n      // Prefix was not applied. Use the first prefix.\n      newvalue = value / prefixes[0].number;\n      prefix = prefixes[0].prefix;\n      suffix = prefixes[0].suffix;\n      applied = true;\n    }\n\n    if (applied) {\n      newvalue = parseFloat(newvalue.toPrecision(k.toString().length + Math.floor(newvalue).toString().replace(/[^0-9]*/g, \"\").length));\n    }\n\n    return [newvalue, prefix, suffix];\n  };\n  /**\r\n   * Invalidates the parent [[Sprite]] object.\r\n   */\n\n\n  NumberFormatter.prototype.invalidateSprite = function () {\n    if (this.sprite) {\n      this.sprite.invalidate();\n    }\n  };\n\n  Object.defineProperty(NumberFormatter.prototype, \"numberFormat\", {\n    /**\r\n     * @return A format to use for number formatting\r\n     */\n    get: function () {\n      return this._numberFormat;\n    },\n\n    /**\r\n     * Number format.\r\n     *\r\n     * @default \"#,###.#####\"\r\n     * @see {@link https://www.amcharts.com/docs/v4/concepts/formatters/formatting-numbers/} Tutorial on number formatting\r\n     * @param format  A format to use for number formatting\r\n     */\n    set: function (format) {\n      this._numberFormat = format;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(NumberFormatter.prototype, \"intlLocales\", {\n    /**\r\n     * @return Date format\r\n     */\n    get: function () {\n      return this._intlLocales;\n    },\n\n    /**\r\n     * Locales if you are using date formats in `Intl.NumberFormatOptions` syntax.\r\n     *\r\n     * @see (@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/NumberFormat) about using Intl for number formatting\r\n     * @param value Locales\r\n     */\n    set: function (value) {\n      this._intlLocales = value;\n      this.invalidateSprite();\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(NumberFormatter.prototype, \"negativeBase\", {\n    /**\r\n     * @return A format to use for number formatting\r\n     */\n    get: function () {\n      return this._negativeBase;\n    },\n\n    /**\r\n     * Negative base for negative numbers.\r\n     *\r\n     * @default 0\r\n     * @see {@link https://www.amcharts.com/docs/v4/concepts/formatters/formatting-numbers/} Tutorial on number formatting\r\n     * @param format  A format to use for number formatting\r\n     */\n    set: function (value) {\n      this._negativeBase = value;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(NumberFormatter.prototype, \"bigNumberPrefixes\", {\n    /**\r\n     * @return Prefixes for big numbers\r\n     */\n    get: function () {\n      if (!$type.hasValue(this._bigNumberPrefixes)) {\n        this._bigNumberPrefixes = [{\n          \"number\": 1e+3,\n          \"suffix\": this.language.translate(\"_big_number_suffix_3\")\n        }, {\n          \"number\": 1e+6,\n          \"suffix\": this.language.translate(\"_big_number_suffix_6\")\n        }, {\n          \"number\": 1e+9,\n          \"suffix\": this.language.translate(\"_big_number_suffix_9\")\n        }, {\n          \"number\": 1e+12,\n          \"suffix\": this.language.translate(\"_big_number_suffix_12\")\n        }, {\n          \"number\": 1e+15,\n          \"suffix\": this.language.translate(\"_big_number_suffix_15\")\n        }, {\n          \"number\": 1e+18,\n          \"suffix\": this.language.translate(\"_big_number_suffix_18\")\n        }, {\n          \"number\": 1e+21,\n          \"suffix\": this.language.translate(\"_big_number_suffix_21\")\n        }, {\n          \"number\": 1e+24,\n          \"suffix\": this.language.translate(\"_big_number_suffix_24\")\n        }];\n      }\n\n      return this._bigNumberPrefixes;\n    },\n\n    /**\r\n     * Prefixes for big numbers.\r\n     *\r\n     * It's an array of objects of number/prefix pairs.\r\n     *\r\n     * ```JSON\r\n     * [\r\n     *   { \"number\": 1e+3, \"suffix\": \"K\" },\r\n     *   { \"number\": 1e+6, \"suffix\": \"M\" },\r\n     *   { \"number\": 1e+9, \"suffix\": \"G\" },\r\n     *   { \"number\": 1e+12, \"suffix\": \"T\" },\r\n     *   { \"number\": 1e+15, \"suffix\": \"P\" },\r\n     *   { \"number\": 1e+18, \"suffix\": \"E\" },\r\n     *   { \"number\": 1e+21, \"suffix\": \"Z\" },\r\n     *   { \"number\": 1e+24, \"suffix\": \"Y\" }\r\n     * ]\r\n     * ```\r\n     *\r\n     * If the number is bigger than the `number` ir will be converted to the\r\n     * appropriate bigger number with prefix.\r\n     *\r\n     * E.g. as per above `1500` will be converted to `1.5K`.\r\n     *\r\n     * Please note that for this transformation to be enabled, you need to\r\n     * enable it specific modifier in your format setting.\r\n     *\r\n     * The modifier for big/small number modification is \"a\":\r\n     *\r\n     * ```Text\r\n     * {myfield.formatNumber(\"#,###.00a\")}\r\n     * ```\r\n     *\r\n     * @see {@link https://www.amcharts.com/docs/v4/concepts/formatters/formatting-numbers/} Tutorial on number formatting\r\n     * @param prefixes  Prefixes for big numbers\r\n     */\n    set: function (prefixes) {\n      this._bigNumberPrefixes = prefixes;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(NumberFormatter.prototype, \"smallNumberPrefixes\", {\n    /**\r\n     * @return Prefixes for small numbers\r\n     */\n    get: function () {\n      if (!$type.hasValue(this._smallNumberPrefixes)) {\n        this._smallNumberPrefixes = [{\n          \"number\": 1e-24,\n          \"suffix\": this.language.translate(\"_small_number_suffix_24\")\n        }, {\n          \"number\": 1e-21,\n          \"suffix\": this.language.translate(\"_small_number_suffix_21\")\n        }, {\n          \"number\": 1e-18,\n          \"suffix\": this.language.translate(\"_small_number_suffix_18\")\n        }, {\n          \"number\": 1e-15,\n          \"suffix\": this.language.translate(\"_small_number_suffix_15\")\n        }, {\n          \"number\": 1e-12,\n          \"suffix\": this.language.translate(\"_small_number_suffix_12\")\n        }, {\n          \"number\": 1e-9,\n          \"suffix\": this.language.translate(\"_small_number_suffix_9\")\n        }, {\n          \"number\": 1e-6,\n          \"suffix\": this.language.translate(\"_small_number_suffix_6\")\n        }, {\n          \"number\": 1e-3,\n          \"suffix\": this.language.translate(\"_small_number_suffix_3\")\n        }];\n      }\n\n      return this._smallNumberPrefixes;\n    },\n\n    /**\r\n     * Prefixes for big numbers.\r\n     *\r\n     * It's an array of objects of number/prefix pairs.\r\n     *\r\n     * ```JSON\r\n     * [\r\n     *   { \"number\": 1e-24, \"suffix\": \"y\" },\r\n     *   { \"number\": 1e-21, \"suffix\": \"z\" },\r\n     *   { \"number\": 1e-18, \"suffix\": \"a\" },\r\n     *   { \"number\": 1e-15, \"suffix\": \"f\" },\r\n     *   { \"number\": 1e-12, \"suffix\": \"p\" },\r\n     *   { \"number\": 1e-9, \"suffix\": \"n\" },\r\n     *   { \"number\": 1e-6, \"suffix\": \"μ\" },\r\n     *   { \"number\": 1e-3, \"suffix\": \"m\" }\r\n     * ]\r\n     * ```\r\n     *\r\n     * If the number is smaller than the `number` ir will be converted to the\r\n     * appropriate smaller number with prefix.\r\n     *\r\n     * E.g. as per above `0.0015` will be converted to `1.5m`.\r\n     *\r\n     * Please note that for this transformation to be enabled, you need to\r\n     * enable it specific modifier in your format setting.\r\n     *\r\n     * The modifier for big/small number modification is \"a\":\r\n     *\r\n     * ```Text\r\n     * {myfield.formatNumber(\"#,###.00a\")}\r\n     * ```\r\n     *\r\n     * IMPORTANT: The order of the suffixes is important. The list must start\r\n     * from the smallest number and work towards bigger ones.\r\n     *\r\n     * @see {@link https://www.amcharts.com/docs/v4/concepts/formatters/formatting-numbers/} Tutorial on number formatting\r\n     * @param prefixes  Prefixes for small numbers\r\n     */\n    set: function (prefixes) {\n      this._smallNumberPrefixes = prefixes;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(NumberFormatter.prototype, \"smallNumberThreshold\", {\n    /**\r\n     * @return Small number threshold\r\n     */\n    get: function () {\n      return this._smallNumberThreshold;\n    },\n\n    /**\r\n     * Any number smaller than this will be considered \"small\" number, which will\r\n     * trigger special formatting if \"a\" format modifier is used.\r\n     *\r\n     * @since 4.6.8\r\n     * @param  value  Small number threshold\r\n     */\n    set: function (value) {\n      this._smallNumberThreshold = value;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(NumberFormatter.prototype, \"bytePrefixes\", {\n    /**\r\n     * @return Prefixes for byte-size formatting\r\n     */\n    get: function () {\n      if (!$type.hasValue(this._bytePrefixes)) {\n        this._bytePrefixes = [{\n          \"number\": 1,\n          suffix: this.language.translate(\"_byte_suffix_B\")\n        }, {\n          \"number\": 1024,\n          suffix: this.language.translate(\"_byte_suffix_KB\")\n        }, {\n          \"number\": 1048576,\n          suffix: this.language.translate(\"_byte_suffix_MB\")\n        }, {\n          \"number\": 1073741824,\n          suffix: this.language.translate(\"_byte_suffix_GB\")\n        }, {\n          \"number\": 1099511627776,\n          suffix: this.language.translate(\"_byte_suffix_TB\")\n        }, {\n          \"number\": 1125899906842624,\n          suffix: this.language.translate(\"_byte_suffix_PB\")\n        }];\n      }\n\n      return this._bytePrefixes;\n    },\n\n    /**\r\n     * Basically the same as `bigNumberPrefixes`, except base for calculation\r\n     * is not thousand but byte (1024).\r\n     *\r\n     * The modifier is \"b\".\r\n     *\r\n     *  ```Text\r\n     * {myfield.formatNumber(\"#,###.00b\")}\r\n     * ```\r\n     *\r\n     * The above `2048` will change to `2K`.\r\n     *\r\n     * @see {@link https://www.amcharts.com/docs/v4/concepts/formatters/formatting-numbers/} Tutorial on number formatting\r\n     * @param prefixes  Prefixes for byte-size formatting\r\n     */\n    set: function (prefixes) {\n      this._bytePrefixes = prefixes;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(NumberFormatter.prototype, \"outputFormat\", {\n    /**\r\n     * @ignore Exclude from docs\r\n     * @return Output format\r\n     */\n    get: function () {\n      return this._outputFormat;\n    },\n\n    /**\r\n     * Ooutput format: \"svg\" or \"html\".\r\n     *\r\n     * @ignore Exclude from docs\r\n     * @param value  Output format\r\n     */\n    set: function (outputFormat) {\n      this._outputFormat = outputFormat.toLowerCase();\n      this.invalidateSprite();\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\r\n   * Replaces brackets with temporary placeholders.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param text  Input text\r\n   * @return Escaped text\r\n   */\n\n  NumberFormatter.prototype.escape = function (text) {\n    return text.replace(\"||\", $strings.PLACEHOLDER2);\n  };\n  /**\r\n   * Replaces placeholders back to brackets.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param text  Escaped text\r\n   * @return Unescaped text\r\n   */\n\n\n  NumberFormatter.prototype.unescape = function (text) {\n    return text.replace($strings.PLACEHOLDER2, \"|\");\n  };\n\n  return NumberFormatter;\n}(BaseObject);\n\nexport { NumberFormatter };\n/**\r\n * Register class in system, so that it can be instantiated using its name from\r\n * anywhere.\r\n *\r\n * @ignore\r\n */\n\nregistry.registeredClasses[\"NumberFormatter\"] = NumberFormatter;","map":null,"metadata":{},"sourceType":"module"}