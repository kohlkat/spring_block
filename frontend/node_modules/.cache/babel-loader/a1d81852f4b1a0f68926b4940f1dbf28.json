{"ast":null,"code":"import * as tslib_1 from \"tslib\";\n/**\r\n * ============================================================================\r\n * IMPORTS\r\n * ============================================================================\r\n * @hidden\r\n */\n\nimport { Container } from \"./Container\";\nimport { List, ListDisposer } from \"./utils/List\";\nimport { OrderedListTemplate } from \"./utils/SortedList\";\nimport { Dictionary } from \"./utils/Dictionary\";\nimport { Disposer, MultiDisposer } from \"./utils/Disposer\";\nimport { DataSource } from \"./data/DataSource\";\nimport { Responsive } from \"./utils/Responsive\";\nimport { system } from \"./System\";\nimport { DataItem } from \"./DataItem\";\nimport { registry } from \"./Registry\";\nimport * as $math from \"./utils/Math\";\nimport * as $array from \"./utils/Array\";\nimport * as $ease from \"./utils/Ease\";\nimport * as $utils from \"./utils/Utils\";\nimport * as $iter from \"./utils/Iterator\";\nimport * as $object from \"./utils/Object\";\nimport * as $type from \"./utils/Type\";\n/**\r\n * ============================================================================\r\n * MAIN CLASS\r\n * ============================================================================\r\n * @hidden\r\n */\n\n/**\r\n * A Component represents an independent functional element or control, that\r\n * can have it's own behavior, children, data, etc.\r\n *\r\n * A few examples of a Component: [[Legend]], [[Series]], [[Scrollbar]].\r\n *\r\n * @see {@link IComponentEvents} for a list of available events\r\n * @see {@link IComponentAdapters} for a list of available Adapters\r\n * @important\r\n */\n\nvar Component =\n/** @class */\nfunction (_super) {\n  tslib_1.__extends(Component, _super);\n  /**\r\n   * Constructor\r\n   */\n\n\n  function Component() {\n    var _this = // Init\n    _super.call(this) || this;\n    /**\r\n     * Holds data field names.\r\n     *\r\n     * Data fields define connection beween [[DataItem]] and actual properties\r\n     * in raw data.\r\n     */\n\n\n    _this.dataFields = {};\n    /**\r\n     * A list of [[DataSource]] definitions of external data source.\r\n     *\r\n     * @ignore Exclude from docs\r\n     */\n\n    _this._dataSources = {};\n    /**\r\n     * This is used when only new data is invalidated (if added using `addData`\r\n     * method).\r\n     *\r\n     * @ignore Exclude from docs\r\n     */\n\n    _this._parseDataFrom = 0;\n    /**\r\n     * Holds the disposers for the dataItems and dataUsers\r\n     *\r\n     * @ignore Exclude from docs\r\n     */\n\n    _this._dataDisposers = [];\n    /**\r\n     * Currently selected \"data set\".\r\n     *\r\n     * If it's set to `\"\"`, main data set (unaggregated data) is used.\r\n     */\n\n    _this._currentDataSetId = \"\";\n    /**\r\n     * [_start description]\r\n     *\r\n     * @ignore Exclude from docs\r\n     */\n\n    _this._start = 0;\n    /**\r\n     * [_end description]\r\n     *\r\n     * @ignore Exclude from docs\r\n     */\n\n    _this._end = 1;\n    /**\r\n     * If set to `true`, changing data range in element will not trigger\r\n     * `daterangechanged` event.\r\n     */\n\n    _this.skipRangeEvent = false;\n    /**\r\n     * Whenever selected scope changes (chart is zoomed or panned), for example\r\n     * by interaction from a Scrollbar, or API, a chart needs to reposition\r\n     * its contents.\r\n     *\r\n     * `rangeChangeDuration` influences how this is performed.\r\n     *\r\n     * If set to zero (0), the change will happen instantenously.\r\n     *\r\n     * If set to non-zero value, the chart will gradually animate into new\r\n     * position for the set amount of milliseconds.\r\n     *\r\n     * @default 0\r\n     * @see {@link https://www.amcharts.com/docs/v4/concepts/animations/} for more info about animations\r\n     */\n\n    _this.rangeChangeDuration = 0;\n    /**\r\n     * An easing function to use for range change animation.\r\n     *\r\n     * @see {@link Ease}\r\n     * @see {@link https://www.amcharts.com/docs/v4/concepts/animations/} for more info about animations\r\n     */\n\n    _this.rangeChangeEasing = $ease.cubicOut;\n    /**\r\n     * A duration (ms) of each data parsing step. A Component parses its data in\r\n     * chunks in order to avoid completely freezing the machine when large data\r\n     * sets are used. This setting will control how many milliseconds should pass\r\n     * when parsing data until parser stops for a brief moment to let other\r\n     * processes catch up.\r\n     */\n\n    _this.parsingStepDuration = 50;\n    /**\r\n     * [dataInvalid description]\r\n     *\r\n     * @ignore Exclude from docs\r\n     * @todo Description\r\n     */\n\n    _this.dataInvalid = false;\n    /**\r\n     *\r\n     * @ignore Exclude from docs\r\n     */\n\n    _this.rawDataInvalid = false;\n    /**\r\n     * [dataRangeInvalid description]\r\n     *\r\n     * @ignore Exclude from docs\r\n     * @todo Description\r\n     */\n\n    _this.dataRangeInvalid = false;\n    /**\r\n     * [dataItemsInvalid description]\r\n     *\r\n     * @ignore Exclude from docs\r\n     * @todo Description\r\n     */\n\n    _this.dataItemsInvalid = false;\n    /**\r\n     * If set to a non-zero number the element will \"animate\" data values of its\r\n     * children.\r\n     *\r\n     * This will happen on first load and whenever data values change.\r\n     *\r\n     * Enabling interpolation will mean that elements will transit smoothly into\r\n     * new values rather than updating instantly.\r\n     *\r\n     * @default 0\r\n     * @see {@link https://www.amcharts.com/docs/v4/concepts/animations/} for more info about animations\r\n     */\n\n    _this.interpolationDuration = 0;\n    /**\r\n     * An easing function to use for interpolating values when transiting from\r\n     * one source value to another.\r\n     *\r\n     * @default cubicOut\r\n     * @see {@link https://www.amcharts.com/docs/v4/concepts/animations/} for more info about animations\r\n     * @see {@link Ease}\r\n     */\n\n    _this.interpolationEasing = $ease.cubicOut;\n    /**\r\n     * Indicates whether transition between data item's values should start and\r\n     * play out all at once, or with a small delay (as defined by\r\n     * `sequencedInterpolationDelay`) for each subsequent data item.\r\n     *\r\n     * @default true\r\n     * @see {@link https://www.amcharts.com/docs/v4/concepts/animations/} for more info about animations\r\n     */\n\n    _this.sequencedInterpolation = true;\n    /**\r\n     * A delay (ms) to wait between animating each subsequent data item's\r\n     * interpolation animation.\r\n     *\r\n     * Relative only if `sequencedInterpolation = true`.\r\n     *\r\n     * @default 0\r\n     * @see {@link https://www.amcharts.com/docs/v4/concepts/animations/} for more info about animations\r\n     */\n\n    _this.sequencedInterpolationDelay = 0;\n    /**\r\n     * A progress (0-1) for the data validation process.\r\n     *\r\n     * @ignore Exclude from docs\r\n     */\n\n    _this.dataValidationProgress = 0;\n    _this._addAllDataItems = true;\n    _this._usesData = true;\n    _this.className = \"Component\";\n    _this.minZoomCount = 1;\n    _this.maxZoomCount = 0;\n    _this._dataItems = new OrderedListTemplate(_this.createDataItem());\n\n    _this._dataItems.events.on(\"inserted\", _this.handleDataItemAdded, _this, false);\n\n    _this._dataItems.events.on(\"removed\", _this.handleDataItemRemoved, _this, false);\n\n    _this._disposers.push(new ListDisposer(_this._dataItems));\n\n    _this._disposers.push(_this._dataItems.template);\n\n    _this.invalidateData(); // TODO what about remove ?\n\n\n    _this.dataUsers.events.on(\"inserted\", _this.handleDataUserAdded, _this, false); // Set up disposers\n\n\n    _this._disposers.push(new MultiDisposer(_this._dataDisposers));\n\n    _this._start = 0;\n    _this._end = 1;\n    _this.maxZoomDeclination = 1; // Apply theme\n\n    _this.applyTheme();\n\n    return _this;\n  }\n  /**\r\n   * Returns a new/empty DataItem of the type appropriate for this object.\r\n   *\r\n   * @see {@link DataItem}\r\n   * @return Data Item\r\n   */\n\n\n  Component.prototype.createDataItem = function () {\n    return new DataItem();\n  };\n  /**\r\n   * [handleDataUserAdded description]\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @todo Description\r\n   * @param event Event object\r\n   */\n\n\n  Component.prototype.handleDataUserAdded = function (event) {\n    var dataUser = event.newValue;\n    dataUser.dataProvider = this;\n  };\n  /**\r\n   * [handleDataItemValueChange description]\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @todo Description\r\n   */\n\n\n  Component.prototype.handleDataItemValueChange = function (dataItem, name) {\n    if (!this.dataItemsInvalid) {\n      this.invalidateDataItems();\n    }\n  };\n  /**\r\n   * [handleDataItemWorkingValueChange description]\r\n   *\r\n   * @ignore Exclude from docs\r\n   */\n\n\n  Component.prototype.handleDataItemWorkingValueChange = function (dataItem, name) {};\n  /**\r\n   * [handleDataItemWorkingLocationChange description]\r\n   *\r\n   * @ignore Exclude from docs\r\n   */\n\n\n  Component.prototype.handleDataItemWorkingLocationChange = function (dataItem, name) {};\n  /**\r\n   * [handleDataItemCalculatedValueChange description]\r\n   *\r\n   * @ignore Exclude from docs\r\n   */\n\n\n  Component.prototype.handleDataItemCalculatedValueChange = function (dataItem, name) {};\n  /**\r\n   * [handleDataItemPropertyChange description]\r\n   *\r\n   * @ignore Exclude from docs\r\n   */\n\n\n  Component.prototype.handleDataItemPropertyChange = function (dataItem, name) {};\n  /**\r\n   * Populates a [[DataItem]] width data from data source.\r\n   *\r\n   * Loops through all the fields and if such a field is found in raw data\r\n   * object, a corresponding value on passed in `dataItem` is set.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param item\r\n   */\n\n\n  Component.prototype.processDataItem = function (dataItem, dataContext) {\n    var _this = this;\n\n    if (dataItem) {\n      if (!dataContext) {\n        dataContext = {};\n      } // store reference to original data item\n\n\n      dataItem.dataContext = dataContext;\n      var hasSomeValues_1 = false;\n      $object.each(this.dataFields, function (key, fieldValue) {\n        var fieldName = key;\n        var value = dataContext[fieldValue]; // Apply adapters to a retrieved value\n\n        if (_this._adapterO) {\n          if (_this._adapterO.isEnabled(\"dataContextValue\")) {\n            value = _this._adapterO.apply(\"dataContextValue\", {\n              field: fieldName,\n              value: value,\n              dataItem: dataItem\n            }).value;\n          }\n        }\n\n        if (dataItem.hasChildren[fieldName]) {\n          if ($type.hasValue(value)) {\n            hasSomeValues_1 = true;\n\n            var template = _this.createDataItem();\n\n            template.copyFrom(_this.mainDataSet.template);\n            var children = new OrderedListTemplate(template);\n            children.events.on(\"inserted\", _this.handleDataItemAdded, _this, false);\n            children.events.on(\"removed\", _this.handleDataItemRemoved, _this, false);\n\n            _this._dataDisposers.push(new ListDisposer(children));\n\n            var count = value.length;\n\n            for (var i = 0; i < count; i++) {\n              var rawDataItem = value[i];\n              var childDataItem = children.create();\n              childDataItem.parent = dataItem;\n\n              _this.processDataItem(childDataItem, rawDataItem);\n            }\n\n            var anyDataItem = dataItem;\n            anyDataItem[fieldName] = children;\n          }\n        } else {\n          // data is converted to numbers/dates in each dataItem\n          if ($type.hasValue(value)) {\n            hasSomeValues_1 = true;\n            dataItem[fieldName] = value;\n          }\n        }\n      });\n      $object.each(this.propertyFields, function (key, fieldValue) {\n        var f = key;\n        var value = dataContext[fieldValue];\n\n        if ($type.hasValue(value)) {\n          hasSomeValues_1 = true;\n          dataItem.setProperty(f, value);\n        }\n      }); // @todo we might need some flag which would tell whether we should create empty data items or not.\n\n      if (!this._addAllDataItems && !hasSomeValues_1) {\n        this.mainDataSet.remove(dataItem);\n      }\n    }\n  };\n  /**\r\n   *\r\n   * When validating raw data, instead of processing data item, we update it\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param item\r\n   */\n\n\n  Component.prototype.updateDataItem = function (dataItem) {\n    var _this = this;\n\n    if (dataItem) {\n      var dataContext_1 = dataItem.dataContext;\n      $object.each(this.dataFields, function (key, fieldValue) {\n        var fieldName = key;\n        var value = dataContext_1[fieldValue]; // Apply adapters to a retrieved value\n\n        if (_this._adapterO) {\n          value = _this._adapterO.apply(\"dataContextValue\", {\n            field: fieldName,\n            value: value,\n            dataItem: dataItem\n          }).value;\n        }\n\n        if (dataItem.hasChildren[fieldName]) {\n          if (value) {\n            var anyDataItem = dataItem;\n            var children = anyDataItem[fieldName];\n            $iter.each(children.iterator(), function (child) {\n              _this.updateDataItem(child);\n            });\n          }\n        } else {\n          // data is converted to numbers/dates in each dataItem\n          if ($type.hasValue(value)) {\n            dataItem[fieldName] = value;\n          }\n        }\n      });\n      $object.each(this.propertyFields, function (key, fieldValue) {\n        var f = key;\n        var value = dataContext_1[fieldValue];\n\n        if ($type.hasValue(value)) {\n          dataItem.setProperty(f, value);\n        }\n      });\n    }\n  };\n  /**\r\n   * [validateDataElements description]\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @todo Description\r\n   */\n\n\n  Component.prototype.validateDataElements = function () {\n    var count = this.endIndex;\n\n    for (var i = this.startIndex; i < count; i++) {\n      var dataItem = this.dataItems.getIndex(i); // TODO is this correct\n\n      if (dataItem) {\n        this.validateDataElement(dataItem);\n      }\n    }\n  };\n  /**\r\n   * Validates this element and its related elements.\r\n   *\r\n   * @ignore Exclude from docs\r\n   */\n\n\n  Component.prototype.validate = function () {\n    this.validateDataElements();\n\n    _super.prototype.validate.call(this);\n  };\n  /**\r\n   * [validateDataElement description]\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param dataItem [description]\r\n   */\n\n\n  Component.prototype.validateDataElement = function (dataItem) {};\n  /**\r\n   * Adds one or several (array) of data items to the existing data.\r\n   *\r\n   * @param rawDataItem One or many raw data item objects\r\n   */\n\n\n  Component.prototype.addData = function (rawDataItem, removeCount) {\n    var _this = this; // need to check if data is invalid, as addData might be called multiple times\n\n\n    if (!this.dataInvalid && this.inited) {\n      this._parseDataFrom = this.data.length; // save length of parsed data\n    }\n\n    if (rawDataItem instanceof Array) {\n      // can't use concat because new array is returned\n      $array.each(rawDataItem, function (dataItem) {\n        _this.data.push(dataItem);\n      });\n    } else {\n      this.data.push(rawDataItem); // add to raw data array\n    }\n\n    if (this.inited) {\n      this.removeData(removeCount);\n    } else {\n      if ($type.isNumber(removeCount)) {\n        while (removeCount > 0) {\n          this.data.shift();\n          removeCount--;\n        }\n      }\n    }\n\n    this.invalidateData();\n  };\n  /**\r\n   * Removes elements from the beginning of data\r\n   *\r\n   * @param count number of elements to remove\r\n   */\n\n\n  Component.prototype.removeData = function (count) {\n    if ($type.isNumber(count)) {\n      while (count > 0) {\n        var dataItem = this.mainDataSet.getIndex(0);\n\n        if (dataItem) {\n          this.mainDataSet.remove(dataItem);\n        }\n\n        this.dataUsers.each(function (dataUser) {\n          if (!dataUser.data || dataUser.data.length == 0) {\n            var dataItem_1 = dataUser.dataItems.getIndex(0);\n\n            if (dataItem_1) {\n              dataUser.dataItems.remove(dataItem_1);\n            }\n          }\n        });\n        this.data.shift();\n\n        if (this._parseDataFrom > 0) {\n          this._parseDataFrom--;\n        }\n\n        count--;\n      }\n\n      this.invalidateData();\n    }\n  };\n  /**\r\n   * Triggers a data (re)parsing.\r\n   *\r\n   * @ignore Exclude from docs\r\n   */\n\n\n  Component.prototype.invalidateData = function () {\n    if (this.disabled || this.isTemplate) {\n      return;\n    } //if(!this.dataInvalid){\n\n\n    registry.addToInvalidComponents(this);\n    system.requestFrame();\n    this.dataInvalid = true;\n    $iter.each(this.dataUsers.iterator(), function (x) {\n      x.invalidateDataItems();\n    }); //}\n  };\n  /**\r\n   * [invalidateDataUsers description]\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @todo Description\r\n   */\n\n\n  Component.prototype.invalidateDataUsers = function () {\n    $iter.each(this.dataUsers.iterator(), function (x) {\n      x.invalidate();\n    });\n  };\n  /**\r\n   * Invalidates data values. When data array is not changed, but values within\r\n   * it changes, we invalidate data so that component would process changes.\r\n   *\r\n   * @ignore Exclude from docs\r\n   */\n\n\n  Component.prototype.invalidateDataItems = function () {\n    if (this.disabled || this.isTemplate) {\n      return;\n    } //if(!this.dataItemsInvalid){\n\n\n    $array.move(registry.invalidDataItems, this);\n    system.requestFrame();\n    this.dataItemsInvalid = true;\n    $iter.each(this.dataUsers.iterator(), function (x) {\n      x.invalidateDataItems();\n    }); //}\n  };\n  /**\r\n   * Invalidates data range. This is done when data which must be shown\r\n   * changes (chart is zoomed for example).\r\n   *\r\n   * @ignore Exclude from docs\r\n   */\n\n\n  Component.prototype.invalidateDataRange = function () {\n    if (this.disabled || this.isTemplate) {\n      return;\n    } //if(!this.dataRangeInvalid){\n\n\n    this.dataRangeInvalid = true;\n    $array.move(registry.invalidDataRange, this);\n    system.requestFrame(); //}\n  };\n  /**\r\n   * Processes data range.\r\n   *\r\n   * @todo Description\r\n   * @ignore Exclude from docs\r\n   */\n\n\n  Component.prototype.validateDataRange = function () {\n    $array.remove(registry.invalidDataRange, this);\n    this.dataRangeInvalid = false;\n\n    if (this.startIndex != this._prevStartIndex || this.endIndex != this._prevEndIndex) {\n      this.rangeChangeUpdate();\n      this.appendDataItems();\n      this.invalidate();\n      this.dispatchImmediately(\"datarangechanged\");\n    }\n  };\n  /**\r\n   * [sliceData description]\r\n   *\r\n   * @todo Description\r\n   * @ignore Exclude from docs\r\n   */\n\n\n  Component.prototype.sliceData = function () {\n    this._workingStartIndex = this.startIndex;\n    this._workingEndIndex = this.endIndex;\n  };\n  /**\r\n   * [rangeChangeUpdate description]\r\n   *\r\n   * @todo Description\r\n   * @ignore Exclude from docs\r\n   */\n\n\n  Component.prototype.rangeChangeUpdate = function () {\n    this.sliceData();\n    this._prevStartIndex = this.startIndex;\n    this._prevEndIndex = this.endIndex;\n  };\n  /**\r\n   * [appendDataItems description]\r\n   *\r\n   * @todo Description\r\n   * @ignore Exclude from docs\r\n   */\n\n\n  Component.prototype.appendDataItems = function () {\n    // TODO use an iterator instead\n    var count = this.endIndex;\n\n    for (var i = this.startIndex; i < count; i++) {\n      // data item\n      var dataItem = this.dataItems.getIndex(i);\n\n      if (dataItem) {\n        dataItem.__disabled = false;\n      }\n    }\n\n    for (var i = 0; i < this.startIndex; i++) {\n      var dataItem = this.dataItems.getIndex(i);\n      dataItem.__disabled = true;\n    }\n\n    for (var i = this.endIndex; i < this.dataItems.length; i++) {\n      var dataItem = this.dataItems.getIndex(i);\n      dataItem.__disabled = true;\n    }\n  };\n  /**\r\n   * If you want to have a smooth transition from one data values to another, you change your raw data and then you must call this method.\r\n   * then instead of redrawing everything, the chart will check raw data and smoothly transit from previous to new data\r\n   */\n\n\n  Component.prototype.invalidateRawData = function () {\n    if (this.disabled || this.isTemplate) {\n      return;\n    } //if(!this.rawDataInvalid){\n\n\n    $array.move(registry.invalidRawDatas, this);\n    system.requestFrame();\n    this.rawDataInvalid = true;\n    $iter.each(this.dataUsers.iterator(), function (x) {\n      x.invalidateRawData();\n    }); //}\n  };\n  /**\r\n   * @ignore\r\n   */\n\n\n  Component.prototype.validateRawData = function () {\n    var _this = this;\n\n    $array.remove(registry.invalidRawDatas, this);\n    $iter.each(this.mainDataSet.iterator(), function (dataItem) {\n      if (dataItem) {\n        _this.updateDataItem(dataItem);\n      }\n    });\n  };\n  /**\r\n   * Destroys this object and all related data.\r\n   */\n\n\n  Component.prototype.dispose = function () {\n    var _this = this;\n\n    this.mainDataSet.template.clones.clear();\n    $object.each(this._dataSources, function (key, source) {\n      _this.removeDispose(source);\n    });\n\n    _super.prototype.dispose.call(this);\n  };\n  /**\r\n   * @ignore\r\n   */\n\n\n  Component.prototype.disposeData = function () {\n    this.mainDataSet.template.clones.clear();\n    $array.each(this._dataDisposers, function (x) {\n      x.dispose();\n    }); // and for all components\n\n    $iter.each(this.dataUsers.iterator(), function (dataUser) {\n      dataUser.disposeData();\n    });\n    this._dataDisposers.length = 0;\n    this._startIndex = undefined;\n    this._endIndex = undefined; // dispose old\n\n    this.mainDataSet.clear();\n    this.mainDataSet.template.clones.clear();\n\n    if (this._dataSets) {\n      this._dataSets.clear();\n    }\n  };\n\n  Component.prototype.getDataItem = function (dataContext) {\n    return this.mainDataSet.create();\n  };\n  /**\r\n   * Validates (processes) data.\r\n   *\r\n   * @ignore Exclude from docs\r\n   */\n\n\n  Component.prototype.validateData = function () {\n    this.dispatchImmediately(\"beforedatavalidated\");\n    this.dataInvalid = false;\n    registry.removeFromInvalidComponents(this);\n\n    if (this.__disabled) {\n      return;\n    }\n\n    this.dataValidationProgress = 0; // need this to slice new data\n\n    this._prevStartIndex = undefined;\n    this._prevEndIndex = undefined; // todo: this needs some overthinking, maybe some extra settings like zoomOotonDataupdate like in v3 or so. some charts like pie chart probably should act like this always\n\n    this._startIndex = undefined;\n    this._endIndex = undefined;\n\n    if (this.dataFields.data && this.dataItem) {\n      var dataContext = this.dataItem.dataContext;\n      this._data = dataContext[this.dataFields.data];\n    } // data items array is reset only if all data is validated, if _parseDataFrom is not 0, we append new data only\n    // check heatmap demo if uncommented\n    // fixed both issues by adding && this.data.length > 0\n    // check adding series example if changed\n\n\n    if (this._parseDataFrom === 0 && this.data.length > 0) {\n      this.disposeData();\n    }\n\n    if (this.data.length > 0) {\n      var preloader = this.preloader; // and for all components\n\n      $iter.each(this.dataUsers.iterator(), function (dataUser) {\n        // todo: this needs some overthinking, maybe some extra settings like zoomOUtonDataupdate like in v3 or so. some charts like pie chart probably should act like this always\n        dataUser._startIndex = undefined;\n        dataUser._endIndex = undefined;\n      });\n      var counter = 0;\n      var startTime = Date.now(); // parse data\n\n      var i = this._parseDataFrom;\n      var n = this.data.length;\n\n      var _loop_1 = function () {\n        var rawDataItem = this_1.data[i];\n\n        if (this_1._usesData) {\n          var dataItem = this_1.getDataItem(rawDataItem);\n          this_1.processDataItem(dataItem, rawDataItem);\n        }\n\n        this_1.dataUsers.each(function (dataUser) {\n          if (dataUser.data.length == 0) {\n            // checking if data is not set directly\n            var dataUserDataItem = dataUser.getDataItem(rawDataItem);\n            dataUser.processDataItem(dataUserDataItem, rawDataItem);\n          }\n        });\n        counter++; // show preloader if this takes too many time\n\n        if (counter == 100) {\n          // no need to check it on each data item\n          counter = 0;\n          var elapsed = Date.now() - startTime;\n\n          if (elapsed > this_1.parsingStepDuration) {\n            if (i < this_1.data.length - 10) {\n              this_1._parseDataFrom = i + 1; // update preloader\n\n              if (preloader) {\n                if (i / this_1.data.length > 0.5 && !preloader.visible) {// do not start showing\n                } else {\n                  preloader.progress = i / this_1.data.length;\n                }\n              }\n\n              this_1.dataValidationProgress = i / this_1.data.length;\n              i = this_1.data.length; // stops cycle\n\n              this_1.invalidateData();\n              return {\n                value: void 0\n              };\n            }\n          }\n        }\n      };\n\n      var this_1 = this;\n\n      for (i; i < n; i++) {\n        var state_1 = _loop_1();\n\n        if (typeof state_1 === \"object\") return state_1.value;\n      }\n\n      if (preloader) {\n        preloader.progress = 1;\n      }\n\n      this.dataUsers.each(function (dataUser) {\n        if (dataUser.hidden) {\n          dataUser.hide(0);\n        }\n      });\n    }\n\n    this.dataValidationProgress = 1;\n    this._parseDataFrom = 0; // reset this index, it is set to dataItems.length if addData() method was used.\n\n    this.invalidateDataItems();\n\n    if (!this._internalDefaultsApplied) {\n      this.applyInternalDefaults();\n    }\n\n    this.dispatch(\"datavalidated\"); // can't zoom chart if dispatched immediately\n  };\n  /**\r\n   * Validates (processes) data items.\r\n   *\r\n   * @ignore Exclude from docs\r\n   */\n\n\n  Component.prototype.validateDataItems = function () {\n    $array.remove(registry.invalidDataItems, this);\n    this.dataItemsInvalid = false;\n    this.invalidateDataRange();\n    this.invalidate();\n    this.dispatch(\"dataitemsvalidated\");\n  };\n\n  Object.defineProperty(Component.prototype, \"data\", {\n    /**\r\n     * Returns element's source (raw) data.\r\n     *\r\n     * @return Data\r\n     */\n    get: function () {\n      if (!this._data) {\n        this._data = [];\n      }\n\n      if (!this._adapterO) {\n        return this._data;\n      } else {\n        return this._adapterO.apply(\"data\", this._data);\n      }\n    },\n\n    /**\r\n     * Sets source (raw) data for the element. The \"data\" is always an `Array`\r\n     * of objects.\r\n     *\r\n     * @param value Data\r\n     */\n    set: function (value) {\n      this.setData(value);\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  Component.prototype.setData = function (value) {\n    // array might be the same, but there might be items added\n    // todo: check if array changed, toString maybe?\n    //if (this._data != value) {\n    this._parseDataFrom = 0;\n    this.disposeData();\n    this._data = value;\n\n    if (value && value.length > 0) {\n      this.invalidateData();\n    } //}\n\n  };\n  /**\r\n   * Returns (creates if necessary) a [[DataSource]] bound to any specific\r\n   * property.\r\n   *\r\n   * For example if I want to bind `data` to an external JSON file, I'd create\r\n   * a DataSource for it.\r\n   *\r\n   * @param property  Property to bind external data to\r\n   * @return A DataSource for property\r\n   */\n\n\n  Component.prototype.getDataSource = function (property) {\n    var _this = this;\n\n    if (!$type.hasValue(this._dataSources[property])) {\n      this._dataSources[property] = new DataSource();\n      this._dataSources[property].component = this;\n      this.setDataSourceEvents(this._dataSources[property], property);\n\n      this._dataSources[property].adapter.add(\"dateFields\", function (val) {\n        return _this.dataSourceDateFields(val);\n      });\n\n      this._dataSources[property].adapter.add(\"numberFields\", function (val) {\n        return _this.dataSourceNumberFields(val);\n      });\n\n      this.events.on(\"inited\", function () {\n        _this.loadData(property);\n      }, this, false);\n    }\n\n    return this._dataSources[property];\n  };\n\n  Object.defineProperty(Component.prototype, \"dataSource\", {\n    /**\r\n     * @return Data source\r\n     */\n    get: function () {\n      if (!this._dataSources[\"data\"]) {\n        this.getDataSource(\"data\");\n      }\n\n      return this._dataSources[\"data\"];\n    },\n\n    /**\r\n     *A [[DataSource]] to be used for loading Component's data.\r\n     *\r\n     * @see {@link https://www.amcharts.com/docs/v4/concepts/loading-external-data/} for more on loading external data\r\n     * @param value  Data source\r\n     */\n    set: function (value) {\n      var _this = this;\n\n      if (this._dataSources[\"data\"]) {\n        this.removeDispose(this._dataSources[\"data\"]);\n      }\n\n      this._dataSources[\"data\"] = value;\n      this._dataSources[\"data\"].component = this;\n      this.events.on(\"inited\", function () {\n        _this.loadData(\"data\");\n      }, this, false);\n      this.setDataSourceEvents(value, \"data\");\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\r\n   * Initiates loading of the external data via [[DataSource]].\r\n   *\r\n   * @ignore Exclude from docs\r\n   */\n\n  Component.prototype.loadData = function (property) {\n    this._dataSources[property].load();\n  };\n  /**\r\n   * This function is called by the [[DataSource]]'s `dateFields` adapater\r\n   * so that particular chart types can popuplate this setting with their\r\n   * own type-specific data fields so they are parsed properly.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param value  Array of date fields\r\n   * @return Array of date fields populated with chart's date fields\r\n   */\n\n\n  Component.prototype.dataSourceDateFields = function (value) {\n    return value;\n  };\n  /**\r\n   * This function is called by the [[DataSource]]'s `numberFields` adapater\r\n   * so that particular chart types can popuplate this setting with their\r\n   * own type-specific data fields so they are parsed properly.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param value  Array of number fields\r\n   * @return Array of number fields populated with chart's number fields\r\n   */\n\n\n  Component.prototype.dataSourceNumberFields = function (value) {\n    return value;\n  };\n  /**\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @todo Description\r\n   * @param list        [description]\r\n   * @param dataFields  [description]\r\n   * @param targetList  [description]\r\n   * @return [description]\r\n   */\n\n\n  Component.prototype.populateDataSourceFields = function (list, dataFields, targetList) {\n    $array.each(targetList, function (value) {\n      if (dataFields[value] && $array.indexOf(list, dataFields[value]) === -1) {\n        list.push(dataFields[value]);\n      }\n    });\n    return list;\n  };\n  /**\r\n   * Sets events on a [[DataSource]].\r\n   *\r\n   * @ignore Exclude from docs\r\n   */\n\n\n  Component.prototype.setDataSourceEvents = function (ds, property) {\n    var _this = this;\n\n    ds.events.on(\"started\", function (ev) {\n      var preloader = _this.preloader;\n\n      if (preloader) {\n        preloader.progress = 0; //preloader.label.text = this.language.translate(\"Loading\");\n      }\n    }, undefined, false);\n    ds.events.on(\"loadstarted\", function (ev) {\n      var preloader = _this.preloader;\n\n      if (preloader) {\n        preloader.progress = 0.25;\n      }\n    }, undefined, false);\n    ds.events.on(\"loadended\", function (ev) {\n      var preloader = _this.preloader;\n\n      if (preloader) {\n        preloader.progress = 0.5;\n      }\n    }, undefined, false);\n    ds.events.on(\"parseended\", function (ev) {\n      var preloader = _this.preloader;\n\n      if (preloader) {\n        preloader.progress = 0.75;\n      }\n    }, undefined, false);\n    ds.events.on(\"ended\", function (ev) {\n      var preloader = _this.preloader;\n\n      if (preloader) {\n        preloader.progress = 1;\n      }\n    }, undefined, false);\n    ds.events.on(\"error\", function (ev) {\n      var preloader = _this.preloader;\n\n      if (preloader) {\n        preloader.progress = 1;\n      }\n\n      _this.openModal(ev.message);\n    }, undefined, false);\n\n    if (property) {\n      ds.events.on(\"done\", function (ev) {\n        var preloader = _this.preloader;\n\n        if (preloader) {\n          preloader.progress = 1;\n        }\n\n        if (property == \"data\" && !$type.isArray(ev.data)) {\n          ev.data = [ev.data];\n        }\n\n        if (ds.incremental && property == \"data\" && _this.data.length) {\n          _this.addData(ev.data, ds.keepCount ? ev.data.length : 0);\n        } else if (ds.updateCurrentData && property == \"data\" && _this.data.length) {\n          // cycle through existing data items\n          $array.each(_this.data, function (item, index) {\n            if ($type.hasValue(ev.data[index])) {\n              $object.each(item, function (key, val) {\n                if ($type.hasValue(ev.data[index][key])) {\n                  item[key] = ev.data[index][key];\n                }\n              });\n            }\n          });\n\n          _this.invalidateRawData();\n        } else {\n          _this[property] = ev.data;\n        }\n      });\n    }\n  };\n\n  Object.defineProperty(Component.prototype, \"responsive\", {\n    /**\r\n     * @return Responsive rules handler\r\n     */\n    get: function () {\n      if (!this._responsive) {\n        this._responsive = new Responsive();\n        this._responsive.component = this;\n      }\n\n      return this._responsive;\n    },\n\n    /**\r\n     * A [[Responsive]] instance to be used when applying conditional\r\n     * property values.\r\n     *\r\n     * NOTE: Responsive features are currently in development and may not work\r\n     * as expected, if at all.\r\n     *\r\n     * @param value  Responsive rules handler\r\n     */\n    set: function (value) {\n      this._responsive = value;\n      this._responsive.component = this;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\r\n   * Sets current zoom.\r\n   *\r\n   * The range uses relative values from 0 to 1, with 0 marking beginning and 1\r\n   * marking end of the available data range.\r\n   *\r\n   * This method will not have any effect when called on a chart object.\r\n   * Since the chart can have a number of axes and series, each with its own\r\n   * data, the meaning of \"range\" is very ambiguous.\r\n   *\r\n   * To zoom the chart use `zoom*` methods on its respective axes.\r\n   *\r\n   * @param range          Range\r\n   * @param skipRangeEvent Should rangechanged event not be triggered?\r\n   * @param instantly      Do not animate?\r\n   * @return Actual modidied range (taking `maxZoomFactor` into account)\r\n   */\n\n  Component.prototype.zoom = function (range, skipRangeEvent, instantly, declination) {\n    var _this = this;\n\n    if (skipRangeEvent === void 0) {\n      skipRangeEvent = false;\n    }\n\n    if (instantly === void 0) {\n      instantly = false;\n    }\n\n    var start = range.start;\n    var end = range.end;\n    var priority = range.priority;\n\n    if (priority == \"end\" && end == 1 && start != 0) {\n      if (start < this.start) {\n        priority = \"start\";\n      }\n    }\n\n    if (priority == \"start\" && start == 0) {\n      if (end > this.end) {\n        priority = \"end\";\n      }\n    }\n\n    if (!$type.isNumber(declination)) {\n      declination = this.maxZoomDeclination;\n    }\n\n    if (!$type.isNumber(start) || !$type.isNumber(end)) {\n      return {\n        start: this.start,\n        end: this.end\n      };\n    }\n\n    if (this._finalStart != start || this._finalEnd != end) {\n      var maxZoomFactor = this.maxZoomFactor / this.minZoomCount;\n      var minZoomFactor = this.maxZoomFactor / this.maxZoomCount; // most likely we are dragging left scrollbar grip here, so we tend to modify end\n\n      if (priority == \"start\") {\n        if (this.maxZoomCount > 0) {\n          // add to the end\n          if (1 / (end - start) < minZoomFactor) {\n            end = start + 1 / minZoomFactor;\n          }\n        } // add to the end\n\n\n        if (1 / (end - start) > maxZoomFactor) {\n          end = start + 1 / maxZoomFactor;\n        } //unless end is > 0\n\n\n        if (end > 1 && end - start < 1 / maxZoomFactor) {\n          //end = 1;\n          start = end - 1 / maxZoomFactor;\n        }\n      } // most likely we are dragging right, so we modify left\n      else {\n          if (this.maxZoomCount > 0) {\n            // add to the end\n            if (1 / (end - start) < minZoomFactor) {\n              start = end - 1 / minZoomFactor;\n            }\n          } // remove from start\n\n\n          if (1 / (end - start) > maxZoomFactor) {\n            start = end - 1 / maxZoomFactor;\n          }\n\n          if (start < 0 && end - start < 1 / maxZoomFactor) {\n            //start = 0;\n            end = start + 1 / maxZoomFactor;\n          }\n        }\n\n      if (start < -declination) {\n        start = -declination;\n      }\n\n      if (1 / (end - start) > maxZoomFactor) {\n        end = start + 1 / maxZoomFactor;\n      }\n\n      if (end > 1 + declination) {\n        end = 1 + declination;\n      }\n\n      if (1 / (end - start) > maxZoomFactor) {\n        start = end - 1 / maxZoomFactor;\n      }\n\n      this._finalEnd = end;\n      this._finalStart = start;\n      this.skipRangeEvent = skipRangeEvent;\n\n      if (this.rangeChangeDuration > 0 && !instantly) {\n        // todo: maybe move this to Animation\n        var rangeChangeAnimation = this.rangeChangeAnimation;\n\n        if (rangeChangeAnimation && rangeChangeAnimation.progress < 1) {\n          var options = rangeChangeAnimation.animationOptions;\n\n          if (options.length > 1) {\n            if (options[0].to == start && options[1].to == end) {\n              return {\n                start: start,\n                end: end\n              };\n            } else {\n              if (!rangeChangeAnimation.isDisposed()) {\n                rangeChangeAnimation.stop();\n              }\n            }\n          }\n        }\n\n        this.dispatchImmediately(\"rangechangestarted\");\n\n        if (this.rangeChangeAnimation) {\n          this.rangeChangeAnimation.kill();\n        }\n\n        rangeChangeAnimation = this.animate([{\n          property: \"start\",\n          to: start\n        }, {\n          property: \"end\",\n          to: end\n        }], this.rangeChangeDuration, this.rangeChangeEasing);\n        this.rangeChangeAnimation = rangeChangeAnimation;\n\n        if (rangeChangeAnimation && !rangeChangeAnimation.isFinished()) {\n          rangeChangeAnimation.events.on(\"animationended\", function () {\n            _this.dispatchImmediately(\"rangechangeended\");\n          });\n        } else {\n          this.dispatchImmediately(\"rangechangeended\");\n        }\n      } else {\n        this.start = start;\n        this.end = end;\n      }\n    }\n\n    return {\n      start: start,\n      end: end\n    };\n  };\n  /**\r\n   * Zooms to specific data items using their index in data.\r\n   *\r\n   * This method will not have any effect when called on a chart object.\r\n   * Since the chart can have a number of axes and series, each with its own\r\n   * data, the meaning of \"index\" is very ambiguous.\r\n   *\r\n   * To zoom the chart use `zoom*` methods on its respective axes.\r\n   *\r\n   * @param startIndex     Index of the starting data item\r\n   * @param endIndex       Index of the ending data item\r\n   * @param skipRangeEvent Should rangechanged event not be triggered?\r\n   * @param instantly      Do not animate?\r\n   */\n\n\n  Component.prototype.zoomToIndexes = function (startIndex, endIndex, skipRangeEvent, instantly) {\n    if (!$type.isNumber(startIndex) || !$type.isNumber(endIndex)) {\n      return;\n    }\n\n    var start = startIndex / this.dataItems.length;\n    var end = endIndex / this.dataItems.length;\n    this.zoom({\n      start: start,\n      end: end\n    }, skipRangeEvent, instantly);\n  };\n\n  Object.defineProperty(Component.prototype, \"zoomFactor\", {\n    /**\r\n     * A current zoom factor (0-1). 1 meaning fully zoomed out. (showing all of\r\n     * the available data)\r\n     *\r\n     * @return Zoom factor\r\n     */\n    get: function () {\n      return $math.fitToRange(1 / (this.end - this.start), 1, this.maxZoomFactor);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Component.prototype, \"maxZoomFactor\", {\n    /**\r\n     * @return Maximum zoomFactor\r\n     */\n    get: function () {\n      return this.getPropertyValue(\"maxZoomFactor\");\n    },\n\n    /**\r\n     * Max available `zoomFactor`.\r\n     *\r\n     * The element will not allow zoom to occur beyond this factor.\r\n     *\r\n     * [[DateAxis]] and [[CategoryAxis]] calculate this atutomatically so that\r\n     * category axis could be zoomed to one category and date axis allows to be\r\n     * zoomed up to one base interval.\r\n     *\r\n     * In case you want to restrict category or date axis to be zoomed to more\r\n     * than one category or more than one base interval, use `minZoomCount`\r\n     * property (set it to `> 1`).\r\n     *\r\n     * Default value of [[ValueAxis]]'s `maxZoomFactor` is `1000`.\r\n     *\r\n     * Feel free to modify it to allow bigger zoom or to restrict zooming.\r\n     *\r\n     * @param value  Maximum zoomFactor\r\n     */\n    set: function (value) {\n      if (this.setPropertyValue(\"maxZoomFactor\", value)) {\n        if (value == 1) {\n          this.maxZoomDeclination = 0;\n        }\n\n        this.invalidateDataRange();\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Component.prototype, \"maxZoomDeclination\", {\n    /**\r\n     * @ignore\r\n     * @return Maximum zoom declination\r\n     */\n    get: function () {\n      return this.getPropertyValue(\"maxZoomDeclination\");\n    },\n\n    /**\r\n     * Max zoom declination.\r\n     *\r\n     * @ignore\r\n     * @default 1\r\n     * @param value  Maximum zoom declination\r\n     */\n    set: function (value) {\n      if (this.setPropertyValue(\"maxZoomDeclination\", value)) {\n        this.invalidateDataRange();\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Component.prototype, \"startIndex\", {\n    /**\r\n     * Current starting index.\r\n     *\r\n     * @return Start index\r\n     */\n    get: function () {\n      if (!$type.isNumber(this._startIndex)) {\n        this._startIndex = 0;\n      }\n\n      return this._startIndex;\n    },\n\n    /**\r\n     * Sets current starting index.\r\n     *\r\n     * @ignore Exclude from docs\r\n     * @param value Start index\r\n     */\n    set: function (value) {\n      this._startIndex = $math.fitToRange(Math.round(value), 0, this.dataItems.length); //this._workingStartIndex = this._startIndex; // not good, breaks adjusted working start index of line series\n\n      this.start = this.indexToPosition(this._startIndex);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\r\n   * @ignore\r\n   * @todo:review description\r\n   * returns item's relative position by the index of the item\r\n   * @param index\r\n   */\n\n  Component.prototype.indexToPosition = function (index) {\n    return index / this.dataItems.length;\n  };\n\n  Object.defineProperty(Component.prototype, \"endIndex\", {\n    /**\r\n     * Current ending index.\r\n     *\r\n     * @return End index\r\n     */\n    get: function () {\n      var count = this.dataItems.length;\n\n      if (!$type.isNumber(this._endIndex) || this._endIndex > count) {\n        this._endIndex = count;\n      }\n\n      return this._endIndex;\n    },\n\n    /**\r\n     * Sets current ending index.\r\n     *\r\n     * @ignore Exclude from docs\r\n     * @param value End index\r\n     */\n    set: function (value) {\n      this._endIndex = $math.fitToRange(Math.round(value), 0, this.dataItems.length); //this._workingEndIndex = this._endIndex; // not good, breaks adjusted workingend index of line series\n\n      this.end = this.indexToPosition(this._endIndex);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Component.prototype, \"start\", {\n    /**\r\n     * @return Start (0-1)\r\n     */\n    get: function () {\n      if (!this._adapterO) {\n        return this._start;\n      } else {\n        return this._adapterO.apply(\"start\", this._start);\n      }\n    },\n\n    /**\r\n     * Start of the current data range (zoom).\r\n     *\r\n     * These are relative values from 0 (beginning) to 1 (end).\r\n     *\r\n     * @param value Start (0-1)\r\n     */\n    set: function (value) {\n      // value = $math.round(value, 10); not good\n      //if (1 / (this.end - value) > this.maxZoomFactor) {\n      //\tvalue = this.end - 1 / this.maxZoomFactor;\n      //}\n      if (this._start != value) {\n        this._start = value;\n        var startIndex = Math.max(0, Math.floor(this.dataItems.length * value) || 0);\n        this._startIndex = Math.min(startIndex, this.dataItems.length);\n        this.invalidateDataRange();\n        this.invalidate();\n        this.dispatchImmediately(\"startchanged\");\n        this.dispatch(\"startendchanged\");\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Component.prototype, \"end\", {\n    /**\r\n     * @return End (0-1)\r\n     */\n    get: function () {\n      if (!this._adapterO) {\n        return this._end;\n      } else {\n        return this._adapterO.apply(\"end\", this._end);\n      }\n    },\n\n    /**\r\n     * End of the current data range (zoom).\r\n     *\r\n     * These are relative values from 0 (beginning) to 1 (end).\r\n     *\r\n     * @param value End (0-1)\r\n     */\n    set: function (value) {\n      // value = $math.round(value, 10); // not good\n      //if (1 / (value - this.start) > this.maxZoomFactor) {\n      //\tvalue = 1 / this.maxZoomFactor + this.start;\n      //}\n      if (this._end != value) {\n        this._end = value;\n        this._endIndex = Math.min(this.dataItems.length, Math.ceil(this.dataItems.length * value) || 0);\n        this.invalidateDataRange();\n        this.invalidate();\n        this.dispatchImmediately(\"endchanged\");\n        this.dispatch(\"startendchanged\");\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\r\n   * [removeFromInvalids description]\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @todo Description\r\n   */\n\n  Component.prototype.removeFromInvalids = function () {\n    _super.prototype.removeFromInvalids.call(this);\n\n    registry.removeFromInvalidComponents(this);\n    $array.remove(registry.invalidDataItems, this);\n    $array.remove(registry.invalidDataRange, this);\n    $array.remove(registry.invalidRawDatas, this);\n  };\n\n  Object.defineProperty(Component.prototype, \"dataItems\", {\n    /**\r\n     * Returns a list of source [[DataItem]] objects currently used in the chart.\r\n     *\r\n     * @return List of data items\r\n     */\n    get: function () {\n      if (this._currentDataSetId != \"\") {\n        var dataItems = this.dataSets.getKey(this._currentDataSetId);\n\n        if (dataItems) {\n          return dataItems;\n        }\n      }\n\n      return this._dataItems;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Component.prototype, \"dataSets\", {\n    /**\r\n     * Holds data items for data sets (usually aggregated data).\r\n     *\r\n     * @ignore\r\n     * @since 4.7.0\r\n     * @return  Data sets\r\n     */\n    get: function () {\n      if (!this._dataSets) {\n        this._dataSets = new Dictionary();\n      }\n\n      return this._dataSets;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\r\n   * Makes the chart use particular data set.\r\n   *\r\n   * If `id` is not provided or there is no such data set, main data will be\r\n   * used.\r\n   *\r\n   * @ignore\r\n   * @since 4.7.0\r\n   * @param  id  Data set id\r\n   */\n\n  Component.prototype.setDataSet = function (id) {\n    if (this._currentDataSetId != id) {\n      var dataSet = this.dataSets.getKey(id);\n\n      if (!dataSet) {\n        if (this._currentDataSetId != \"\") {\n          this.dataItems.each(function (dataItem) {\n            dataItem.__disabled = true;\n          });\n          this._currentDataSetId = \"\";\n          this.invalidateDataRange();\n          this._prevStartIndex = undefined;\n          this.dataItems.each(function (dataItem) {\n            dataItem.__disabled = false;\n          });\n          return true;\n        }\n      } else {\n        this.dataItems.each(function (dataItem) {\n          dataItem.__disabled = true;\n        });\n        this._currentDataSetId = id;\n        this.invalidateDataRange();\n        this._prevStartIndex = undefined;\n        this.dataItems.each(function (dataItem) {\n          dataItem.__disabled = false;\n        });\n        return true;\n      }\n    }\n\n    return false;\n  };\n\n  Object.defineProperty(Component.prototype, \"currentDataSetId\", {\n    /**\r\n     * Returns id of the currently used data set, or `undefined` if main data set\r\n     * is in use.\r\n     *\r\n     * @since 4.7.0\r\n     * @return Current data set id\r\n     */\n    get: function () {\n      return this._currentDataSetId;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Component.prototype, \"mainDataSet\", {\n    /**\r\n     * Returns reference to \"main\" data set (unaggregated data as it was supplied\r\n     * in `data`).\r\n     *\r\n     * @since 4.7.0\r\n     * @return Main data set\r\n     */\n    get: function () {\n      return this._dataItems;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\r\n   * Updates the indexes for the dataItems\r\n   *\r\n   * @ignore Exclude from docs\r\n   */\n\n  Component.prototype._updateDataItemIndexes = function (startIndex) {\n    var dataItems = this.mainDataSet.values;\n    var length = dataItems.length;\n\n    for (var i = startIndex; i < length; ++i) {\n      dataItems[i]._index = i;\n    }\n  };\n  /**\r\n   * Processes newly added [[DataItem]] as well as triggers data re-validation.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param event [description]\r\n   */\n\n\n  Component.prototype.handleDataItemAdded = function (event) {\n    event.newValue.component = this;\n\n    this._updateDataItemIndexes(event.index);\n\n    if (!this.dataItemsInvalid) {\n      this.invalidateDataItems();\n    }\n  };\n  /**\r\n   * removes [[DataItem]] as well as triggers data re-validation.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param event [description]\r\n   */\n\n\n  Component.prototype.handleDataItemRemoved = function (event) {\n    //\t\tevent.oldValue.component = undefined; // not good, as some items might be not removed from component lists\n    this._updateDataItemIndexes(event.index);\n\n    if (!this.dataItemsInvalid) {\n      this.invalidateDataItems();\n    }\n  };\n  /**\r\n   * Binds a data element's field to a specific field in raw data.\r\n   * For example, for the very basic column chart you'd want to bind a `value`\r\n   * field to a field in data, such as `price`.\r\n   *\r\n   * Some more advanced Components, like [[CandlestickSeries]] need several\r\n   * data fields bound to data, such as ones for open, high, low and close\r\n   * values.\r\n   *\r\n   * @todo Example\r\n   * @param field  Field name\r\n   * @param value  Field name in data\r\n   */\n\n\n  Component.prototype.bindDataField = function (field, value) {\n    this.dataFields[field] = value;\n    this.invalidateDataRange();\n  };\n  /**\r\n   * Invalidates processed data.\r\n   *\r\n   * @ignore Exclude from docs\r\n   */\n\n\n  Component.prototype.invalidateProcessedData = function () {\n    this.resetProcessedRange();\n    this.invalidateDataRange();\n  };\n  /**\r\n   * [resetProcessedRange description]\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @todo Description\r\n   */\n\n\n  Component.prototype.resetProcessedRange = function () {\n    this._prevEndIndex = null;\n    this._prevStartIndex = null;\n  };\n\n  Object.defineProperty(Component.prototype, \"dataUsers\", {\n    /**\r\n     * Returns all other [[Component]] objects that are using this element's\r\n     * data.\r\n     *\r\n     * @ignore Exclude from docs\r\n     * @todo Description (review)\r\n     * @return [description]\r\n     */\n    get: function () {\n      var _this = this;\n\n      if (!this._dataUsers) {\n        this._dataUsers = new List(); //this._disposers.push(new ListDisposer(this._dataUsers));\n        // TODO better way of handling this? e.g. move into another module ?\n\n        this._disposers.push(new Disposer(function () {\n          // TODO clear the list ?\n          $iter.each(_this._dataUsers.iterator(), function (x) {\n            x.dispose();\n          });\n        }));\n      }\n\n      return this._dataUsers;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\r\n   * Returns a clone of this element.\r\n   *\r\n   * @return Clone\r\n   */\n\n  Component.prototype.clone = function () {\n    var component = _super.prototype.clone.call(this);\n\n    component.dataFields = $utils.copyProperties(this.dataFields, {});\n    return component;\n  };\n  /**\r\n   * Copies all parameters from another [[Component]].\r\n   *\r\n   * @param source Source Component\r\n   */\n\n\n  Component.prototype.copyFrom = function (source) {\n    _super.prototype.copyFrom.call(this, source);\n\n    this.data = source.data;\n    this.sequencedInterpolation = source.sequencedInterpolation;\n    this.sequencedInterpolationDelay = source.sequencedInterpolationDelay;\n    this.interpolationDuration = source.interpolationDuration;\n    this.interpolationEasing = source.interpolationEasing;\n  };\n  /**\r\n   * Invalidates the whole element, including all its children, causing\r\n   * complete re-parsing of data and redraw.\r\n   *\r\n   * Use sparingly!\r\n   */\n\n\n  Component.prototype.reinit = function () {\n    this._inited = false;\n    this.deepInvalidate();\n  };\n  /**\r\n   * Add an adapter for data.\r\n   *\r\n   * @return Exporting\r\n   */\n\n\n  Component.prototype.getExporting = function () {\n    var _export = _super.prototype.getExporting.call(this);\n\n    if (!_export.adapter.has(\"data\", this._exportData, -1, this)) {\n      _export.adapter.add(\"data\", this._exportData, -1, this);\n\n      this.events.on(\"datavalidated\", function (ev) {\n        if (_export.menu) {\n          _export.menu.invalidate();\n        }\n\n        _export.handleDataUpdated();\n      });\n    }\n\n    return _export;\n  };\n\n  Component.prototype._exportData = function (arg) {\n    arg.data = this.data;\n    return arg;\n  };\n\n  Component.prototype.setDisabled = function (value) {\n    var changed = _super.prototype.setDisabled.call(this, value);\n\n    if (changed) {\n      this.invalidateData();\n    }\n\n    return changed;\n  };\n  /**\r\n   * @ignore\r\n   */\n\n\n  Component.prototype.setShowOnInit = function (value) {\n    if (value != this.getPropertyValue(\"showOnInit\")) {\n      if (value && !this.inited && !this.hidden) {\n        this._showOnInitDisposer2 = this.events.once(\"dataitemsvalidated\", this.hideInitially, this, false);\n\n        this._disposers.push(this._showOnInitDisposer2);\n      } else {\n        if (this._showOnInitDisposer2) {\n          this.removeDispose(this._showOnInitDisposer2);\n        }\n      }\n    } // important order here\n\n\n    _super.prototype.setShowOnInit.call(this, value);\n  };\n\n  Component.prototype.setBaseId = function (value) {\n    if (value != this._baseId) {\n      if (this.dataInvalid) {\n        this.dataInvalid = false;\n        registry.removeFromInvalidComponents(this);\n        this._baseId = value;\n        this.invalidateData();\n      }\n    }\n\n    _super.prototype.setBaseId.call(this, value);\n  };\n\n  Object.defineProperty(Component.prototype, \"minZoomCount\", {\n    /**\r\n     * @return Min zoom count\r\n     */\n    get: function () {\n      return this.getPropertyValue(\"minZoomCount\");\n    },\n\n    /**\r\n     * Use this for [[CategoryAxis]] or [[DateAxis]].\r\n     *\r\n     * Allows restricting zoom in beyond certain number of categories or base\r\n     * intervals.\r\n     *\r\n     * @default 1\r\n     * @param value  Min zoom count\r\n     */\n    set: function (value) {\n      this.setPropertyValue(\"minZoomCount\", value);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Component.prototype, \"maxZoomCount\", {\n    /**\r\n     * @return Max zoom count\r\n     */\n    get: function () {\n      return this.getPropertyValue(\"maxZoomCount\");\n    },\n\n    /**\r\n     * Use this for [[CategoryAxis]] or [[DateAxis]].\r\n     *\r\n     * Limits how many categories or base intervals can be shown at the same\r\n     * time.\r\n     *\r\n     * If there are more items in the chart, the chart will auto-zoom.\r\n     *\r\n     * @default 0 (no limit)\r\n     * @since 4.6.2\r\n     * @param value  Max zoom count\r\n     */\n    set: function (value) {\n      this.setPropertyValue(\"maxZoomCount\", value);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\r\n   * Called during the System.update method\r\n   *\r\n   * @ignore Exclude from docs\r\n   */\n\n  Component.prototype._systemCheckIfValidate = function () {\n    if (this.dataInvalid || this.dataProvider && this.dataProvider.dataInvalid) {\n      return false;\n    } else {\n      return true;\n    }\n  };\n  /**\r\n   * Adds easing functions to \"function\" fields.\r\n   *\r\n   * @param field  Field name\r\n   * @return Assign as function?\r\n   */\n\n\n  Component.prototype.asFunction = function (field) {\n    return field == \"interpolationEasing\" || field == \"rangeChangeEasing\" || _super.prototype.asIs.call(this, field);\n  };\n\n  return Component;\n}(Container);\n\nexport { Component };\n/**\r\n * Register class in system, so that it can be instantiated using its name from\r\n * anywhere.\r\n *\r\n * @ignore\r\n */\n\nregistry.registeredClasses[\"Component\"] = Component;","map":null,"metadata":{},"sourceType":"module"}