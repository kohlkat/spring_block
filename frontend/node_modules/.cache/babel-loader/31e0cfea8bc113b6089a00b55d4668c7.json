{"ast":null,"code":"/**\r\n * A collection of Math-related functions\r\n *\r\n * @todo Comment trigonometric functions?\r\n */\nimport * as $type from \"./Type\";\n/**\r\n * ============================================================================\r\n * CONSTANTS\r\n * ============================================================================\r\n * @hidden\r\n */\n\nexport var PI = Math.PI;\nexport var HALFPI = PI / 2;\nexport var RADIANS = PI / 180;\nexport var DEGREES = 180 / PI;\n/**\r\n * Converts any value and fits it into a specific value range.\r\n *\r\n * @param value  Source value\r\n * @param min    Minimum allowable value\r\n * @param max    Maximum allowable value\r\n * @return Number\r\n */\n\nexport function toNumberRange(value, min, max) {\n  if ($type.hasValue(value)) {\n    value = $type.toNumber(value);\n    return fitToRange(value, min, max);\n  }\n\n  return value;\n}\n/**\r\n * Rounds the numeric value to whole number or specific precision of set.\r\n *\r\n * @param value      Value\r\n * @param precision  Precision (number of decimal points)\r\n * @param floor  In case value ends with 0.5 and precision is 0, we might need to floor the value instead of ceiling it.\r\n * @return Rounded value\r\n */\n\nexport function round(value, precision, floor) {\n  if (!$type.isNumber(precision) || precision <= 0) {\n    var rounded = Math.round(value);\n\n    if (floor) {\n      if (rounded - value == 0.5) {\n        rounded--;\n      }\n    }\n\n    return rounded;\n  } else {\n    var d = Math.pow(10, precision);\n    return Math.round(value * d) / d;\n  }\n}\n/**\r\n * Ceils the numeric value to whole number or specific precision of set.\r\n *\r\n * @param value      Value\r\n * @param precision  Precision (number of decimal points)\r\n * @return Rounded value\r\n */\n\nexport function ceil(value, precision) {\n  if (!$type.isNumber(precision) || precision <= 0) {\n    return Math.ceil(value);\n  } else {\n    var d = Math.pow(10, precision);\n    return Math.ceil(value * d) / d;\n  }\n}\n/**\r\n * Stretches `t` so that it will always be between `from` and `to`.\r\n *\r\n * @param t     Number from 0 to 1\r\n * @param from  Lowest possible value\r\n * @param to    Highest possible value\r\n * @return Adjusted value\r\n */\n\nexport function stretch(t, from, to) {\n  return t * (to - from) + from;\n}\n/**\r\n * Adjust numeric value so it fits to specific value range.\r\n *\r\n * @param value     Value\r\n * @param minValue  Lowest possible value\r\n * @param maxValue  Highest possible value\r\n * @return Adjusted value\r\n */\n\nexport function fitToRange(value, minValue, maxValue) {\n  if ($type.isNumber(minValue)) {\n    if ($type.isNumber(maxValue) && maxValue < minValue) {\n      var temp = maxValue;\n      maxValue = minValue;\n      minValue = temp;\n    }\n\n    if (value < minValue) {\n      value = minValue;\n    }\n  }\n\n  if ($type.isNumber(maxValue)) {\n    if (value > maxValue) {\n      value = maxValue;\n    }\n  }\n\n  return value;\n}\n/**\r\n * Returns sine of a number.\r\n *\r\n * @param value  Value\r\n * @return Sine\r\n */\n\nexport function sin(value) {\n  return round(Math.sin(RADIANS * value), 10);\n}\n/**\r\n * Returns tan of a number.\r\n *\r\n * @param value  Value\r\n * @return Sine\r\n */\n\nexport function tan(value) {\n  return round(Math.tan(RADIANS * value), 10);\n}\n/**\r\n * Returns cosine of a number.\r\n *\r\n * @param value  Value\r\n * @return Cosine\r\n */\n\nexport function cos(value) {\n  return round(Math.cos(RADIANS * value), 10);\n}\nexport function max(left, right) {\n  if ($type.isNumber(left)) {\n    if ($type.isNumber(right)) {\n      if (right > left) {\n        return right;\n      } else {\n        return left;\n      }\n    } else {\n      return left;\n    }\n  } else if ($type.isNumber(right)) {\n    return right;\n  } else {\n    return null;\n  }\n}\nexport function min(left, right) {\n  if ($type.isNumber(left)) {\n    if ($type.isNumber(right)) {\n      if (right < left) {\n        return right;\n      } else {\n        return left;\n      }\n    } else {\n      return left;\n    }\n  } else if ($type.isNumber(right)) {\n    return right;\n  } else {\n    return null;\n  }\n}\n/**\r\n * Returns the closest value from the array of values to the reference value.\r\n *\r\n * @param values  Array of values\r\n * @param value   Reference value\r\n * @return Closes value from the array\r\n */\n\nexport function closest(values, referenceValue) {\n  return values.reduce(function (prev, curr) {\n    return Math.abs(curr - referenceValue) < Math.abs(prev - referenceValue) ? curr : prev;\n  });\n}\n/**\r\n * Checks whether two ranges of values intersect.\r\n *\r\n * @param range1  Range 1\r\n * @param range2  Range 2\r\n * @return Any intersecting numbers?\r\n */\n\nexport function intersect(range1, range2) {\n  var start1 = $type.getValue(range1.start);\n  var start2 = $type.getValue(range2.start);\n  var end1 = $type.getValue(range1.end);\n  var end2 = $type.getValue(range2.end);\n  return Math.max(start1, start2) <= Math.min(end1, end2);\n}\n/**\r\n * Inverts the range of values.\r\n *\r\n * @param range  Range\r\n */\n\nexport function invertRange(range) {\n  var start = $type.getValue(range.start);\n  var end = $type.getValue(range.end);\n  return {\n    start: 1 - end,\n    end: 1 - start\n  };\n}\n/**\r\n * Returns an intersection range between two ranges of values.\r\n *\r\n * @param range1  Range 1\r\n * @param range2  Range 2\r\n * @return Intersecting value range\r\n */\n\nexport function intersection(range1, range2) {\n  var start1 = $type.getValue(range1.start);\n  var start2 = $type.getValue(range2.start);\n  var end1 = $type.getValue(range1.end);\n  var end2 = $type.getValue(range2.end);\n  var startMax = Math.max(start1, start2);\n  var endMin = Math.min(end1, end2);\n\n  if (endMin < startMax) {\n    return undefined;\n  } else {\n    return {\n      start: startMax,\n      end: endMin\n    };\n  }\n}\n/**\r\n * Returns pixel \"distance\" between two points.\r\n *\r\n * If second point is not specified, distance from {x:0, y:0} point is\r\n * calculated.\r\n *\r\n * @param point1  Point 1\r\n * @param point2  Point 2\r\n * @return Distance in relative pixels\r\n */\n\nexport function getDistance(point1, point2) {\n  if (!point1) {\n    return 0;\n  }\n\n  if (!point2) {\n    point2 = {\n      x: 0,\n      y: 0\n    };\n  }\n\n  return Math.sqrt(Math.pow(Math.abs(point1.x - point2.x), 2) + Math.pow(Math.abs(point1.y - point2.y), 2));\n}\n/**\r\n * Returns approximate pixel \"distance\" between two points of cubic curve\r\n *\r\n * If second point is not specified, distance from {x:0, y:0} point is\r\n * calculated.\r\n *\r\n * @param point1  Point 1\r\n * @param point2  Point 2\r\n * @param controlPointA  Control Point 1\r\n * @param controlPointB  Control Point 2\r\n * @param stepCount  number of steps (the more, the more accurate result)\r\n * @return Distance in relative pixels\r\n */\n\nexport function getCubicCurveDistance(point1, point2, controlPointA, controlPointB, stepCount) {\n  if (!point1) {\n    return 0;\n  }\n\n  if (!point2) {\n    point2 = {\n      x: 0,\n      y: 0\n    };\n  }\n\n  var distance = 0;\n  var prevPoint = point1;\n\n  if (stepCount > 0) {\n    for (var s = 0; s <= stepCount; s++) {\n      var point = getPointOnCubicCurve(point1, point2, controlPointA, controlPointB, s / stepCount);\n      distance += getDistance(prevPoint, point);\n      prevPoint = point;\n    }\n  }\n\n  return distance;\n}\n/**\r\n * Returns scale based on original and end position of the two points.\r\n *\r\n * @param point1       Current position of point 1\r\n * @param startPoint1  Start position of point 1\r\n * @param point2       Current position of point 1\r\n * @param startPoint2  Start position of point 2\r\n * @return Scale        Calculated scale\r\n */\n\nexport function getScale(point1, startPoint1, point2, startPoint2) {\n  var initialDistance = getDistance(startPoint1, startPoint2);\n  var currentDistance = getDistance(point1, point2);\n  return Math.abs(currentDistance / initialDistance);\n}\n/**\r\n * Returns an exact mid point between two points.\r\n *\r\n * @param point1     Position of point 1\r\n * @param point2     Position of point 2\r\n * @return Mid point  Position of mid-point\r\n */\n\nexport function getMidPoint(point1, point2, position) {\n  if (!$type.isNumber(position)) {\n    position = 0.5;\n  }\n\n  return {\n    \"x\": point1.x + (point2.x - point1.x) * position,\n    \"y\": point1.y + (point2.y - point1.y) * position\n  };\n}\n/**\r\n * Returns difference in angles between starting and ending position of two\r\n * vectors.\r\n *\r\n * @param point1       Current position of point 1\r\n * @param startPoint1  Start position of point 1\r\n * @param point2       Current position of point 1\r\n * @param startPoint2  Start position of point 2\r\n * @return Angle difference in degrees\r\n */\n\nexport function getRotation(point1, startPoint1, point2, startPoint2) {\n  // Get start and end angles\n  var startAngle = getAngle(startPoint1, startPoint2);\n  var angle = getAngle(point1, point2); // Calculate angle\n\n  var diff = startAngle - angle;\n\n  if (diff < 0) {\n    diff += 360;\n  }\n\n  return diff;\n}\n/**\r\n * Calculates angle of the vector based on two or one point.\r\n *\r\n * @param point1  Point 1\r\n * @param point2  Point 2\r\n * @return Angle in degrees\r\n */\n\nexport function getAngle(point1, point2) {\n  if (!point2) {\n    point2 = {\n      x: point1.x * 2,\n      y: point1.y * 2\n    };\n  }\n\n  var diffX = point2.x - point1.x;\n  var diffY = point2.y - point1.y;\n  var angle = Math.atan2(diffY, diffX) * DEGREES;\n\n  if (angle < 0) {\n    angle += 360;\n  }\n\n  return normalizeAngle(angle);\n}\n/**\r\n * Returns the shift in coordinates of the center when item is rotated, moved\r\n * and scaled at the same time.\r\n *\r\n * @param center       Current center\r\n * @param point1       Frst reference point\r\n * @param startPoint1  Original position of the first reference point\r\n * @param point2       Second reference point\r\n * @param startPoint2  Original position of the first reference point\r\n * @return Shift in center point coordinates\r\n */\n\nexport function getCenterShift(center, point1, startPoint1, point2, startPoint2) {\n  // Get angle\n  var angle = getRotation(point1, startPoint1, point2, startPoint2) - 90;\n\n  if (angle < 0) {\n    angle += 360;\n  } // Get distance between new position\n\n\n  var distance = getDistance(point1, point2); // Calculate new X\n\n  var x = Math.cos(angle) / distance + point1.x;\n  var y = Math.cos(angle) / distance + point1.y;\n  var shift = {\n    \"x\": x - center.x,\n    \"y\": y - center.y\n  };\n  return shift;\n}\n/**\r\n * Converts an array of points into a bounding box rectangle.\r\n *\r\n * Array can contain any number of points.\r\n *\r\n * @param points  Points\r\n * @return Bounding box rectangle\r\n */\n\nexport function getBBox(points) {\n  if (points) {\n    var length_1 = points.length;\n\n    if (length_1 !== 0) {\n      var left = void 0;\n      var right = void 0;\n      var top_1;\n      var bottom = void 0;\n\n      for (var i = 0; i < length_1; i++) {\n        var point = points[i];\n\n        if (!$type.isNumber(right) || point.x > right) {\n          right = point.x;\n        }\n\n        if (!$type.isNumber(left) || point.x < left) {\n          left = point.x;\n        }\n\n        if (!$type.isNumber(top_1) || point.y < top_1) {\n          top_1 = point.y;\n        }\n\n        if (!$type.isNumber(bottom) || point.y > bottom) {\n          bottom = point.y;\n        }\n      }\n\n      return {\n        x: left,\n        y: top_1,\n        width: right - left,\n        height: bottom - top_1\n      };\n    }\n  }\n\n  return {\n    x: 0,\n    y: 0,\n    width: 0,\n    height: 0\n  };\n}\n/**\r\n * Returns a [[IRectangle]] object representing a common rectangle that fits\r\n * all passed in rectangles in it.\r\n *\r\n * @param rectangles  An array of rectangles\r\n * @return Common rectangle\r\n */\n\nexport function getCommonRectangle(rectangles) {\n  var length = rectangles.length;\n\n  if (length !== 0) {\n    var minX = void 0;\n    var minY = void 0;\n    var maxX = void 0;\n    var maxY = void 0;\n\n    for (var i = 0; i < length; i++) {\n      var rectangle = rectangles[i];\n      minX = min(rectangle.x, minX);\n      minY = min(rectangle.y, minY);\n      maxX = max(rectangle.x + rectangle.width, maxX);\n      maxY = max(rectangle.y + rectangle.height, maxY);\n    }\n\n    return {\n      x: minX,\n      y: minY,\n      width: maxX - minX,\n      height: maxY - minY\n    };\n  }\n}\n/**\r\n * [getPointOnQuadraticCurve description]\r\n *\r\n * @ignore Exclude from docs\r\n * @todo Description\r\n * @param pointA        [description]\r\n * @param pointB        [description]\r\n * @param controlPoint  [description]\r\n * @param position      [description]\r\n * @return [description]\r\n */\n\nexport function getPointOnQuadraticCurve(pointA, pointB, controlPoint, position) {\n  var x = (1 - position) * (1 - position) * pointA.x + 2 * (1 - position) * position * controlPoint.x + position * position * pointB.x;\n  var y = (1 - position) * (1 - position) * pointA.y + 2 * (1 - position) * position * controlPoint.y + position * position * pointB.y;\n  return {\n    x: x,\n    y: y\n  };\n}\n/**\r\n * [getPointOnCubicCurve description]\r\n *\r\n * @ignore Exclude from docs\r\n * @todo Description\r\n * @param pointA         [description]\r\n * @param pointB         [description]\r\n * @param controlPointA  [description]\r\n * @param controlPointB  [description]\r\n * @param position       [description]\r\n * @return [description]\r\n */\n\nexport function getPointOnCubicCurve(pointA, pointB, controlPointA, controlPointB, position) {\n  var point = {\n    x: 0,\n    y: 0\n  };\n  var mt1 = 1 - position;\n  var mt2 = mt1 * mt1;\n  var mt3 = mt2 * mt1;\n  point.x = pointA.x * mt3 + controlPointA.x * 3 * mt2 * position + controlPointB.x * 3 * mt1 * position * position + pointB.x * position * position * position;\n  point.y = pointA.y * mt3 + controlPointA.y * 3 * mt2 * position + controlPointB.y * 3 * mt1 * position * position + pointB.y * position * position * position;\n  return point;\n}\n/**\r\n * [getCubicControlPointA description]\r\n *\r\n * @ignore Exclude from docs\r\n * @todo Description\r\n * @param p0        [description]\r\n * @param p1        [description]\r\n * @param p2        [description]\r\n * @param p3        [description]\r\n * @param tensionX  [description]\r\n * @param tensionY  [description]\r\n * @return [description]\r\n */\n\nexport function getCubicControlPointA(p0, p1, p2, p3, tensionX, tensionY) {\n  tensionX = adjustTension(tensionX);\n  tensionY = adjustTension(tensionY);\n  return {\n    x: (-p0.x + p1.x / tensionX + p2.x) * tensionX,\n    y: (-p0.y + p1.y / tensionY + p2.y) * tensionY\n  };\n}\n/**\r\n * [getCubicControlPointB description]\r\n *\r\n * @ignore Exclude from docs\r\n * @todo Description\r\n * @param p0        [description]\r\n * @param p1        [description]\r\n * @param p2        [description]\r\n * @param p3        [description]\r\n * @param tensionX  [description]\r\n * @param tensionY  [description]\r\n * @return [description]\r\n */\n\nexport function getCubicControlPointB(p0, p1, p2, p3, tensionX, tensionY) {\n  tensionX = adjustTension(tensionX);\n  tensionY = adjustTension(tensionY);\n  return {\n    x: (p1.x + p2.x / tensionX - p3.x) * tensionX,\n    y: (p1.y + p2.y / tensionY - p3.y) * tensionY\n  };\n}\n/**\r\n * [adjustTension description]\r\n *\r\n * @ignore Exclude from docs\r\n * @todo Description\r\n * @param tension  [description]\r\n * @return [description]\r\n */\n\nexport function adjustTension(tension) {\n  return 1 - tension + 0.00001;\n}\n/**\r\n * [normalizeAngle description]\r\n *\r\n * @ignore Exclude from docs\r\n * @todo Description\r\n * @param value  [description]\r\n * @return [description]\r\n */\n\nexport function normalizeAngle(value) {\n  if (value == 360) {\n    return 360;\n  }\n\n  return value % 360;\n}\n/**\r\n * [normalizeAngleToRange description]\r\n *\r\n * @ignore Exclude from docs\r\n * @todo Description\r\n * @todo review this with various angles, can be tested on radar chart with custom start/end angles\r\n * @param value       [description]\r\n * @param startAngle  [description]\r\n * @param endAngle    [description]\r\n * @return [description]\r\n */\n\nexport function fitAngleToRange(value, startAngle, endAngle) {\n  if (startAngle > endAngle) {\n    var temp = startAngle;\n    startAngle = endAngle;\n    endAngle = temp;\n  }\n\n  value = normalizeAngle(value);\n  var count = (startAngle - normalizeAngle(startAngle)) / 360;\n\n  if (value < startAngle) {\n    value += 360 * (count + 1);\n  }\n\n  var maxEnd = startAngle + (endAngle - startAngle) / 2 + 180;\n  var maxStart = startAngle + (endAngle - startAngle) / 2 - 180;\n\n  if (value > endAngle) {\n    if (value - 360 > startAngle) {\n      value -= 360;\n    } else {\n      if (value < maxEnd) {\n        value = endAngle;\n      } else {\n        value = startAngle;\n      }\n    }\n  }\n\n  if (value < startAngle) {\n    if (value > maxStart) {\n      value = startAngle;\n    } else {\n      value = endAngle;\n    }\n  }\n\n  return value;\n}\n/**\r\n * Returns [[IRectangle]] of an arc in relative values, assuming that the\r\n * center is at the circle center.\r\n *\r\n * Used to find out max radius of an arc.\r\n *\r\n * @ignore Exclude from docs\r\n * @param startAngle  Start angle\r\n * @param endAngle    End angle\r\n * @param radius    \t Relative radius\r\n * @return Rectangle\r\n */\n\nexport function getArcRect(startAngle, endAngle, radius) {\n  var minX = Number.MAX_VALUE;\n  var minY = Number.MAX_VALUE;\n  var maxX = -Number.MAX_VALUE;\n  var maxY = -Number.MAX_VALUE;\n  var bpoints = [];\n\n  if (!$type.isNumber(radius)) {\n    radius = 1;\n  }\n\n  bpoints.push(getArcPoint(radius, startAngle));\n  bpoints.push(getArcPoint(radius, endAngle));\n  var fromAngle = Math.min(Math.floor(startAngle / 90) * 90, Math.floor(endAngle / 90) * 90);\n  var toAngle = Math.max(Math.ceil(startAngle / 90) * 90, Math.ceil(endAngle / 90) * 90);\n\n  for (var angle = fromAngle; angle <= toAngle; angle += 90) {\n    if (angle >= startAngle && angle <= endAngle) {\n      bpoints.push(getArcPoint(radius, angle));\n    }\n  }\n\n  for (var i = 0; i < bpoints.length; i++) {\n    var pt = bpoints[i];\n\n    if (pt.x < minX) {\n      minX = pt.x;\n    }\n\n    if (pt.y < minY) {\n      minY = pt.y;\n    }\n\n    if (pt.x > maxX) {\n      maxX = pt.x;\n    }\n\n    if (pt.y > maxY) {\n      maxY = pt.y;\n    }\n  }\n\n  return {\n    x: minX,\n    y: minY,\n    width: maxX - minX,\n    height: maxY - minY\n  };\n}\n/**\r\n * Returns point on arc\r\n *\r\n * @param center point\r\n * @param radius\r\n * @param arc\r\n * @return {boolean}\r\n */\n\nexport function getArcPoint(radius, arc) {\n  return {\n    x: radius * cos(arc),\n    y: radius * sin(arc)\n  };\n}\n/**\r\n * Returns true if a point is within rectangle\r\n *\r\n * @param point\r\n * @param rectangle\r\n * @return {boolean}\r\n */\n\nexport function isInRectangle(point, rectangle) {\n  if (point.x >= rectangle.x && point.x <= rectangle.x + rectangle.width && point.y > rectangle.y && point.y < rectangle.y + rectangle.height) {\n    return true;\n  }\n\n  return false;\n}\nexport function getLineIntersection(pointA1, pointA2, pointB1, pointB2) {\n  var x = ((pointA1.x * pointA2.y - pointA2.x * pointA1.y) * (pointB1.x - pointB2.x) - (pointA1.x - pointA2.x) * (pointB1.x * pointB2.y - pointB1.y * pointB2.x)) / ((pointA1.x - pointA2.x) * (pointB1.y - pointB2.y) - (pointA1.y - pointA2.y) * (pointB1.x - pointB2.x));\n  var y = ((pointA1.x * pointA2.y - pointA2.x * pointA1.y) * (pointB1.y - pointB2.y) - (pointA1.y - pointA2.y) * (pointB1.x * pointB2.y - pointB1.y * pointB2.x)) / ((pointA1.x - pointA2.x) * (pointB1.y - pointB2.y) - (pointA1.y - pointA2.y) * (pointB1.x - pointB2.x));\n  return {\n    x: x,\n    y: y\n  };\n}","map":null,"metadata":{},"sourceType":"module"}