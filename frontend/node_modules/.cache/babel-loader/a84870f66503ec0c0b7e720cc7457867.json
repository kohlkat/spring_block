{"ast":null,"code":"/**\r\n * Map module.\r\n */\nimport * as tslib_1 from \"tslib\";\n/**\r\n * ============================================================================\r\n * IMPORTS\r\n * ============================================================================\r\n * @hidden\r\n */\n\nimport { SerialChart, SerialChartDataItem } from \"./SerialChart\";\nimport { Disposer } from \"../../core/utils/Disposer\";\nimport { InterfaceColorSet } from \"../../core/utils/InterfaceColorSet\";\nimport { MapSeries } from \"../map/MapSeries\";\nimport { MapImage } from \"../map/MapImage\";\nimport { MapPolygon } from \"../map/MapPolygon\";\nimport { MapPolygonSeries } from \"../map/MapPolygonSeries\";\nimport { Projection } from \"../map/projections/Projection\";\nimport { Circle } from \"../../core/elements/Circle\";\nimport { SmallMap } from \"../map/SmallMap\";\nimport * as $mapUtils from \"../map/MapUtils\";\nimport { keyboard } from \"../../core/utils/Keyboard\";\nimport { registry } from \"../../core/Registry\";\nimport * as $math from \"../../core/utils/Math\";\nimport * as $utils from \"../../core/utils/Utils\";\nimport * as $ease from \"../../core/utils/Ease\";\nimport * as $iter from \"../../core/utils/Iterator\";\nimport * as $type from \"../../core/utils/Type\";\nimport * as $geo from \"../map/Geo\";\nimport { GraticuleSeries } from \"../map/GraticuleSeries\";\nimport { getInteraction } from \"../../core/interaction/Interaction\";\n/**\r\n * ============================================================================\r\n * DATA ITEM\r\n * ============================================================================\r\n * @hidden\r\n */\n\n/**\r\n * Defines a [[DataItem]] for [[MapChart]].\r\n *\r\n * @see {@link DataItem}\r\n */\n\nvar MapChartDataItem =\n/** @class */\nfunction (_super) {\n  tslib_1.__extends(MapChartDataItem, _super);\n  /**\r\n   * Constructor\r\n   */\n\n\n  function MapChartDataItem() {\n    var _this = _super.call(this) || this;\n\n    _this.className = \"MapChartDataItem\";\n\n    _this.applyTheme();\n\n    return _this;\n  }\n\n  return MapChartDataItem;\n}(SerialChartDataItem);\n\nexport { MapChartDataItem };\n/**\r\n * ============================================================================\r\n * MAIN CLASS\r\n * ============================================================================\r\n * @hidden\r\n */\n\n/**\r\n * Creates a map.\r\n *\r\n * @see {@link IMapChartEvents} for a list of available Events\r\n * @see {@link IMapChartAdapters} for a list of available Adapters\r\n * @see {@link https://www.amcharts.com/docs/v4/chart-types/map/} for documentation\r\n */\n\nvar MapChart =\n/** @class */\nfunction (_super) {\n  tslib_1.__extends(MapChart, _super);\n  /**\r\n   * Constructor\r\n   */\n\n\n  function MapChart() {\n    var _this = // Init\n    _super.call(this) || this;\n    /**\r\n     * A ratio to be used when scaling the map shapes.\r\n     *\r\n     * @readonly\r\n     */\n\n\n    _this.scaleRatio = 1;\n    /**\r\n     * Default duration of zoom animations (ms).\r\n     */\n\n    _this.zoomDuration = 1000;\n    /**\r\n     * Default zooming animation easing function.\r\n     */\n\n    _this.zoomEasing = $ease.cubicOut;\n    /**\r\n     * Smallest available zoom level. The map will not allow to zoom out past\r\n     * this setting.\r\n     *\r\n     * NOTE: Should be power of 2.\r\n     *\r\n     * @default 1\r\n     */\n\n    _this.minZoomLevel = 1;\n    /**\r\n     * Biggest available zoom level. The map will not allow to zoom in past\r\n     * this setting.\r\n     *\r\n     * NOTE: Should be power of 2.\r\n     *\r\n     * @default 32\r\n     */\n\n    _this.maxZoomLevel = 32;\n    /**\r\n     * [_prevZoomGeoPoint description]\r\n     *\r\n     * @todo Description\r\n     */\n\n    _this._prevZoomGeoPoint = {\n      latitude: 0,\n      longitude: 0\n    };\n    _this.className = \"MapChart\"; // Set default projection\n\n    _this.projection = new Projection();\n    _this.deltaLongitude = 0;\n    _this.deltaLatitude = 0;\n    _this.deltaGamma = 0;\n    _this.maxPanOut = 0.7;\n    _this.homeZoomLevel = 1;\n    _this.zoomStep = 2;\n    _this.layout = \"absolute\"; // Set padding\n\n    _this.padding(0, 0, 0, 0);\n\n    $utils.used(_this.backgroundSeries); // so that the map would render in a hidden div too\n\n    _this.minWidth = 10;\n    _this.minHeight = 10;\n\n    _this.events.once(\"inited\", _this.handleAllInited, _this, false); // Create a container for map series\n\n\n    var seriesContainer = _this.seriesContainer;\n    seriesContainer.visible = false;\n    seriesContainer.inert = true;\n    seriesContainer.resizable = true;\n    seriesContainer.events.on(\"transformed\", _this.handleMapTransform, _this, false);\n    seriesContainer.events.on(\"doublehit\", _this.handleDoubleHit, _this, false);\n    seriesContainer.events.on(\"dragged\", _this.handleDrag, _this, false);\n    seriesContainer.zIndex = 0;\n    seriesContainer.dragWhileResize = true; //seriesContainer.background.fillOpacity = 0;\n    // Set up events\n    //this.events.on(\"validated\", this.updateExtremes, this);\n    //this.events.on(\"datavalidated\", this.handleAllValidated, this, false);\n    //this.events.on(\"datavalidated\", this.updateExtremes, this, false);\n    // Set up main chart container, e.g. set backgrounds and events to monitor\n    // size changes, etc.\n\n    var chartContainer = _this.chartContainer;\n    chartContainer.parent = _this;\n    chartContainer.zIndex = -1;\n\n    _this._disposers.push(_this.events.on(\"maxsizechanged\", function () {\n      if (_this.inited) {\n        if (_this._mapAnimation) {\n          _this._mapAnimation.stop();\n        }\n\n        var allInited_1 = true;\n\n        _this.series.each(function (series) {\n          series.updateTooltipBounds();\n\n          if (!series.inited || series.dataInvalid) {\n            allInited_1 = false;\n          }\n        });\n\n        if (allInited_1) {\n          _this.updateScaleRatio();\n        }\n\n        _this.zoomToGeoPoint(_this._zoomGeoPointReal, _this.zoomLevel, true, 0);\n      }\n    }, undefined, false));\n\n    var chartContainerBg = chartContainer.background;\n    chartContainerBg.fillOpacity = 0;\n    chartContainerBg.events.on(\"down\", function (e) {\n      _this.seriesContainer.dragStart(e.target.interactions.downPointers.getIndex(0));\n    }, _this);\n    chartContainerBg.events.on(\"up\", function (e) {\n      _this.seriesContainer.dragStop();\n    }, _this);\n    chartContainerBg.events.on(\"doublehit\", _this.handleDoubleHit, _this);\n    chartContainerBg.focusable = true;\n    chartContainer.events.on(\"down\", _this.handleMapDown, _this, false); // Add description to background\n\n    _this.background.fillOpacity = 0;\n    _this.background.readerTitle = _this.language.translate(\"Use plus and minus keys on your keyboard to zoom in and out\"); // Add keyboard events for panning\n\n    _this._disposers.push(getInteraction().body.events.on(\"keyup\", function (ev) {\n      if (_this.topParent.hasFocused && (!_this._zoomControl || !_this._zoomControl.thumb.isFocused)) {\n        switch (keyboard.getEventKey(ev.event)) {\n          case \"up\":\n            _this.pan({\n              x: 0,\n              y: 0.1\n            });\n\n            break;\n\n          case \"down\":\n            _this.pan({\n              x: 0,\n              y: -0.1\n            });\n\n            break;\n\n          case \"left\":\n            _this.pan({\n              x: 0.1,\n              y: 0\n            });\n\n            break;\n\n          case \"right\":\n            _this.pan({\n              x: -0.1,\n              y: 0\n            });\n\n            break;\n        }\n      }\n    }, _this));\n\n    _this.mouseWheelBehavior = \"zoom\";\n    var interaction = getInteraction();\n\n    _this._disposers.push(interaction.body.events.on(\"down\", _this.handlePanDown, _this));\n\n    _this._disposers.push(interaction.body.events.on(\"up\", _this.handlePanUp, _this)); //this._disposers.push(interaction.body.events.on(\"track\", this.handlePanMove, this));\n\n\n    var panSprite = _this.seriesContainer.createChild(Circle);\n\n    panSprite.radius = 10;\n    panSprite.inert = true;\n    panSprite.isMeasured = false;\n    panSprite.events.on(\"transformed\", _this.handlePanMove, _this, false);\n    panSprite.interactionsEnabled = false;\n    panSprite.opacity = 0;\n    panSprite.x = 0;\n    panSprite.y = 0;\n    _this.panSprite = panSprite;\n    _this.panBehavior = \"move\";\n    /*\r\n            this.panSprite.inertiaOptions.setKey(\"move\", {\r\n                \"time\": 100,\r\n                \"duration\": 1000,\r\n                \"factor\": 3,\r\n                \"easing\": $ease.sinOut\r\n            });*/\n    // Apply theme\n\n    _this.applyTheme();\n\n    return _this;\n  }\n  /**\r\n   * @ignore\r\n   */\n\n\n  MapChart.prototype.handlePanDown = function (event) {\n    var svgPoint = $utils.documentPointToSvg(event.pointer.point, this.htmlContainer);\n\n    if (svgPoint.x > 0 && svgPoint.y > 0 && svgPoint.x < this.svgContainer.width && svgPoint.y < this.svgContainer.height) {\n      // Get local point\n      this._downPointOrig = $utils.documentPointToSprite(event.pointer.point, this.seriesContainer);\n      this.panSprite.moveTo(this._downPointOrig);\n      this.panSprite.dragStart(event.pointer);\n      this._downDeltaLongitude = this.deltaLongitude;\n      this._downDeltaLatitude = this.deltaLatitude;\n    }\n  };\n  /**\r\n   * @ignore\r\n   */\n\n\n  MapChart.prototype.handlePanUp = function (event) {\n    if (this._downPointOrig) {\n      this.panSprite.dragStop(event.pointer);\n    }\n\n    this._downPointOrig = undefined;\n  };\n  /**\r\n   * @ignore\r\n   */\n\n\n  MapChart.prototype.handlePanMove = function () {\n    if (!this.seriesContainer.isResized) {\n      var d3Projection = this.projection.d3Projection;\n      var panBehavior = this.panBehavior;\n\n      if (panBehavior != \"move\" && panBehavior != \"none\" && this._downPointOrig && d3Projection.rotate) {\n        var rotation = d3Projection.rotate();\n        var dln = rotation[0];\n        var dlt = rotation[1];\n        var dlg = rotation[2];\n        d3Projection.rotate([0, 0, 0]);\n        var downGeoLocal = this.projection.invert(this._downPointOrig);\n        var local = {\n          x: this.panSprite.pixelX,\n          y: this.panSprite.pixelY\n        };\n        var geoLocal = void 0;\n\n        if (local) {\n          geoLocal = this.projection.invert(local);\n        }\n\n        d3Projection.rotate([dln, dlt, dlg]);\n\n        if (geoLocal) {\n          if (panBehavior == \"rotateLat\" || panBehavior == \"rotateLongLat\") {\n            this.deltaLatitude = this._downDeltaLatitude + geoLocal.latitude - downGeoLocal.latitude;\n          }\n\n          if (panBehavior == \"rotateLong\" || panBehavior == \"rotateLongLat\") {\n            this.deltaLongitude = this._downDeltaLongitude + geoLocal.longitude - downGeoLocal.longitude;\n          }\n        }\n      }\n    }\n  };\n  /**\r\n   * @ignore\r\n   */\n\n\n  MapChart.prototype.handleAllInited = function () {\n    var _this = this;\n\n    var inited = true;\n    this.seriesContainer.visible = true;\n    this.series.each(function (series) {\n      if (!series.inited || series.dataInvalid) {\n        inited = false;\n      }\n    });\n\n    if (inited) {\n      this.updateCenterGeoPoint();\n      this.updateScaleRatio();\n      this.goHome(0);\n    } else {\n      // TODO verify that this is correct\n      var disposer_1 = registry.events.once(\"exitframe\", function () {\n        _this.removeDispose(disposer_1);\n\n        _this.handleAllInited();\n      }, this, false);\n      this.addDisposer(disposer_1);\n    }\n  };\n  /**\r\n   * @ignore\r\n   */\n\n\n  MapChart.prototype.updateZoomGeoPoint = function () {\n    var seriesPoint = $utils.svgPointToSprite({\n      x: this.innerWidth / 2 + this.pixelPaddingLeft,\n      y: this.innerHeight / 2 + this.pixelPaddingTop\n    }, this.series.getIndex(0));\n    var geoPoint = this.projection.invert(seriesPoint);\n    this._zoomGeoPointReal = geoPoint;\n  };\n  /**\r\n   * @ignore\r\n   */\n\n\n  MapChart.prototype.updateCenterGeoPoint = function () {\n    var maxLeft;\n    var maxRight;\n    var maxTop;\n    var maxBottom;\n\n    if (this.backgroundSeries) {\n      var features = this.backgroundSeries.getFeatures();\n\n      if (features.length > 0) {\n        var bounds = this.projection.d3Path.bounds(features[0].geometry);\n        maxLeft = bounds[0][0];\n        maxTop = bounds[0][1];\n        maxRight = bounds[1][0];\n        maxBottom = bounds[1][1];\n      }\n    } else {\n      this.series.each(function (series) {\n        var bbox = series.group.node.getBBox();\n\n        if (maxLeft > bbox.x || !$type.isNumber(maxLeft)) {\n          maxLeft = bbox.x;\n        }\n\n        if (maxRight < bbox.x + bbox.width || !$type.isNumber(maxRight)) {\n          maxRight = bbox.x + bbox.width;\n        }\n\n        if (maxTop > bbox.y || !$type.isNumber(maxTop)) {\n          maxTop = bbox.y;\n        }\n\n        if (maxBottom < bbox.y + bbox.height || !$type.isNumber(maxBottom)) {\n          maxBottom = bbox.y + bbox.height;\n        }\n      });\n    }\n\n    this.seriesMaxLeft = maxLeft;\n    this.seriesMaxRight = maxRight;\n    this.seriesMaxTop = maxTop;\n    this.seriesMaxBottom = maxBottom;\n    this.seriesWidth = maxRight - maxLeft;\n    this.seriesHeight = maxBottom - maxTop;\n\n    if (this.seriesWidth > 0 && this.seriesHeight > 0) {\n      this.chartContainer.visible = true;\n      this._centerGeoPoint = this.projection.invert({\n        x: maxLeft + (maxRight - maxLeft) / 2,\n        y: maxTop + (maxBottom - maxTop) / 2\n      });\n\n      if (!this._zoomGeoPointReal || !$type.isNumber(this._zoomGeoPointReal.latitude)) {\n        this._zoomGeoPointReal = this._centerGeoPoint;\n      }\n    } else {\n      this.chartContainer.visible = false;\n    }\n  };\n  /**\r\n   * Prevents map to be dragged out of the container area\r\n   * @ignore\r\n   */\n\n\n  MapChart.prototype.handleDrag = function () {\n    var d = this.zoomLevel * this.scaleRatio;\n    var ww = this.seriesWidth * d;\n    var hh = this.seriesHeight * d;\n    var seriesContainer = this.seriesContainer;\n    var maxLeft = this.seriesMaxLeft * d;\n    var maxRight = this.seriesMaxRight * d;\n    var maxTop = this.seriesMaxTop * d;\n    var maxBottom = this.seriesMaxBottom * d;\n    var x = seriesContainer.pixelX;\n    var y = seriesContainer.pixelY;\n    var maxPanOut = this.maxPanOut;\n    var minX = Math.min(this.maxWidth * (1 - maxPanOut) - ww - maxLeft, -maxLeft);\n\n    if (x < minX) {\n      x = minX;\n    }\n\n    var maxX = Math.max(this.maxWidth * maxPanOut - maxLeft, this.maxWidth - maxRight);\n\n    if (x > maxX) {\n      x = maxX;\n    }\n\n    var minY = Math.min(this.maxHeight * (1 - maxPanOut) - hh - maxTop, -maxTop);\n\n    if (y < minY) {\n      y = minY;\n    }\n\n    var maxY = Math.max(this.maxHeight * maxPanOut - maxTop, this.maxHeight - maxBottom);\n\n    if (y > maxY) {\n      y = maxY;\n    }\n\n    seriesContainer.moveTo({\n      x: x,\n      y: y\n    }, undefined, undefined, true);\n    this._zoomGeoPointReal = this.zoomGeoPoint;\n  };\n  /**\r\n   * Sets defaults that instantiate some objects that rely on parent, so they\r\n   * cannot be set in constructor.\r\n   */\n\n\n  MapChart.prototype.applyInternalDefaults = function () {\n    _super.prototype.applyInternalDefaults.call(this); // Add a default screen reader title for accessibility\n    // This will be overridden in screen reader if there are any `titles` set\n\n\n    if (!$type.hasValue(this.readerTitle)) {\n      this.readerTitle = this.language.translate(\"Map\");\n    }\n  };\n  /**\r\n   * Handles event when a pointer presses down on the map, e.g. user presses\r\n   * down mouse or touches the map on a screen.\r\n   *\r\n   * Stops all animations currently going on.\r\n   */\n\n\n  MapChart.prototype.handleMapDown = function () {\n    if (this._mapAnimation) {\n      this._mapAnimation.stop();\n    }\n  };\n  /**\r\n   * Handles the event when user doubleclicks or dooubletaps the map: zooms\r\n   * in on the reference point.\r\n   *\r\n   * @param event  Original event\r\n   */\n\n\n  MapChart.prototype.handleDoubleHit = function (event) {\n    var svgPoint = $utils.documentPointToSvg(event.point, this.htmlContainer, this.svgContainer.cssScale);\n    var geoPoint = this.svgPointToGeo(svgPoint);\n    this.zoomIn(geoPoint);\n  };\n  /**\r\n   * Handles mouse wheel event, e.g. user rotates mouse wheel while over the\r\n   * map: zooms in or out depending on the direction of the wheel turn.\r\n   *\r\n   * @param event  Original event\r\n   */\n\n\n  MapChart.prototype.handleWheel = function (event) {\n    // Cancel any move inertia if there is one\n    var inertia = this.seriesContainer.interactions.inertias.getKey(\"move\");\n\n    if (inertia) {\n      inertia.done();\n    }\n\n    var svgPoint = $utils.documentPointToSvg(event.point, this.htmlContainer, this.svgContainer.cssScale);\n    var geoPoint = this.svgPointToGeo(svgPoint);\n\n    if (event.shift.y < 0) {\n      this.zoomIn(geoPoint, undefined, this.interactions.mouseOptions.sensitivity);\n    } else {\n      this.zoomOut(geoPoint, undefined, this.interactions.mouseOptions.sensitivity);\n    }\n  };\n\n  Object.defineProperty(MapChart.prototype, \"mouseWheelBehavior\", {\n    /**\r\n     * @return mouse wheel behavior\r\n     */\n    get: function () {\n      return this.getPropertyValue(\"mouseWheelBehavior\");\n    },\n\n    /**\r\n     * Specifies what should chart do if when mouse wheel is rotated.\r\n     *\r\n     * @param mouse wheel behavior\r\n     * @default zoomX\r\n     */\n    set: function (value) {\n      if (this.setPropertyValue(\"mouseWheelBehavior\", value)) {\n        if (value != \"none\") {\n          this._mouseWheelDisposer = this.chartContainer.events.on(\"wheel\", this.handleWheel, this, false);\n\n          this._disposers.push(this._mouseWheelDisposer);\n        } else {\n          if (this._mouseWheelDisposer) {\n            this._mouseWheelDisposer.dispose();\n          }\n\n          this.chartContainer.wheelable = false;\n        }\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(MapChart.prototype, \"panBehavior\", {\n    /**\r\n     * @returns Behavior\r\n     */\n    get: function () {\n      return this.getPropertyValue(\"panBehavior\");\n    },\n\n    /**\r\n     * What \"dragging\" map does.\r\n     *\r\n     * Available values:\r\n     * * `\"move\"` (default): changes position of the map.\r\n     * * `\"rotateLat\"`: changes `deltaLatitude` (rotates the globe vertically).\r\n     * * `\"rotateLong\"`: changes `deltaLongitude` (rotates the globe horizontally).\r\n     * * `\"rotateLongLat\"`: changes both `deltaLongitude` and `deltaLatitude` (rotates the globe in any direction).\r\n     *\r\n     * @default \"move\"\r\n     * @since 4.3.0\r\n     * @param  value  Behavior\r\n     */\n    set: function (value) {\n      if (this.setPropertyValue(\"panBehavior\", value)) {\n        var seriesContainer = this.seriesContainer;\n        this.panSprite.draggable = false;\n        seriesContainer.draggable = false;\n\n        switch (value) {\n          case \"move\":\n            seriesContainer.draggable = true;\n            break;\n\n          default:\n            this.panSprite.draggable = true;\n            break;\n        }\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(MapChart.prototype, \"projection\", {\n    /**\r\n     * @return Projection\r\n     */\n    get: function () {\n      return this.getPropertyValue(\"projection\");\n    },\n\n    /**\r\n     * Projection to use for the map.\r\n     *\r\n     * Available projections:\r\n     * * Albers\r\n     * * AlbersUSA\r\n     * * AzimuthalEqualArea\r\n     * * Eckert6\r\n     * * EqualEarth\r\n     * * Mercator\r\n     * * Miller\r\n     * * NaturalEarth\r\n     * * Orthographic\r\n     * * Stereographic\r\n     *\r\n     * ```TypeScript\r\n     * map.projection = new am4maps.projections.Mercator();\r\n     * ```\r\n     * ```JavaScript\r\n     * map.projection = new am4maps.projections.Mercator();\r\n     * ```\r\n     * ```JSON\r\n     * {\r\n     *   // ...\r\n     *   \"projection\": \"Mercator\"\r\n     *   // ...\r\n     * }\r\n     * ```\r\n     *\r\n     * @see {@link https://www.amcharts.com/docs/v4/chart-types/map/#Setting_projection} More about projections\r\n     * @param projection  Projection\r\n     */\n    set: function (projection) {\n      var _this = this;\n\n      if (this.setPropertyValue(\"projection\", projection)) {\n        this.invalidateProjection();\n        projection.chart = this;\n\n        if (this._backgroundSeries) {\n          this._backgroundSeries.invalidate();\n        }\n\n        this.series.each(function (series) {\n          series.events.once(\"validated\", function () {\n            _this.updateCenterGeoPoint();\n\n            _this.updateScaleRatio();\n\n            _this.goHome(0);\n          });\n        });\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\r\n   * Validates (processes) data items.\r\n   *\r\n   * @ignore Exclude from docs\r\n   */\n\n  MapChart.prototype.validateDataItems = function () {\n    _super.prototype.validateDataItems.call(this);\n\n    this.updateExtremes();\n  };\n  /**\r\n   * Calculates the longitudes and latitudes of the most distant points from\r\n   * the center in all four directions: West, East, North, and South.\r\n   *\r\n   * @ignore Exclude from docs\r\n   */\n\n\n  MapChart.prototype.updateExtremes = function () {\n    var east;\n    var north;\n    var west;\n    var south;\n    this.series.each(function (series) {\n      if (series.ignoreBounds || series instanceof GraticuleSeries && series.fitExtent) {} else {\n        if (series.north > north || !$type.isNumber(north)) {\n          north = series.north;\n        }\n\n        if (series.south < south || !$type.isNumber(south)) {\n          south = series.south;\n        }\n\n        if (series.west < west || !$type.isNumber(west)) {\n          west = series.west;\n        }\n\n        if (series.east > east || !$type.isNumber(east)) {\n          east = series.east;\n        }\n      }\n    });\n    var features = [];\n    var foundGraticule = false; // if we gave graticule, get features of these series only for faster fitSize\n\n    this.series.each(function (series) {\n      if (series instanceof GraticuleSeries && !series.fitExtent) {\n        features = series.getFeatures();\n        foundGraticule = true;\n      }\n    });\n\n    if (!foundGraticule) {\n      this.series.each(function (series) {\n        if (series.ignoreBounds || series instanceof GraticuleSeries && series.fitExtent) {} else {\n          features = features.concat(series.getFeatures());\n        }\n      });\n    }\n\n    var w = $math.max(50, this.innerWidth);\n    var h = $math.max(50, this.innerHeight);\n    var d3Projection = this.projection.d3Projection;\n\n    if (features.length > 0 && d3Projection && (this.east != east || this.west != west || this.north != north || this.south != south)) {\n      this.east = east;\n      this.west = west;\n      this.north = north;\n      this.south = south;\n\n      if (d3Projection.rotate) {\n        var rotation = d3Projection.rotate();\n        var deltaLong = rotation[0];\n        var deltaLat = rotation[1];\n        var deltaGamma = rotation[2];\n        this.deltaLongitude = deltaLong;\n        this.deltaLatitude = deltaLat;\n        this.deltaGamma = deltaGamma;\n      }\n\n      var geoJSON = {\n        \"type\": \"FeatureCollection\",\n        features: features\n      };\n      var initialScale = d3Projection.scale();\n      d3Projection.fitSize([w, h], geoJSON);\n\n      if (d3Projection.scale() != initialScale) {\n        this.invalidateDataUsers();\n      }\n\n      this.series.each(function (series) {\n        if (series instanceof GraticuleSeries) {\n          series.invalidateData();\n        }\n      });\n\n      if (this._backgroundSeries) {\n        var polygon = this._backgroundSeries.mapPolygons.getIndex(0);\n\n        if (polygon) {\n          polygon.multiPolygon = $mapUtils.getBackground(this.north, this.east, this.south, this.west);\n        }\n      }\n\n      this._fitWidth = w;\n      this._fitHeight = h;\n    }\n\n    if (!this._zoomGeoPointReal || !$type.isNumber(this._zoomGeoPointReal.latitude)) {\n      this.goHome(0);\n    }\n  };\n  /**\r\n   * (Re)calculates a ratio which should be used to scale the actual map so\r\n   * that it fits perfectly into available space. Helps to avoid redrawing of all the map if container size changes\r\n   * @ignore\r\n   */\n\n\n  MapChart.prototype.updateScaleRatio = function () {\n    var scaleRatio;\n    this.updateCenterGeoPoint();\n    var hScale = this.innerWidth / this.seriesWidth;\n    var vScale = this.innerHeight / this.seriesHeight;\n    scaleRatio = $math.min(hScale, vScale);\n\n    if ($type.isNaN(scaleRatio) || scaleRatio == Infinity) {\n      scaleRatio = 1;\n    }\n\n    if (scaleRatio != this.scaleRatio) {\n      this.scaleRatio = scaleRatio;\n      $iter.each(this.series.iterator(), function (series) {\n        series.scale = scaleRatio;\n        series.updateTooltipBounds();\n      });\n      this.backgroundSeries.scale = scaleRatio;\n      this.dispatch(\"scaleratiochanged\");\n    }\n  };\n  /**\r\n   * Converts a point within map container to geographical (lat/long)\r\n   * coordinates.\r\n   *\r\n   * @param point  Source point\r\n   * @return Geo-point\r\n   */\n\n\n  MapChart.prototype.svgPointToGeo = function (point) {\n    var series = this.series.getIndex(0);\n\n    if (series) {\n      var seriesPoint = $utils.svgPointToSprite(point, series);\n      return this.seriesPointToGeo(seriesPoint);\n    }\n  };\n  /**\r\n   * Converts geographical (lat/long) coordinates to an X/Y point within map's\r\n   * container.\r\n   *\r\n   * @param point  Source geo-point\r\n   * @return Point\r\n   */\n\n\n  MapChart.prototype.geoPointToSVG = function (point) {\n    var series = this.series.getIndex(0);\n\n    if (series) {\n      var seriesPoint = this.geoPointToSeries(point);\n      return $utils.spritePointToSvg(seriesPoint, series);\n    }\n  };\n  /**\r\n   * Converts a point (X/Y) within actual objects of the map to geographical\r\n   * (lat/long) coordinates.\r\n   *\r\n   * @param point  Source point\r\n   * @return Geo-point\r\n   */\n\n\n  MapChart.prototype.seriesPointToGeo = function (point) {\n    return this.projection.invert(point);\n  };\n  /**\r\n   * Converts geographical (lat/long) coordinates to an X/Y point within\r\n   * actual elements/objects of the maps.\r\n   *\r\n   * @param point  Source geo-point\r\n   * @return Point\r\n   */\n\n\n  MapChart.prototype.geoPointToSeries = function (point) {\n    return this.projection.convert(point);\n  };\n\n  Object.defineProperty(MapChart.prototype, \"geodata\", {\n    /**\r\n     * @return GeoJSON data\r\n     */\n    get: function () {\n      return this._geodata;\n    },\n\n    /**\r\n     * Map data in GeoJSON format.\r\n     *\r\n     * The Map supports the following GeoJSON objects: `Point`, `LineString`,\r\n     * `Polygon`, `MultiPoint`, `MultiLineString`, and `MultiPolygon`.\r\n     *\r\n     * @see {@link http://geojson.org/} Official GeoJSON format specification\r\n     * @param geoJSON GeoJSON data\r\n     */\n    set: function (geodata) {\n      if (geodata != this._geodata) {\n        this._geodata = geodata;\n        this.invalidateData();\n        this.dataUsers.each(function (dataUser) {\n          for (var i = dataUser.data.length - 1; i >= 0; i--) {\n            if (dataUser.data[i].madeFromGeoData == true) {\n              dataUser.data.splice(i, 1);\n            }\n          }\n\n          dataUser.disposeData();\n          dataUser.invalidateData();\n        });\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\r\n   * Zooms the map to particular zoom level and centers on a latitude/longitude\r\n   * coordinate.\r\n   *\r\n   * @param point      Center coordinate\r\n   * @param zoomLevel  Zoom level\r\n   * @param center     Center on the given coordinate?\r\n   * @param duration   Duration for zoom animation (ms)\r\n   * @return Zoom animation\r\n   */\n\n  MapChart.prototype.zoomToGeoPoint = function (point, zoomLevel, center, duration, mapObject) {\n    var _this = this;\n\n    if (!point) {\n      point = this.zoomGeoPoint;\n    }\n\n    if (!point || !$type.isNumber(point.longitude) || !$type.isNumber(point.latitude)) {\n      return;\n    }\n\n    this._zoomGeoPointReal = point;\n    zoomLevel = $math.fitToRange(zoomLevel, this.minZoomLevel, this.maxZoomLevel);\n    var seriesPoint = this.projection.convert(point);\n\n    if (seriesPoint) {\n      var svgPoint = this.geoPointToSVG(point);\n      var mapPoint = $utils.svgPointToSprite(svgPoint, this);\n\n      if (center) {\n        mapPoint = {\n          x: this.innerWidth / 2,\n          y: this.innerHeight / 2\n        };\n      }\n\n      if (!$type.isNumber(duration)) {\n        duration = this.zoomDuration;\n      }\n\n      var x = mapPoint.x - seriesPoint.x * zoomLevel * this.scaleRatio;\n      var y = mapPoint.y - seriesPoint.y * zoomLevel * this.scaleRatio;\n\n      if (!mapObject && zoomLevel < this.zoomLevel) {\n        x = this.innerWidth / 2 - (this.seriesMaxLeft + (this.seriesMaxRight - this.seriesMaxLeft) / 2) * zoomLevel * this.scaleRatio;\n        y = this.innerHeight / 2 - (this.seriesMaxTop + (this.seriesMaxBottom - this.seriesMaxTop) / 2) * zoomLevel * this.scaleRatio;\n      }\n\n      this._mapAnimation = this.seriesContainer.animate([{\n        property: \"scale\",\n        to: zoomLevel\n      }, {\n        property: \"x\",\n        from: this.seriesContainer.pixelX,\n        to: x\n      }, {\n        property: \"y\",\n        from: this.seriesContainer.pixelY,\n        to: y\n      }], duration, this.zoomEasing);\n\n      this._disposers.push(this._mapAnimation.events.on(\"animationended\", function () {\n        _this._zoomGeoPointReal = _this.zoomGeoPoint;\n      }));\n\n      this.seriesContainer.validatePosition();\n      return this._mapAnimation;\n    }\n  };\n  /**\r\n   * Zooms the map to a particular map object.\r\n   *\r\n   * @param mapObject  Target map object\r\n   * @param zoomLevel  Zoom level\r\n   * @param center     Center on the given coordinate?\r\n   * @param duration   Duration for zoom animation (ms)\r\n   * @return Zoom animation\r\n   */\n\n\n  MapChart.prototype.zoomToMapObject = function (mapObject, zoomLevel, center, duration) {\n    if (center == undefined) {\n      center = true;\n    }\n\n    var inertia = this.seriesContainer.interactions.inertias.getKey(\"move\");\n\n    if (inertia) {\n      inertia.done();\n    }\n\n    if (mapObject instanceof MapImage) {\n      if ($type.isNaN(zoomLevel)) {\n        zoomLevel = 5;\n      }\n\n      return this.zoomToGeoPoint({\n        latitude: mapObject.latitude,\n        longitude: mapObject.longitude\n      }, zoomLevel, center, duration);\n    }\n\n    var dataItem = mapObject.dataItem;\n\n    if (dataItem && $type.isNumber(dataItem.zoomLevel)) {\n      zoomLevel = dataItem.zoomLevel;\n    }\n\n    if (mapObject instanceof MapPolygon) {\n      var dataItem_1 = mapObject.dataItem;\n      var bbox = mapObject.polygon.bbox;\n\n      if (!$type.isNumber(zoomLevel)) {\n        zoomLevel = Math.min(this.seriesWidth / bbox.width, this.seriesHeight / bbox.height);\n      }\n\n      var geoPoint = void 0;\n\n      if (dataItem_1 && $type.hasValue(dataItem_1.zoomGeoPoint)) {\n        geoPoint = dataItem_1.zoomGeoPoint;\n      } else {\n        // this is more accurate\n        var polygonPoint = {\n          x: bbox.x + bbox.width / 2,\n          y: bbox.y + bbox.height / 2\n        };\n        var seriesPoint = $utils.spritePointToSprite(polygonPoint, mapObject.polygon, mapObject.series);\n        geoPoint = this.seriesPointToGeo(seriesPoint);\n      }\n\n      return this.zoomToGeoPoint(geoPoint, zoomLevel, true, duration, true);\n    }\n  };\n  /**\r\n   * Zooms the map to a particular viewport.\r\n   *\r\n   * The `north`, `east`, `south`, and `west` define boundaries of the\r\n   * imaginary viewort we want to zoom the map to.\r\n   *\r\n   * `level` is not actual zoom level. The map will determine the zoom level\r\n   * required to accommodated such zoom, and will adjust it by `level` if set.\r\n   *\r\n   * @param north     Latitude of the North-most boundary\r\n   * @param east      Longitude of the East-most boundary\r\n   * @param south     Latitude of the South-most boundary\r\n   * @param west      Longitude of the West-most boundary\r\n   * @param level     Adjust zoom level\r\n   * @param center    Center on the given coordinate?\r\n   * @param duration  Duration for zoom animation (ms)\r\n   * @return Zoom animation\r\n   */\n\n\n  MapChart.prototype.zoomToRectangle = function (north, east, south, west, level, center, duration) {\n    if ($type.isNaN(level)) {\n      level = 1;\n    }\n\n    var zoomLevel = level * Math.min((this.south - this.north) / (south - north), (this.west - this.east) / (west - east));\n    return this.zoomToGeoPoint({\n      latitude: north + (south - north) / 2,\n      longitude: west + (east - west) / 2\n    }, zoomLevel, center, duration);\n  };\n  /**\r\n   * Zooms in the map, optionally centering on particular latitude/longitude\r\n   * point.\r\n   *\r\n   * @param geoPoint  Optional center point\r\n   * @param duration  Duration for zoom animation (ms)\r\n   * @return Zoom animation\r\n   */\n\n\n  MapChart.prototype.zoomIn = function (geoPoint, duration, sensitivity) {\n    if (sensitivity === void 0) {\n      sensitivity = 1;\n    }\n\n    var step = 1 + (this.zoomStep - 1) * sensitivity;\n\n    if (step < 1) {\n      step = 1;\n    }\n\n    return this.zoomToGeoPoint(geoPoint, this.zoomLevel * step, false, duration);\n  };\n  /**\r\n   * Zooms out the map, optionally centering on particular latitude/longitude\r\n   * point.\r\n   *\r\n   * @param geoPoint  Optional center point\r\n   * @param duration  Duration for zoom animation (ms)\r\n   * @return Zoom animation\r\n   */\n\n\n  MapChart.prototype.zoomOut = function (geoPoint, duration, sensitivity) {\n    if (sensitivity === void 0) {\n      sensitivity = 1;\n    }\n\n    var step = 1 + (this.zoomStep - 1) * sensitivity;\n\n    if (step < 1) {\n      step = 1;\n    }\n\n    return this.zoomToGeoPoint(geoPoint, this.zoomLevel / step, false, duration);\n  };\n  /**\r\n   * Pans the maps using relative coordinates. E.g.:\r\n   *\r\n   * ```JSON\r\n   * {\r\n   *   x: 0.1,\r\n   *   y: -0.1\r\n   * }\r\n   * ```\r\n   *\r\n   * The above will move the map by 10% to the right, and by 10% upwards.\r\n   *\r\n   * @param shift     Vertical and horizontal shift\r\n   * @param duration  Pan animation duration (ms)\r\n   */\n\n\n  MapChart.prototype.pan = function (shift, duration) {\n    var point = this.geoPointToSVG(this.zoomGeoPoint);\n    point.x += this.pixelWidth * shift.x;\n    point.y += this.pixelHeight * shift.y;\n    this.zoomToGeoPoint(this.svgPointToGeo(point), this.zoomLevel, true, duration);\n  };\n\n  Object.defineProperty(MapChart.prototype, \"zoomGeoPoint\", {\n    /**\r\n     * Current lat/long coordinates for the center of the viewport. (default\r\n     * zoom reference point)\r\n     *\r\n     * @readonly\r\n     * @return Coordinates\r\n     */\n    get: function () {\n      var point = $utils.spritePointToSvg({\n        x: this.pixelWidth / 2,\n        y: this.pixelHeight / 2\n      }, this);\n      return this.svgPointToGeo(point);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(MapChart.prototype, \"zoomLevel\", {\n    /**\r\n     * @return Zoom level\r\n     */\n    get: function () {\n      return this.seriesContainer.scale;\n    },\n\n    /**\r\n     * Current zoom level.\r\n     *\r\n     * @readonly\r\n     * @return Zoom level\r\n     */\n    set: function (value) {\n      this.seriesContainer.scale = value;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\r\n   * Dispatches events after some map transformation, like pan or zoom.\r\n   *\r\n   * @ignore\r\n   */\n\n  MapChart.prototype.handleMapTransform = function () {\n    if (this.zoomLevel != this._prevZoomLevel) {\n      this.dispatch(\"zoomlevelchanged\");\n      this._prevZoomLevel = this.zoomLevel;\n    }\n\n    if (this.zoomGeoPoint && (this._prevZoomGeoPoint.latitude != this.zoomGeoPoint.latitude || this._prevZoomGeoPoint.longitude != this.zoomGeoPoint.longitude)) {\n      this.dispatch(\"mappositionchanged\");\n    }\n  };\n\n  Object.defineProperty(MapChart.prototype, \"smallMap\", {\n    /**\r\n     * @return Small map\r\n     */\n    get: function () {\n      if (!this._smallMap) {\n        var smallMap = new SmallMap();\n        this.smallMap = smallMap;\n      }\n\n      return this._smallMap;\n    },\n\n    /**\r\n     * A [[SmallMap]] to be used on the map.\r\n     *\r\n     * Please note, that accessing this property will NOT create a small map\r\n     * if it has not yet been created. (except in JSON)\r\n     *\r\n     * ```TypeScript\r\n     * // Create a small map\r\n     * map.smallMap = new am4maps.SmallMap();\r\n     * ```\r\n     * ```JavaScript\r\n     * // Create a small map\r\n     * map.smallMap = new am4maps.SmallMap();\r\n     * ```\r\n     * ```JSON\r\n     * {\r\n     *   // ...\r\n     *   \"smallMap\": {}\r\n     *   // ...\r\n     * }\r\n     * ```\r\n     *\r\n     * @param smallMap  Small map\r\n     */\n    set: function (smallMap) {\n      if (this._smallMap) {\n        this.removeDispose(this._smallMap);\n      }\n\n      this._smallMap = smallMap;\n      this._smallMap.chart = this;\n      smallMap.parent = this.chartContainer;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(MapChart.prototype, \"zoomControl\", {\n    /**\r\n     * @return Zoom control\r\n     */\n    get: function () {\n      return this._zoomControl;\n    },\n\n    /**\r\n     * A [[ZoomControl]] to be used on the map.\r\n     *\r\n     * Please note, that accessing this property will NOT create a zoom control\r\n     * if it has not yet been created. (except in JSON)\r\n     *\r\n     * ```TypeScript\r\n     * // Create a zoom control\r\n     * map.zoomControl = new am4maps.ZoomControl();\r\n     * ```\r\n     * ```JavaScript\r\n     * // Create a zoom control\r\n     * map.zoomControl = new am4maps.ZoomControl();\r\n     * ```\r\n     * ```JSON\r\n     * {\r\n     *   // ...\r\n     *   \"zoomControl\": {}\r\n     *   // ...\r\n     * }\r\n     * ```\r\n     *\r\n     * @param zoomControl  Zoom control\r\n     */\n    set: function (zoomControl) {\n      if (this._zoomControl) {\n        this.removeDispose(this._zoomControl);\n      }\n\n      this._zoomControl = zoomControl;\n      zoomControl.chart = this;\n      zoomControl.parent = this.chartContainer;\n      zoomControl.plusButton.exportable = false;\n      zoomControl.minusButton.exportable = false;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\r\n   * Creates and returns a map series of appropriate type.\r\n   *\r\n   * @return Map series\r\n   */\n\n  MapChart.prototype.createSeries = function () {\n    return new MapSeries();\n  };\n\n  Object.defineProperty(MapChart.prototype, \"deltaLongitude\", {\n    /**\r\n     * @return Rotation\r\n     */\n    get: function () {\n      return this.getPropertyValue(\"deltaLongitude\");\n    },\n\n    /**\r\n     * Degrees to rotate the map around vertical axis (Y).\r\n     *\r\n     * E.g. if set to -160, the longitude 20 will become a new center, creating\r\n     * a Pacific-centered map.\r\n     *\r\n     * @see {@link https://www.amcharts.com/docs/v4/chart-types/map/#Map_rotation} For more info on map rotation.\r\n     * @param  value  Rotation\r\n     */\n    set: function (value) {\n      if (this.setPropertyValue(\"deltaLongitude\", $geo.wrapAngleTo180(value))) {\n        this.rotateMap();\n        this.updateZoomGeoPoint();\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(MapChart.prototype, \"deltaLatitude\", {\n    /**\r\n     * @return Rotation\r\n     */\n    get: function () {\n      return this.getPropertyValue(\"deltaLatitude\");\n    },\n\n    /**\r\n     * Degrees to rotate the map around horizontal axis (X).\r\n     *\r\n     * E.g. setting this to 90 will put Antarctica directly in the center of\r\n     * the map.\r\n     *\r\n     * @see {@link https://www.amcharts.com/docs/v4/chart-types/map/#Map_rotation} For more info on map rotation.\r\n     * @since 4.3.0\r\n     * @param  value  Rotation\r\n     */\n    set: function (value) {\n      if (this.setPropertyValue(\"deltaLatitude\", value)) {\n        this.rotateMap();\n        this.updateZoomGeoPoint();\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(MapChart.prototype, \"deltaGamma\", {\n    /**\r\n     * @return Rotation\r\n     */\n    get: function () {\n      return this.getPropertyValue(\"deltaGamma\");\n    },\n\n    /**\r\n     * Degrees to rotate the map around \"Z\" axis. This is the axis that pierces\r\n     * the globe directly from the viewer's point of view.\r\n     *\r\n     * @see {@link https://www.amcharts.com/docs/v4/chart-types/map/#Map_rotation} For more info on map rotation.\r\n     * @since 4.3.0\r\n     * @param  value  Rotation\r\n     */\n    set: function (value) {\n      if (this.setPropertyValue(\"deltaGamma\", value)) {\n        this.rotateMap();\n        this.updateZoomGeoPoint();\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\r\n   * @ignore\r\n   */\n\n  MapChart.prototype.rotateMap = function () {\n    if (this.projection.d3Projection) {\n      if (this.projection.d3Projection.rotate) {\n        this.projection.d3Projection.rotate([this.deltaLongitude, this.deltaLatitude, this.deltaGamma]);\n        this.invalidateProjection();\n      }\n    }\n  };\n\n  Object.defineProperty(MapChart.prototype, \"maxPanOut\", {\n    /**\r\n     * @return Max pan out\r\n     */\n    get: function () {\n      return this.getPropertyValue(\"maxPanOut\");\n    },\n\n    /**\r\n     * Maximum portion of the map's width/height to allow panning \"off screen\".\r\n     *\r\n     * A value of 0 (zero) will prevent any portion of the the map to be panned\r\n     * outside the viewport.\r\n     *\r\n     * 0.5 will allow half of the map to be outside viewable area.\r\n     *\r\n     * @default 0.7\r\n     * @param value  Max pan out\r\n     */\n    set: function (value) {\n      this.setPropertyValue(\"maxPanOut\", value);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(MapChart.prototype, \"homeGeoPoint\", {\n    /**\r\n     * @return Home geo point\r\n     */\n    get: function () {\n      return this.getPropertyValue(\"homeGeoPoint\");\n    },\n\n    /**\r\n     * The geographical point to center map on when it is first loaded.\r\n     *\r\n     * The map will also be centered to this point when you call `goHome()`\r\n     * method.\r\n     *\r\n     * @param value  Home geo point\r\n     */\n    set: function (value) {\n      this.setPropertyValue(\"homeGeoPoint\", value);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(MapChart.prototype, \"homeZoomLevel\", {\n    /**\r\n     * @return Home zoom level\r\n     */\n    get: function () {\n      return this.getPropertyValue(\"homeZoomLevel\");\n    },\n\n    /**\r\n     * The zoom level to put the map in when it is first loaded.\r\n     *\r\n     * The map will also be set to this zoom level when you call `goHome()`\r\n     * method.\r\n     *\r\n     * @param value  Home zoom level\r\n     */\n    set: function (value) {\n      this.setPropertyValue(\"homeZoomLevel\", value);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(MapChart.prototype, \"zoomStep\", {\n    /**\r\n     * @return Zoom factor\r\n     */\n    get: function () {\n      return this.getPropertyValue(\"zoomStep\");\n    },\n\n    /**\r\n     * When user zooms in or out current zoom level is multiplied or divided\r\n     * by value of this setting.\r\n     *\r\n     * @default 2\r\n     * @param value  Zoom factor\r\n     */\n    set: function (value) {\n      this.setPropertyValue(\"zoomStep\", value);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\r\n   * Invalidates projection, causing all series to be redrawn.\r\n   *\r\n   * Call this after changing projection or its settings.\r\n   */\n\n  MapChart.prototype.invalidateProjection = function () {\n    this.invalidateDataUsers();\n    this.updateCenterGeoPoint();\n  };\n\n  Object.defineProperty(MapChart.prototype, \"geodataSource\", {\n    /**\r\n     * Returns a [[DataSource]] specifically for loading Component's data.\r\n     *\r\n     * @return Data source\r\n     */\n    get: function () {\n      if (!this._dataSources[\"geodata\"]) {\n        this.getDataSource(\"geodata\");\n      }\n\n      return this._dataSources[\"geodata\"];\n    },\n\n    /**\r\n     * Sets a [[DataSource]] to be used for loading Component's data.\r\n     *\r\n     * @param value Data source\r\n     */\n    set: function (value) {\n      var _this = this;\n\n      if (this._dataSources[\"geodata\"]) {\n        this.removeDispose(this._dataSources[\"geodata\"]);\n      }\n\n      this._dataSources[\"geodata\"] = value;\n      this._dataSources[\"geodata\"].component = this;\n      this.events.on(\"inited\", function () {\n        _this.loadData(\"geodata\");\n      }, this, false);\n      this.setDataSourceEvents(value, \"geodata\");\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\r\n   * Processes JSON-based config before it is applied to the object.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param config  Config\r\n   */\n\n  MapChart.prototype.processConfig = function (config) {\n    if ($type.hasValue(config[\"geodata\"]) && $type.isString(config[\"geodata\"])) {\n      var name_1 = config[\"geodata\"]; // Check if there's a map loaded by such name\n\n      if ($type.hasValue(window[\"am4geodata_\" + config[\"geodata\"]])) {\n        config[\"geodata\"] = window[\"am4geodata_\" + config[\"geodata\"]];\n      } // Nope. Let's try maybe we got JSON as string?\n      else {\n          try {\n            config[\"geodata\"] = JSON.parse(config[\"geodata\"]);\n          } catch (e) {\n            // No go again. Error out.\n            throw Error(\"MapChart error: Geodata `\" + name_1 + \"` is not loaded or is incorrect.\");\n          }\n        }\n    } // Instantiate projection\n\n\n    if ($type.hasValue(config[\"projection\"]) && $type.isString(config[\"projection\"])) {\n      config[\"projection\"] = this.createClassInstance(config[\"projection\"]);\n    } // Set up small map\n\n\n    if ($type.hasValue(config.smallMap) && !$type.hasValue(config.smallMap.type)) {\n      config.smallMap.type = \"SmallMap\";\n    } // Set up zoom control\n\n\n    if ($type.hasValue(config.zoomControl) && !$type.hasValue(config.zoomControl.type)) {\n      config.zoomControl.type = \"ZoomControl\";\n    }\n\n    _super.prototype.processConfig.call(this, config);\n  };\n  /**\r\n   * Decorates a new [[Series]] object with required parameters when it is\r\n   * added to the chart.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param event  Event\r\n   */\n\n\n  MapChart.prototype.handleSeriesAdded = function (event) {\n    _super.prototype.handleSeriesAdded.call(this, event);\n\n    var series = event.newValue;\n    series.scale = this.scaleRatio;\n    series.events.on(\"validated\", this.updateCenterGeoPoint, this, false);\n  };\n  /**\r\n   * This function is used to sort element's JSON config properties, so that\r\n   * some properties that absolutely need to be processed last, can be put at\r\n   * the end.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param a  Element 1\r\n   * @param b  Element 2\r\n   * @return Sorting number\r\n   */\n\n\n  MapChart.prototype.configOrder = function (a, b) {\n    if (a == b) {\n      return 0;\n    } // Must come last\n    else if (a == \"smallMap\") {\n        return 1;\n      } else if (b == \"smallMap\") {\n        return -1;\n      } else if (a == \"series\") {\n        return 1;\n      } else if (b == \"series\") {\n        return -1;\n      } else {\n        return _super.prototype.configOrder.call(this, a, b);\n      }\n  };\n  /**\r\n   * Adds `projection` to \"as is\" fields.\r\n   *\r\n   * @param field  Field name\r\n   * @return Assign as is?\r\n   */\n\n\n  MapChart.prototype.asIs = function (field) {\n    return field == \"projection\" || field == \"geodata\" || _super.prototype.asIs.call(this, field);\n  };\n\n  Object.defineProperty(MapChart.prototype, \"centerGeoPoint\", {\n    /**\r\n     * Geo point of map center\r\n     *\r\n     * @readonly\r\n     */\n    get: function () {\n      return this._centerGeoPoint;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\r\n   * Resets the map to its original position and zoom level.\r\n   *\r\n   * Use the only parameter to set number of milliseconds for the zoom\r\n   * animation to play.\r\n   *\r\n   * @param  duration  Duration (ms)\r\n   */\n\n  MapChart.prototype.goHome = function (duration) {\n    var homeGeoPoint = this.homeGeoPoint;\n\n    if (!homeGeoPoint) {\n      homeGeoPoint = this.centerGeoPoint;\n    }\n\n    if (homeGeoPoint) {\n      this.zoomToGeoPoint(homeGeoPoint, this.homeZoomLevel, true, duration);\n    }\n  };\n  /**\r\n   * Sets [[Paper]] instance to use to draw elements.\r\n   *\r\n   * @ignore\r\n   * @param   paper  Paper\r\n   * @return         true if paper was changed, false, if it's the same\r\n   */\n\n\n  MapChart.prototype.setPaper = function (paper) {\n    if (this.svgContainer) {\n      this.svgContainer.hideOverflow = true;\n    }\n\n    return _super.prototype.setPaper.call(this, paper);\n  };\n\n  Object.defineProperty(MapChart.prototype, \"backgroundSeries\", {\n    /**\r\n     * Background series will create polygons that will fill all the map area\r\n     * with some color (or other fill).\r\n     *\r\n     * This might be useful with non-rectangular projections, like Orthographic,\r\n     * Albers, etc.\r\n     *\r\n     * To change background color/opacity access polygon template.\r\n     *\r\n     * ```TypeScript\r\n     * chart.backgroundSeries.mapPolygons.template.polygon.fill = am4core.color(\"#fff\");\r\n     * chart.backgroundSeries.mapPolygons.template.polygon.fillOpacity = 0.1;\r\n     * ```\r\n     * ```JavaScript\r\n     * chart.backgroundSeries.mapPolygons.template.polygon.fill = am4core.color(\"#fff\");\r\n     * chart.backgroundSeries.mapPolygons.template.polygon.fillOpacity = 0.1;\r\n     * ```\r\n     * ```JSON\r\n     * {\r\n     *   \"backgroundSeries\": {\r\n     *     \"mapPolygons\": {\r\n     *       \"polygon\": {\r\n     *         \"fill\": \"#fff\",\r\n     *         \"fillOpacity\": 0.1\r\n     *       }\r\n     *     }\r\n     *   }\r\n     * }\r\n     * ```\r\n     *\r\n     * @since 4.3.0\r\n     */\n    get: function () {\n      var _this = this;\n\n      if (!this._backgroundSeries) {\n        var backgroundSeries = new MapPolygonSeries();\n        backgroundSeries.parent = this.seriesContainer;\n        backgroundSeries.chart = this;\n        backgroundSeries.hiddenInLegend = true;\n        backgroundSeries.addDisposer(new Disposer(function () {\n          _this._backgroundSeries = undefined;\n        }));\n\n        this._disposers.push(backgroundSeries);\n\n        var interfaceColors = new InterfaceColorSet();\n        var color = interfaceColors.getFor(\"background\");\n        var polygonTemplate = backgroundSeries.mapPolygons.template.polygon;\n        polygonTemplate.stroke = color;\n        polygonTemplate.fill = color;\n        polygonTemplate.fillOpacity = 0;\n        polygonTemplate.strokeOpacity = 0;\n        backgroundSeries.mapPolygons.create();\n        this._backgroundSeries = backgroundSeries;\n      }\n\n      return this._backgroundSeries;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\r\n   * Prepares the legend instance for use in this chart.\r\n   *\r\n   * @param legend  Legend\r\n   */\n\n  MapChart.prototype.setLegend = function (legend) {\n    _super.prototype.setLegend.call(this, legend);\n\n    legend.parent = this;\n  };\n  /**\r\n   * @param  value  Tap to activate?\r\n   */\n\n\n  MapChart.prototype.setTapToActivate = function (value) {\n    _super.prototype.setTapToActivate.call(this, value); // setup other containers\n\n\n    this.seriesContainer.interactions.isTouchProtected = true;\n    this.panSprite.interactions.isTouchProtected = true;\n  };\n\n  MapChart.prototype.handleTapToActivate = function () {\n    _super.prototype.handleTapToActivate.call(this);\n\n    this.seriesContainer.interactions.isTouchProtected = false;\n    this.panSprite.interactions.isTouchProtected = false;\n  };\n\n  MapChart.prototype.handleTapToActivateDeactivation = function () {\n    _super.prototype.handleTapToActivateDeactivation.call(this);\n\n    this.seriesContainer.interactions.isTouchProtected = true;\n    this.panSprite.interactions.isTouchProtected = true;\n  };\n  /**\r\n   * Adds easing functions to \"function\" fields.\r\n   *\r\n   * @param field  Field name\r\n   * @return Assign as function?\r\n   */\n\n\n  MapChart.prototype.asFunction = function (field) {\n    return field == \"zoomEasing\" || _super.prototype.asIs.call(this, field);\n  };\n\n  return MapChart;\n}(SerialChart);\n\nexport { MapChart };\n/**\r\n * Register class in system, so that it can be instantiated using its name from\r\n * anywhere.\r\n *\r\n * @ignore\r\n */\n\nregistry.registeredClasses[\"MapChart\"] = MapChart;","map":null,"metadata":{},"sourceType":"module"}