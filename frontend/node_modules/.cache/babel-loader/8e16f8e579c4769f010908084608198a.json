{"ast":null,"code":"/**\r\n * Map polygon module\r\n */\nimport * as tslib_1 from \"tslib\";\n/**\r\n * ============================================================================\r\n * IMPORTS\r\n * ============================================================================\r\n * @hidden\r\n */\n\nimport { MapObject } from \"./MapObject\";\nimport { Polygon } from \"../../core/elements/Polygon\";\nimport { registry } from \"../../core/Registry\";\nimport * as $type from \"../../core/utils/Type\";\nimport { InterfaceColorSet } from \"../../core/utils/InterfaceColorSet\";\nimport $polylabel from \"polylabel\";\nimport * as $mapUtils from \"./MapUtils\";\nimport * as d3geo from \"d3-geo\";\n/**\r\n * ============================================================================\r\n * MAIN CLASS\r\n * ============================================================================\r\n * @hidden\r\n */\n\n/**\r\n * Used to draw a polygon on the map.\r\n *\r\n * @see {@link IMapPolygonEvents} for a list of available events\r\n * @see {@link IMapPolygonAdapters} for a list of available Adapters\r\n */\n\nvar MapPolygon =\n/** @class */\nfunction (_super) {\n  tslib_1.__extends(MapPolygon, _super);\n  /**\r\n   * Constructor\r\n   */\n\n\n  function MapPolygon() {\n    var _this = _super.call(this) || this;\n\n    _this.className = \"MapPolygon\";\n    _this.polygon = _this.createChild(Polygon);\n    _this.polygon.shouldClone = false;\n    _this.polygon.applyOnClones = true;\n    var interfaceColors = new InterfaceColorSet();\n    _this.fill = interfaceColors.getFor(\"secondaryButton\");\n    _this.stroke = interfaceColors.getFor(\"secondaryButtonStroke\");\n    _this.strokeOpacity = 1;\n    _this.tooltipPosition = \"pointer\";\n    _this.nonScalingStroke = true;\n\n    _this.applyTheme();\n\n    return _this;\n  }\n  /**\r\n   * @ignore\r\n   */\n\n\n  MapPolygon.prototype.getFeature = function () {\n    if (this.multiPolygon && this.multiPolygon.length > 0) {\n      return {\n        \"type\": \"Feature\",\n        geometry: {\n          type: \"MultiPolygon\",\n          coordinates: this.multiPolygon\n        }\n      };\n    }\n  };\n\n  Object.defineProperty(MapPolygon.prototype, \"multiGeoPolygon\", {\n    /**\r\n     * @return Polygon coordinates\r\n     */\n    get: function () {\n      var multiGeoPolygon = this.getPropertyValue(\"multiGeoPolygon\");\n\n      if (!multiGeoPolygon && this.dataItem) {\n        multiGeoPolygon = this.dataItem.multiGeoPolygon;\n      }\n\n      return multiGeoPolygon;\n    },\n\n    /**\r\n     * Set of coordinates for the polygon.\r\n     *\r\n     * @param multiGeoPolygon  Polygon coordinates\r\n     */\n    set: function (multiGeoPolygon) {\n      this.setPropertyValue(\"multiGeoPolygon\", multiGeoPolygon, true);\n      this.multiPolygon = $mapUtils.multiGeoPolygonToMultipolygon(multiGeoPolygon);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(MapPolygon.prototype, \"multiPolygon\", {\n    /**\r\n     * @return Coordinates\r\n     */\n    get: function () {\n      var multiPolygon = this.getPropertyValue(\"multiPolygon\");\n\n      if (!multiPolygon && this.dataItem) {\n        multiPolygon = this.dataItem.multiPolygon;\n      }\n\n      return multiPolygon;\n    },\n\n    /**\r\n     * A collection of X/Y coordinates for a multi-part polygon. E.g.:\r\n     *\r\n     * ```JSON\r\n     * [\r\n     *   // Part 1\r\n     *   [\r\n     *     [\r\n     *       [ 100, 150 ],\r\n     *       [ 120, 200 ],\r\n     *       [ 150, 220 ],\r\n     *       [ 170, 240 ],\r\n     *       [ 100, 150 ]\r\n     *     ]\r\n     *   ],\r\n     *\r\n     *   // Part 2\r\n     *   [\r\n     *     [\r\n     *       [ 300, 350 ],\r\n     *       [ 320, 400 ],\r\n     *       [ 350, 420 ],\r\n     *       [ 370, 440 ],\r\n     *       [ 300, 350 ]\r\n     *     ]\r\n     *   ]\r\n     * ]\r\n     * ```\r\n     *\r\n     * @param multiPolygon  Coordinates\r\n     */\n    set: function (multiPolygon) {\n      if (this.setPropertyValue(\"multiPolygon\", multiPolygon)) {\n        this.updateExtremes();\n        this.invalidate();\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\r\n   * (Re)validates the polygon, effectively redrawing it.\r\n   *\r\n   * @ignore Exclude from docs\r\n   */\n\n  MapPolygon.prototype.validate = function () {\n    if (this.series) {\n      var projection = this.series.chart.projection;\n      projection.d3Projection.precision(0.5);\n      var pathGenerator = projection.d3Path;\n\n      if (this.multiPolygon) {\n        if (this.series) {\n          var feature = {\n            type: \"MultiPolygon\",\n            coordinates: this.multiPolygon\n          };\n          this.polygon.path = pathGenerator(feature);\n        }\n\n        if (this.series.calculateVisualCenter) {\n          var biggestArea = 0;\n          var biggestPolygon = this.multiPolygon[0];\n\n          if (this.multiPolygon.length > 1) {\n            for (var i = 0; i < this.multiPolygon.length; i++) {\n              var polygon = this.multiPolygon[i];\n              var area = d3geo.geoArea({\n                type: \"Polygon\",\n                coordinates: polygon\n              });\n\n              if (area > biggestArea) {\n                biggestPolygon = polygon;\n                biggestArea = area;\n              }\n            }\n          }\n\n          var center = $polylabel(biggestPolygon);\n          this._visualLongitude = center[0];\n          this._visualLatitude = center[1];\n        } else {\n          this._visualLongitude = this.longitude;\n          this._visualLatitude = this.latitude;\n        }\n      }\n    }\n\n    _super.prototype.validate.call(this);\n  };\n  /**\r\n   * @ignore Exclude from docs\r\n   */\n\n\n  MapPolygon.prototype.measureElement = function () {// Overriding, just to avoid extra measure\n  };\n\n  Object.defineProperty(MapPolygon.prototype, \"latitude\", {\n    /**\r\n     * Latitude of the geometrical center of the polygon.\r\n     *\r\n     * @readonly\r\n     * @return Center latitude\r\n     */\n    get: function () {\n      return this.north + (this.south - this.north) / 2;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(MapPolygon.prototype, \"longitude\", {\n    /**\r\n     * Longitude of the geometrical center of the polygon.\r\n     *\r\n     * @readonly\r\n     * @return Center longitude\r\n     */\n    get: function () {\n      return this.east + (this.west - this.east) / 2;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(MapPolygon.prototype, \"visualLatitude\", {\n    /**\r\n     * @return  Latitude\r\n     */\n    get: function () {\n      var latitude = this.getPropertyValue(\"visualLatitude\");\n\n      if ($type.isNumber(latitude)) {\n        return latitude;\n      }\n\n      if (!this._adapterO) {\n        return this._visualLatitude;\n      } else {\n        return this._adapterO.apply(\"visualLatitude\", this._visualLatitude);\n      }\n    },\n\n    /**\r\n     * Latitude of the visual center of the polygon.\r\n     *\r\n     * It may (and probably won't) coincide with geometrical center.\r\n     *\r\n     * @since 4.3.0\r\n     * @param  value  Latitude\r\n     */\n    set: function (value) {\n      this.setPropertyValue(\"visualLatitude\", value);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(MapPolygon.prototype, \"visualLongitude\", {\n    /**\r\n     * @return  Longitude\r\n     */\n    get: function () {\n      var longitude = this.getPropertyValue(\"visualLongitude\");\n\n      if ($type.isNumber(longitude)) {\n        return longitude;\n      }\n\n      if (!this._adapterO) {\n        return this._visualLongitude;\n      } else {\n        return this._adapterO.apply(\"visualLongitude\", this._visualLongitude);\n      }\n    },\n\n    /**\r\n     * Longitude of the visual center of the polygon.\r\n     *\r\n     * It may (and probably won't) coincide with geometrical center.\r\n     *\r\n     * @since 4.3.0\r\n     * @param  value  Longitude\r\n     */\n    set: function (value) {\n      this.setPropertyValue(\"visualLongitude\", value);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(MapPolygon.prototype, \"pixelWidth\", {\n    /**\r\n     * Not 100% sure about this, as if we add something to MapPolygon this\r\n     * won't be true, but otherwise we will get all 0 and the tooltip won't\r\n     * be positioned properly\r\n     * @hidden\r\n     */\n\n    /**\r\n     * Element's width in pixels.\r\n     *\r\n     * @readonly\r\n     * @return Width (px)\r\n     */\n    get: function () {\n      return this.polygon.pixelWidth;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(MapPolygon.prototype, \"pixelHeight\", {\n    /**\r\n     * Element's height in pixels.\r\n     *\r\n     * @readonly\r\n     * @return Width (px)\r\n     */\n    get: function () {\n      return this.polygon.pixelHeight;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\r\n   * Copies all properties from another instance of [[MapPolygon]].\r\n   *\r\n   * @param source  Source series\r\n   */\n\n  MapPolygon.prototype.copyFrom = function (source) {\n    _super.prototype.copyFrom.call(this, source);\n\n    this.polygon.copyFrom(source.polygon);\n  };\n  /**\r\n   * @ignore\r\n   */\n\n\n  MapPolygon.prototype.updateExtremes = function () {\n    _super.prototype.updateExtremes.call(this);\n  };\n\n  Object.defineProperty(MapPolygon.prototype, \"boxArea\", {\n    /**\r\n     * @ignore\r\n     * used to sorth polygons from big to small\r\n     */\n    get: function () {\n      return (this.north - this.south) * (this.east - this.west);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\r\n   * X coordinate for the slice tooltip.\r\n   *\r\n   * @ignore\r\n   * @return X\r\n   */\n\n  MapPolygon.prototype.getTooltipX = function () {\n    return this.series.chart.projection.convert({\n      longitude: this.visualLongitude,\n      latitude: this.visualLatitude\n    }).x;\n  };\n  /**\r\n   * Y coordinate for the slice tooltip.\r\n   *\r\n   * @ignore\r\n   * @return Y\r\n   */\n\n\n  MapPolygon.prototype.getTooltipY = function () {\n    return this.series.chart.projection.convert({\n      longitude: this.visualLongitude,\n      latitude: this.visualLatitude\n    }).y;\n  };\n\n  return MapPolygon;\n}(MapObject);\n\nexport { MapPolygon };\n/**\r\n * Register class in system, so that it can be instantiated using its name from\r\n * anywhere.\r\n *\r\n * @ignore\r\n */\n\nregistry.registeredClasses[\"MapPolygon\"] = MapPolygon;","map":null,"metadata":{},"sourceType":"module"}