{"ast":null,"code":"/**\r\n * A module for the mini-map control.\r\n */\nimport * as tslib_1 from \"tslib\";\n/**\r\n * ============================================================================\r\n * IMPORTS\r\n * ============================================================================\r\n * @hidden\r\n */\n\nimport { Container } from \"../../core/Container\";\nimport { Rectangle } from \"../../core/elements/Rectangle\";\nimport { List } from \"../../core/utils/List\";\nimport { MutableValueDisposer, MultiDisposer } from \"../../core/utils/Disposer\";\nimport { registry } from \"../../core/Registry\";\nimport { color } from \"../../core/utils/Color\";\nimport { InterfaceColorSet } from \"../../core/utils/InterfaceColorSet\";\nimport * as $utils from \"../../core/utils/Utils\";\nimport * as $type from \"../../core/utils/Type\";\n/**\r\n * ============================================================================\r\n * MAIN CLASS\r\n * ============================================================================\r\n * @hidden\r\n */\n\n/**\r\n * Creates a \"bird's eye\" view of the whole map.\r\n *\r\n * This control creates a mini-map with the whole of the map, highlighting\r\n * the area which is in the current viewport of the map map.\r\n *\r\n * @see {@link ISmallMapEvents} for a list of available events\r\n * @see {@link ISmallMapAdapters} for a list of available Adapters\r\n * @important\r\n */\n\nvar SmallMap =\n/** @class */\nfunction (_super) {\n  tslib_1.__extends(SmallMap, _super);\n  /**\r\n   * Constructor\r\n   */\n\n\n  function SmallMap() {\n    var _this = // Init\n    _super.call(this) || this;\n    /**\r\n     * A target map.\r\n     */\n\n\n    _this._chart = new MutableValueDisposer();\n    _this.className = \"SmallMap\"; // Set defaults\n\n    _this.align = \"left\";\n    _this.valign = \"bottom\";\n    _this.percentHeight = 20;\n    _this.percentWidth = 20;\n\n    _this.margin(5, 5, 5, 5);\n\n    var interfaceColors = new InterfaceColorSet(); // Set background defailts\n\n    _this.background.fillOpacity = 0.9;\n    _this.background.fill = interfaceColors.getFor(\"background\"); // Set up events\n\n    _this.events.on(\"hit\", _this.moveToPosition, _this, false);\n\n    _this.events.on(\"maxsizechanged\", _this.updateMapSize, _this, false); // Create a container\n\n\n    _this.seriesContainer = _this.createChild(Container);\n    _this.seriesContainer.shouldClone = false; // Create an outline rectangle\n\n    var rectangle = _this.createChild(Rectangle);\n\n    rectangle.shouldClone = false;\n    rectangle.stroke = interfaceColors.getFor(\"alternativeBackground\");\n    rectangle.strokeWidth = 1;\n    rectangle.strokeOpacity = 0.5;\n    rectangle.fill = color(); //\"none\";\n\n    rectangle.verticalCenter = \"middle\";\n    rectangle.horizontalCenter = \"middle\";\n    rectangle.isMeasured = false;\n    rectangle.visible = false;\n    _this.rectangle = rectangle;\n\n    _this._disposers.push(_this._chart); // Apply theme\n\n\n    _this.applyTheme();\n\n    return _this;\n  }\n\n  Object.defineProperty(SmallMap.prototype, \"series\", {\n    /**\r\n     * A list of map series used to draw the mini-map.\r\n     *\r\n     * @readonly\r\n     * @return Series\r\n     */\n    get: function () {\n      if (!this._series) {\n        this._series = new List();\n\n        this._series.events.on(\"inserted\", this.handleSeriesAdded, this, false);\n\n        this._series.events.on(\"removed\", this.handleSeriesRemoved, this, false);\n      }\n\n      return this._series;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\r\n   * Decorates a new series when they are pushed into a `series` list.\r\n   *\r\n   * @param event Event\r\n   */\n\n  SmallMap.prototype.handleSeriesAdded = function (event) {\n    var series = event.newValue;\n\n    if (this.chart.series.contains(series)) {\n      var newSeries = series.clone();\n\n      this._series.removeValue(series);\n\n      this._series.push(newSeries);\n\n      series = newSeries;\n      this.chart.dataUsers.push(newSeries);\n    }\n\n    series.chart = this.chart;\n    series.parent = this.seriesContainer;\n    series.interactionsEnabled = false;\n    series.events.on(\"inited\", this.updateMapSize, this, false);\n    series.hidden = false;\n  };\n  /**\r\n   * Cleans up after series are removed from Scrollbar.\r\n   *\r\n   * @param event  Event\r\n   */\n\n\n  SmallMap.prototype.handleSeriesRemoved = function (event) {\n    //let sourceSeries: MapSeries = event.oldValue;\n    this.invalidate();\n  };\n  /**\r\n   * Moves main map pan position after click on the small map.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param event  Event\r\n   */\n\n\n  SmallMap.prototype.moveToPosition = function (event) {\n    var rectPoint = $utils.spritePointToSprite(event.spritePoint, this, this.seriesContainer);\n    var geoPoint = this.chart.seriesPointToGeo(rectPoint);\n    this.chart.zoomToGeoPoint(geoPoint, this.chart.zoomLevel, true);\n  };\n\n  Object.defineProperty(SmallMap.prototype, \"chart\", {\n    /**\r\n     * @return Chart/map\r\n     */\n    get: function () {\n      return this._chart.get();\n    },\n\n    /**\r\n     * A chart/map that this control is meant for.\r\n     *\r\n     * @param chart  Chart/map\r\n     */\n    set: function (chart) {\n      if (this.chart != chart) {\n        this._chart.set(chart, new MultiDisposer([//chart.events.on(\"zoomlevelchanged\", this.updateRectangle, this, false),\n        chart.events.on(\"mappositionchanged\", this.updateRectangle, this, false), chart.events.on(\"scaleratiochanged\", this.updateMapSize, this, false)]));\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\r\n   * Updates the viewport recangle as per current map zoom/pan position.\r\n   *\r\n   * @ignore Exclude from docs\r\n   */\n\n  SmallMap.prototype.updateRectangle = function () {\n    var chart = this.chart;\n    var zoomLevel = chart.zoomLevel;\n    var rectangle = this.rectangle;\n    rectangle.width = this.pixelWidth / zoomLevel;\n    rectangle.height = this.pixelHeight / zoomLevel;\n    var scale = Math.min(this.percentWidth, this.percentHeight) / 100;\n    var seriesContainer = chart.seriesContainer;\n    rectangle.x = Math.ceil(-seriesContainer.pixelX * scale / zoomLevel) + this.seriesContainer.pixelX;\n    rectangle.y = Math.ceil(-seriesContainer.pixelY * scale / zoomLevel) + this.seriesContainer.pixelY;\n    rectangle.validate();\n  };\n  /**\r\n   * Update map size so that internal elements can redraw themselves after\r\n   * the size of the small map changes.\r\n   *\r\n   * @ignore Exclude from docs\r\n   */\n\n\n  SmallMap.prototype.updateMapSize = function () {\n    if (this.chart) {\n      var scale = this.chart.scaleRatio * Math.min(this.percentWidth, this.percentHeight) / 100;\n      this.seriesContainer.scale = scale;\n      var bbox = {\n        width: 0,\n        height: 0,\n        x: 0,\n        y: 0\n      };\n\n      try {\n        // Add exception catching to tame FF\n        bbox = this.seriesContainer.group.node.getBBox();\n      } catch (err) {}\n\n      if (bbox.width > 0) {\n        this.rectangle.visible = true;\n      }\n\n      this.seriesContainer.x = this.pixelWidth / 2 - bbox.x * scale - bbox.width / 2 * scale;\n      this.seriesContainer.y = this.pixelHeight / 2 - bbox.y * scale - bbox.height / 2 * scale;\n      this.updateRectangle();\n      this.afterDraw();\n    }\n  };\n  /**\r\n   * Update elements after drawing the small map.\r\n   */\n\n\n  SmallMap.prototype.afterDraw = function () {\n    _super.prototype.afterDraw.call(this); //this.seriesContainer.moveTo({ x: this.pixelWidth / 2, y: this.pixelHeight / 2 });\n\n\n    this.rectangle.maskRectangle = {\n      x: -1,\n      y: -1,\n      width: Math.ceil(this.pixelWidth + 2),\n      height: Math.ceil(this.pixelHeight + 2)\n    };\n  };\n  /**\r\n   * Processes JSON-based config before it is applied to the object.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param config  Config\r\n   */\n\n\n  SmallMap.prototype.processConfig = function (config) {\n    if (config) {\n      // Set up series\n      if ($type.hasValue(config.series) && $type.isArray(config.series)) {\n        for (var i = 0, len = config.series.length; i < len; i++) {\n          var series = config.series[i];\n\n          if ($type.hasValue(series) && $type.isString(series) && this.map.hasKey(series)) {\n            config.series[i] = this.map.getKey(series);\n          }\n        }\n      }\n    }\n\n    _super.prototype.processConfig.call(this, config);\n  };\n\n  return SmallMap;\n}(Container);\n\nexport { SmallMap };\n/**\r\n * Register class in system, so that it can be instantiated using its name from\r\n * anywhere.\r\n *\r\n * @ignore\r\n */\n\nregistry.registeredClasses[\"SmallMap\"] = SmallMap;","map":null,"metadata":{},"sourceType":"module"}