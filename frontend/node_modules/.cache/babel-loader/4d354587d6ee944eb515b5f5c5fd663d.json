{"ast":null,"code":"/**\r\n * Provides functionality used to creating and showing tooltips (balloons).\r\n */\nimport * as tslib_1 from \"tslib\";\n/**\r\n * ============================================================================\r\n * IMPORTS\r\n * ============================================================================\r\n * @hidden\r\n */\n\nimport { Container } from \"../Container\";\nimport { registry } from \"../../core/Registry\";\nimport { PointedRectangle } from \"./PointedRectangle\";\nimport { Label } from \"../elements/Label\";\nimport { Animation } from \"../utils/Animation\";\nimport { color } from \"../utils/Color\";\nimport { DropShadowFilter } from \"../rendering/filters/DropShadowFilter\";\nimport * as $math from \"../utils/Math\";\nimport * as $ease from \"../utils/Ease\";\nimport * as $utils from \"../utils/Utils\";\n/**\r\n * ============================================================================\r\n * MAIN CLASS\r\n * ============================================================================\r\n * @hidden\r\n */\n\n/**\r\n * Tooltip displays text and/or multimedia information in a balloon over chart\r\n * area.\r\n * @see {@link ITooltipEvents} for a list of available events\r\n * @see {@link ITooltipAdapters} for a list of available Adapters\r\n */\n\nvar Tooltip =\n/** @class */\nfunction (_super) {\n  tslib_1.__extends(Tooltip, _super);\n  /**\r\n   * Constructor\r\n   */\n\n\n  function Tooltip() {\n    var _this = // Init\n    _super.call(this) || this;\n    /**\r\n     * Holds numeric boundary values. Calculated from the `boundingContainer`.\r\n     * @ignore\r\n     */\n\n\n    _this._boundingRect = {\n      x: -40000,\n      y: -40000,\n      width: 80000,\n      height: 80000\n    };\n    /**\r\n     * Coordinates tooltip's pointer (stem) should point to.\r\n     */\n\n    _this._pointTo = {\n      x: 0,\n      y: 0\n    };\n    /**\r\n     * If set to `true` the pointer/stem of the Tooltip will not go outside\r\n     * Tooltip's width or height depending on pointer's orientation.\r\n     *\r\n     * @default false\r\n     */\n\n    _this.fitPointerToBounds = false;\n    /**\r\n     * If `tooltipOrientation` is vertical, it can be drawn below or above point\r\n     * We need to know this when solving overlapping.\r\n     */\n\n    _this._verticalOrientation = \"up\";\n    _this.className = \"Tooltip\";\n    _this.isMeasured = false;\n    _this.getFillFromObject = true;\n\n    _this.margin(5, 5, 5, 5);\n\n    _this.defaultState.transitionDuration = 1;\n    _this.hiddenState.transitionDuration = 1; // Create chrome/background\n\n    var background = _this.background;\n    background.interactionsEnabled = false;\n    background.fillOpacity = 0.9;\n    background.strokeWidth = 1;\n    background.strokeOpacity = 1;\n    background.stroke = color(\"#ffffff\");\n    background.cornerRadius = 3;\n    background.pointerLength = 6;\n    background.pointerBaseWidth = 10;\n    var dropShadow = new DropShadowFilter();\n    dropShadow.dy = 1;\n    dropShadow.dx = 1;\n    dropShadow.opacity = 0.5;\n    background.filters.push(dropShadow);\n    _this.autoTextColor = true; // Create text element\n\n    var label = _this.createChild(Label);\n\n    label.shouldClone = false;\n    _this.label = label;\n    label.padding(7, 12, 4, 12);\n    label.interactionsEnabled = false;\n    label.horizontalCenter = \"middle\";\n    label.fill = color(\"#ffffff\");\n\n    _this._disposers.push(label);\n\n    _this.label.events.on(\"sizechanged\", _this.drawBackground, _this);\n\n    _this.label.zIndex = 1; // @todo remove this line when bg sorting is solved\n    // Set defaults\n\n    _this.pointerOrientation = \"vertical\";\n    _this.animationDuration = 0;\n    _this.animationEasing = $ease.cubicOut;\n\n    _this.setPropertyValue(\"showInViewport\", false); // Set accessibility options\n\n\n    _this.role = \"tooltip\";\n    _this.visible = false;\n    _this.opacity = 0;\n    _this.x = 0;\n    _this.y = 0;\n\n    _this.events.on(\"visibilitychanged\", _this.handleVisibility, _this); // Apply theme\n\n\n    _this.applyTheme();\n\n    return _this;\n  }\n\n  Tooltip.prototype.handleVisibility = function () {\n    if (this.visible) {\n      this.label.invalidate();\n    }\n  };\n\n  Object.defineProperty(Tooltip.prototype, \"getStrokeFromObject\", {\n    /**\r\n     * Specifies if tooltip background should get stroke color from the sprite it is pointing to.\r\n     *\r\n     * @return {boolean}\r\n     * @default false\r\n     */\n    get: function () {\n      return this.getPropertyValue(\"getStrokeFromObject\");\n    },\n\n    /**\r\n     * Specifies if tooltip background should get stroke color from the sprite it is pointing to.\r\n     *\r\n     * @param value boolean\r\n     */\n    set: function (value) {\n      this.setPropertyValue(\"getStrokeFromObject\", value, true);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Tooltip.prototype, \"autoTextColor\", {\n    /**\r\n     * @return {boolean}\r\n     */\n    get: function () {\n      return this.getPropertyValue(\"autoTextColor\");\n    },\n\n    /**\r\n     * Specifies if text color should be chosen automatically for a better\r\n     * readability.\r\n     *\r\n     * IMPORTANT: this feature is generally ignored, if `getFillFromObject = false`.\r\n     *\r\n     * If inheriting of `fill` color from object tooltip is displayed for is\r\n     * disabled, this feature will not work. If you are explicitly setting a\r\n     * color for tooltip background, you may set a color for its label as well\r\n     * using `tooltip.label.fill` property.\r\n     *\r\n     *\r\n     * @param value boolean\r\n     */\n    set: function (value) {\n      this.setPropertyValue(\"autoTextColor\", value, true);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Tooltip.prototype, \"keepTargetHover\", {\n    /**\r\n     * @return Keep target hovered?\r\n     */\n    get: function () {\n      return this.getPropertyValue(\"keepTargetHover\");\n    },\n\n    /**\r\n     * If this tooltip is displayed on hover on some other object, keep that\r\n     * element hovered if hovering on the tooltip.\r\n     *\r\n     * @default false\r\n     * @since 4.1.13\r\n     * @param  value  Keep target hovered?\r\n     */\n    set: function (value) {\n      var _this = this;\n\n      if (this.setPropertyValue(\"keepTargetHover\", value, true)) {\n        if (value) {\n          this.hoverable = true;\n          this.background.interactionsEnabled = true;\n\n          this._disposers.push(this.events.on(\"over\", function (ev) {\n            if (_this.targetSprite && _this.targetSprite.hoverable) {\n              _this.targetSprite.isHover = true;\n            }\n          }));\n\n          this._disposers.push(this.events.on(\"out\", function (ev) {\n            if (_this.targetSprite && _this.targetSprite.hoverable) {\n              //this.hideTooltip();\n              //this.targetSprite.handleOut();\n              _this.targetSprite.isHover = false;\n            }\n          }));\n        }\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Tooltip.prototype, \"showInViewport\", {\n    /**\r\n     * @return Force showing tooltip?\r\n     */\n    get: function () {\n      return this.getPropertyValue(\"showInViewport\");\n    },\n\n    /**\r\n     * Normally, a tooltip will hide itself if it is pointing to a coordinate\r\n     * that is outside viewport.\r\n     *\r\n     * Setting this setting to `true` will override that and make tooltip\r\n     * appear next to the viewport edge closest to the target point.\r\n     *\r\n     * @default false\r\n     * @since 4.5.7\r\n     * @param  value  Force showing tooltip?\r\n     */\n    set: function (value) {\n      this.setPropertyValue(\"showInViewport\", value);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Tooltip.prototype, \"getFillFromObject\", {\n    /**\r\n     * Specifies if tooltip background should get fill color from the sprite it is pointing to.\r\n     *\r\n     * @return {boolean}\r\n     * @default true\r\n     */\n    get: function () {\n      return this.getPropertyValue(\"getFillFromObject\");\n    },\n\n    /**\r\n     * @param value boolean\r\n     */\n    set: function (value) {\n      this.setPropertyValue(\"getFillFromObject\", value, true);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\r\n   * Creates and returns a background element.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @return Background\r\n   */\n\n  Tooltip.prototype.createBackground = function () {\n    return new PointedRectangle();\n  };\n\n  Object.defineProperty(Tooltip.prototype, \"pointerOrientation\", {\n    /**\r\n     * @return Orientation\r\n     */\n    get: function () {\n      return this.getPropertyValue(\"pointerOrientation\");\n    },\n\n    /**\r\n     * Pointer orientation: `\"horizontal\"`, `\"vertical\"`, `\"up\"`, `\"down\"`,\r\n     * `\"right\"`, or `\"left\"`.\r\n     *\r\n     * Options`\"horizontal\"` or `\"vertical\"` are location-aware, meaning they\r\n     * will change position of the Tooltip based on the target point's position\r\n     * in relation to chart center.\r\n     *\r\n     * Options `\"up\"`, `\"down\"`, `\"right\"`, `\"left\"` are static and will point\r\n     * in the specified direction regardless of the position, even if that means\r\n     * going out of chart/screen bounds.\r\n     *\r\n     * IMPORTANT: in some situations, like having multiple tooltips stacked for\r\n     * multiple series, the `\"up\"` and `\"down\"` values might be ignored in order\r\n     * to make tooltip overlap algorithm work.\r\n     *\r\n     * @default \"vertical\"\r\n     * @param  value  Orientation\r\n     */\n    set: function (value) {\n      this.setPropertyValue(\"pointerOrientation\", value, true);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Tooltip.prototype, \"animationDuration\", {\n    /**\r\n     * @return Orientation\r\n     */\n    get: function () {\n      return this.getPropertyValue(\"animationDuration\");\n    },\n\n    /**\r\n     * Duration in milliseconds for the animation to take place when the tooltip\r\n     * is moving from one place to another.\r\n     *\r\n     * @default 0\r\n     * @param value  number\r\n     */\n    set: function (value) {\n      this.setPropertyValue(\"animationDuration\", value);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Tooltip.prototype, \"animationEasing\", {\n    /**\r\n     * @return {Function}\r\n     */\n    get: function () {\n      return this.getPropertyValue(\"animationEasing\");\n    },\n\n    /**\r\n     * Tooltip animation (moving from one place to another) easing function.\r\n     *\r\n     * @default $ease.cubicOut\r\n     * @param value (value: number) => number\r\n     */\n    set: function (value) {\n      this.setPropertyValue(\"animationEasing\", value);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Tooltip.prototype, \"html\", {\n    /**\r\n     * @return HTML content\r\n     */\n    get: function () {\n      return this.label.html;\n    },\n\n    /**\r\n     * HTML content for the Tooltip.\r\n     *\r\n     * Provided value will be used as is, without applying any further\r\n     * formatting to it.\r\n     *\r\n     * @param value  HTML content\r\n     */\n    set: function (value) {\n      if (this.label.html != value) {\n        this.label.html = value;\n        this.invalidate();\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Tooltip.prototype, \"text\", {\n    /**\r\n     * @return SVG text\r\n     */\n    get: function () {\n      return this.label.text;\n    },\n\n    /**\r\n     * SVG text content for the Tooltip.\r\n     *\r\n     * Text can have a number of formatting options supported by\r\n     * [[TextFormatter]].\r\n     *\r\n     * @param value  SVG text\r\n     */\n    set: function (value) {\n      if (this.label.text != value) {\n        this.label.text = value;\n        this.invalidate();\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\r\n   * Creates the Tooltip.\r\n   *\r\n   * @ignore Exclude from docs\r\n   */\n\n  Tooltip.prototype.draw = function () {\n    _super.prototype.draw.call(this);\n\n    var label = this.label;\n\n    if (label.invalid) {\n      label.validate();\n    }\n\n    var x = this._pointTo.x;\n    var y = this._pointTo.y;\n    var boundingRect = this._boundingRect;\n    var textW = label.measuredWidth;\n    var textH = label.measuredHeight;\n    var pointerLength = this.background.pointerLength;\n    var textX;\n    var textY; // try to handle if text is wider than br\n\n    if (textW > boundingRect.width) {\n      // TODO maybe this isn't needed ?\n      $utils.spritePointToDocument({\n        x: boundingRect.x,\n        y: boundingRect.y\n      }, this.parent);\n      var p1 = $utils.spritePointToDocument({\n        x: boundingRect.x + boundingRect.width,\n        y: boundingRect.y + boundingRect.height\n      }, this.parent);\n      var documentWidth = document.body.offsetWidth; // TODO maybe this isn't needed ?\n\n      $utils.used(document.body.offsetHeight);\n\n      if (p1.x > documentWidth / 2) {\n        boundingRect.x = boundingRect.width - textW;\n      } else {\n        boundingRect.width = boundingRect.x + textW;\n      }\n    }\n\n    var pointerOrientation = this.pointerOrientation; // horizontal\n\n    if (pointerOrientation == \"horizontal\" || pointerOrientation == \"left\" || pointerOrientation == \"right\") {\n      textY = -textH / 2;\n\n      if (pointerOrientation == \"horizontal\") {\n        if (x > boundingRect.x + boundingRect.width / 2) {\n          textX = -textW / 2 - pointerLength;\n        } else {\n          textX = textW / 2 + pointerLength;\n        }\n      } else if (pointerOrientation == \"left\") {\n        textX = textW / 2 + pointerLength;\n      } else {\n        textX = -textW / 2 - pointerLength;\n      }\n    } // vertical pointer\n    else {\n        textX = $math.fitToRange(0, boundingRect.x - x + textW / 2, boundingRect.x - x + boundingRect.width - textW / 2);\n\n        if (pointerOrientation == \"vertical\") {\n          if (y > boundingRect.y + textH + pointerLength) {\n            textY = -textH - pointerLength;\n            this._verticalOrientation = \"up\";\n          } else {\n            textY = pointerLength;\n            this._verticalOrientation = \"down\";\n          }\n        } else if (pointerOrientation == \"down\") {\n          textY = -textH - pointerLength;\n          this._verticalOrientation = \"up\";\n        } else {\n          textY = pointerLength;\n          this._verticalOrientation = \"down\";\n        }\n      }\n\n    textY = $math.fitToRange(textY, boundingRect.y - y, boundingRect.y + boundingRect.height - textH - y);\n    label.x = textX;\n    label.y = textY;\n    this.drawBackground();\n  };\n  /**\r\n   * Overrides functionality from the superclass.\r\n   *\r\n   * @ignore Exclude from docs\r\n   */\n\n\n  Tooltip.prototype.updateBackground = function () {\n    this.group.addToBack(this.background.group);\n  };\n  /**\r\n   * Draws Tooltip background (chrome, background and pointer/stem).\r\n   *\r\n   * @ignore Exclude from docs\r\n   */\n\n\n  Tooltip.prototype.drawBackground = function () {\n    var label = this.label;\n    var background = this.background;\n    var textWidth = label.measuredWidth;\n    var textHeight = label.measuredHeight;\n    var boundingRect = this._boundingRect;\n    var bgWidth = textWidth;\n    var bgX = label.pixelX - textWidth / 2;\n    var bgHeight = textHeight;\n    var bgY = label.pixelY;\n    var x = this._pointTo.x;\n    var y = this._pointTo.y;\n    var boundX1 = boundingRect.x - x;\n    var boundX2 = boundX1 + boundingRect.width;\n    var boundY1 = boundingRect.y - y;\n    var boundY2 = boundY1 + boundingRect.height;\n    background.x = bgX;\n    background.y = bgY;\n    background.width = bgWidth;\n    background.height = bgHeight;\n\n    if (this.fitPointerToBounds) {\n      background.pointerX = $math.fitToRange(-background.x, boundX1 - background.x, boundX2 - background.x);\n      background.pointerY = $math.fitToRange(-background.y, boundY1 - background.y, boundY2 - background.y);\n    } else {\n      background.pointerX = -background.x;\n      background.pointerY = -background.y;\n    }\n\n    background.validate();\n  };\n  /**\r\n   * Set nes tooltip's anchor point and moves whole tooltip.\r\n   *\r\n   * @param x  X coordinate\r\n   * @param y  Y coordinate\r\n   */\n\n\n  Tooltip.prototype.pointTo = function (point, instantly) {\n    if (this._pointTo.x != point.x || this._pointTo.y != point.y) {\n      this._pointTo = point;\n      this.invalidate(); // this helps to avoid strange animation from nowhere on initial show or when balloon was hidden already\n\n      if (!this.visible || instantly) {\n        this.moveTo(this._pointTo);\n\n        if (this._animation) {\n          this._animation.kill();\n        }\n      } else {\n        // helps to avoid flicker on top/left corner\n        if (this.pixelX == 0 && this.pixelY == 0) {\n          this.moveTo(this._pointTo);\n        } else {\n          if (this._animation) {\n            this._animation.kill();\n          }\n\n          this._animation = new Animation(this, [{\n            property: \"x\",\n            to: point.x,\n            from: this.pixelX\n          }, {\n            property: \"y\",\n            to: point.y,\n            from: this.pixelY\n          }], this.animationDuration, this.animationEasing).start();\n        }\n      }\n    }\n  };\n  /**\r\n   * Sets numeric boundaries Tooltip needs to obey (so it does not go outside\r\n   * specific area).\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param rectangle Boundary rectangle\r\n   */\n\n\n  Tooltip.prototype.setBounds = function (rectangle) {\n    var oldRect = this._boundingRect;\n\n    if (oldRect.x != rectangle.x || oldRect.y != rectangle.y || oldRect.width != rectangle.width || oldRect.height != rectangle.height) {\n      this._boundingRect = rectangle;\n      this.invalidate();\n    }\n  };\n\n  Object.defineProperty(Tooltip.prototype, \"boundingContainer\", {\n    /**\r\n     * Sets a [[Container]] instance to be used when calculating numeric\r\n     * boundaries for the Tooltip.\r\n     *\r\n     * @ignore Exclude from docs\r\n     * @param container  Boundary container\r\n     */\n    set: function (container) {\n      this._boundingContainer = container; // TODO remove closures ?\n\n      container.events.on(\"sizechanged\", this.updateBounds, this);\n      container.events.on(\"positionchanged\", this.updateBounds, this);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\r\n   * Updates numeric boundaries for the Tooltip, based on the\r\n   * `boundingCountrainer`.\r\n   */\n\n  Tooltip.prototype.updateBounds = function () {\n    var boundingContainer = this._boundingContainer; // to global\n\n    var rect = $utils.spriteRectToSvg({\n      x: boundingContainer.pixelX,\n      y: boundingContainer.pixelY,\n      width: boundingContainer.maxWidth,\n      height: boundingContainer.maxHeight\n    }, boundingContainer);\n    this.setBounds(rect);\n  };\n\n  Object.defineProperty(Tooltip.prototype, \"verticalOrientation\", {\n    /**\r\n     * If tooltipOrientation is vertical, it can be drawn below or above point.\r\n     * We need to know this when solving overlapping.\r\n     *\r\n     * @ignore Exclude from docs\r\n     * @return \"up\" | \"down\"\r\n     */\n    get: function () {\n      return this._verticalOrientation;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Tooltip.prototype, \"tooltip\", {\n    /**\r\n     * To avoid stackoverflow\r\n     * @ignore\r\n     */\n    get: function () {\n      return undefined;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\r\n   * Copies properties and other attributes.\r\n   *\r\n   * @param source  Source\r\n   */\n\n  Tooltip.prototype.copyFrom = function (source) {\n    _super.prototype.copyFrom.call(this, source);\n\n    this.label.copyFrom(source.label);\n\n    if (source._boundingRect) {\n      this._boundingRect = source._boundingRect;\n    }\n  };\n  /**\r\n   * Adds easing functions to \"function\" fields.\r\n   *\r\n   * @param field  Field name\r\n   * @return Assign as function?\r\n   */\n\n\n  Tooltip.prototype.asFunction = function (field) {\n    return field == \"animationEasing\" || _super.prototype.asIs.call(this, field);\n  };\n\n  return Tooltip;\n}(Container);\n\nexport { Tooltip };\n/**\r\n * Register class in system, so that it can be instantiated using its name from\r\n * anywhere.\r\n *\r\n * @ignore\r\n */\n\nregistry.registeredClasses[\"Tooltip\"] = Tooltip;","map":null,"metadata":{},"sourceType":"module"}