{"ast":null,"code":"/**\r\n * TreeMap chart module.\r\n *\r\n * Parts of the functionality used in this module are taken from D3.js library\r\n * (https://d3js.org/)\r\n */\nimport * as tslib_1 from \"tslib\";\n/**\r\n * ============================================================================\r\n * IMPORTS\r\n * ============================================================================\r\n * @hidden\r\n */\n\nimport { XYChart, XYChartDataItem } from \"./XYChart\";\nimport { registry } from \"../../core/Registry\";\nimport { DictionaryTemplate, DictionaryDisposer } from \"../../core/utils/Dictionary\";\nimport { ValueAxis } from \"../axes/ValueAxis\";\nimport { TreeMapSeries } from \"../series/TreeMapSeries\";\nimport { ColorSet } from \"../../core/utils/ColorSet\";\nimport { MouseCursorStyle } from \"../../core/interaction/Mouse\";\nimport * as $iter from \"../../core/utils/Iterator\";\nimport * as $type from \"../../core/utils/Type\";\nimport * as $array from \"../../core/utils/Array\";\n/**\r\n * ============================================================================\r\n * DATA ITEM\r\n * ============================================================================\r\n * @hidden\r\n */\n\n/**\r\n * Defines a [[DataItem]] for [[TreeMap]].\r\n *\r\n * @see {@link DataItem}\r\n */\n\nvar TreeMapDataItem =\n/** @class */\nfunction (_super) {\n  tslib_1.__extends(TreeMapDataItem, _super);\n  /**\r\n   * Constructor\r\n   */\n\n\n  function TreeMapDataItem() {\n    var _this = _super.call(this) || this;\n    /**\r\n     * Required for squarify functionality.\r\n     *\r\n     * @ignore Exclude from docs\r\n     */\n\n\n    _this.rows = [];\n    _this.className = \"TreeMapDataItem\";\n    _this.values.value = {};\n    _this.values.x0 = {};\n    _this.values.y0 = {};\n    _this.values.x1 = {};\n    _this.values.y1 = {};\n    _this.hasChildren.children = true;\n\n    _this.applyTheme();\n\n    return _this;\n  }\n\n  Object.defineProperty(TreeMapDataItem.prototype, \"legendDataItem\", {\n    /**\r\n     * @return Legend data item\r\n     */\n    get: function () {\n      return this._legendDataItem;\n    },\n\n    /**\r\n     * A legend's data item, that corresponds to this data item.\r\n     *\r\n     * @param value  Legend data item\r\n     */\n    set: function (value) {\n      this._legendDataItem = value;\n\n      if (value.label) {\n        value.label.dataItem = this;\n      }\n\n      if (value.valueLabel) {\n        value.valueLabel.dataItem = this;\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\r\n   * Returns a duration (ms) the Data Item should take to animate from one\r\n   * value to another.\r\n   *\r\n   * If the duration is not specified via parameter, this method will try to\r\n   * request a default duration from the related `Component`.\r\n   *\r\n   * @param duration  Default duration (ms)\r\n   * @return Duration (ms)\r\n   */\n\n  TreeMapDataItem.prototype.getDuration = function () {\n    return 0;\n  };\n\n  Object.defineProperty(TreeMapDataItem.prototype, \"value\", {\n    /**\r\n     * @return Value\r\n     */\n    get: function () {\n      var value = 0;\n\n      if (!this.children || this.children.length == 0) {\n        value = this.values[\"value\"].workingValue;\n      } else {\n        $iter.each(this.children.iterator(), function (child) {\n          var childValue = child.value;\n\n          if ($type.isNumber(childValue)) {\n            value += childValue;\n          }\n        });\n      }\n\n      return value;\n      /*\r\n      let value = this.values[\"value\"].workingValue;\r\n            if (!$type.isNumber(value)) {\r\n          value = 0;\r\n          if (this.children) {\r\n              $iter.each(this.children.iterator(), (child) => {\r\n                  if ($type.isNumber(child.value)) {\r\n                      value += child.value;\r\n                  }\r\n              });\r\n          }\r\n      }\r\n      return value;*/\n    },\n\n    /**\r\n     * Numeric value of the item.\r\n     *\r\n     * @param value  Value\r\n     */\n    set: function (value) {\n      this.setValue(\"value\", value);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(TreeMapDataItem.prototype, \"percent\", {\n    get: function () {\n      if (this.parent) {\n        return this.value / this.parent.value * 100;\n      }\n\n      return 100;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(TreeMapDataItem.prototype, \"x0\", {\n    /**\r\n     * @return X\r\n     */\n    get: function () {\n      return this.values.x0.value;\n    },\n\n    /**\r\n     * Item's X position.\r\n     *\r\n     * @ignore Exclude from docs\r\n     * @todo Description (review)\r\n     * @param value  X\r\n     */\n    set: function (value) {\n      this.setValue(\"x0\", value);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(TreeMapDataItem.prototype, \"x1\", {\n    /**\r\n     * @return X\r\n     */\n    get: function () {\n      return this.values.x1.value;\n    },\n\n    /**\r\n     * Item's X position.\r\n     *\r\n     * @ignore Exclude from docs\r\n     * @todo Description (review)\r\n     * @param value  X\r\n     */\n    set: function (value) {\n      this.setValue(\"x1\", value);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(TreeMapDataItem.prototype, \"y0\", {\n    /**\r\n     * @return Y\r\n     */\n    get: function () {\n      return this.values.y0.value;\n    },\n\n    /**\r\n     * Item's Y position.\r\n     *\r\n     * @ignore Exclude from docs\r\n     * @todo Description (review)\r\n     * @param value  Y\r\n     */\n    set: function (value) {\n      this.setValue(\"y0\", value);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(TreeMapDataItem.prototype, \"y1\", {\n    /**\r\n     * @return Y\r\n     */\n    get: function () {\n      return this.values.y1.value;\n    },\n\n    /**\r\n     * Item's Y position.\r\n     *\r\n     * @ignore Exclude from docs\r\n     * @todo Description (review)\r\n     * @param value  Y\r\n     */\n    set: function (value) {\n      this.setValue(\"y1\", value);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(TreeMapDataItem.prototype, \"name\", {\n    /**\r\n     * @return Name\r\n     */\n    get: function () {\n      return this.properties.name;\n    },\n\n    /**\r\n     * Item's name.\r\n     *\r\n     * @param name  Name\r\n     */\n    set: function (name) {\n      this.setProperty(\"name\", name);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(TreeMapDataItem.prototype, \"children\", {\n    /**\r\n     * @return Item's children\r\n     */\n    get: function () {\n      return this.properties.children;\n    },\n\n    /**\r\n     * A list of item's sub-children.\r\n     *\r\n     * Having children means that the TreeMap chat will automatically be\r\n     * \"drillable\". Clicking on an item with children will zoom to the item, then\r\n     * display its children.\r\n     *\r\n     * Treemap can have any level of nesting.\r\n     *\r\n     * @param children  Item's children\r\n     */\n    set: function (children) {\n      this.setProperty(\"children\", children);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(TreeMapDataItem.prototype, \"level\", {\n    /**\r\n     * Depth level in the treemap hierarchy.\r\n     *\r\n     * The top-level item will have level set at 0. Its children will have\r\n     * level 1, and so on.\r\n     *\r\n     * @readonly\r\n     * @return Level\r\n     */\n    get: function () {\n      if (!this.parent) {\n        return 0;\n      } else {\n        return this.parent.level + 1;\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(TreeMapDataItem.prototype, \"color\", {\n    /**\r\n     * @return Color\r\n     */\n    get: function () {\n      var color = this.properties.color;\n\n      if (color == undefined) {\n        if (this.parent) {\n          color = this.parent.color;\n        }\n      }\n\n      if (color == undefined) {\n        if (this.component) {\n          color = this.component.colors.getIndex(this.component.colors.step * this.index);\n        }\n      }\n\n      return color;\n    },\n\n    /**\r\n     * Item's color.\r\n     *\r\n     * If not set, will use parent's color, or, if that is not set either,\r\n     * automatically assigned color from chart's color set. (`chart.colors`)\r\n     *\r\n     * @param value  Color\r\n     */\n    set: function (value) {\n      this.setProperty(\"color\", value);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(TreeMapDataItem.prototype, \"fill\", {\n    /**\r\n     * @ignore\r\n     * For the legend to work properly\r\n     */\n    get: function () {\n      return this.color;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(TreeMapDataItem.prototype, \"series\", {\n    get: function () {\n      return this._series;\n    },\n\n    /**\r\n     * Series of children data items\r\n     * @todo: proper descrition\r\n     */\n    set: function (series) {\n      if (series != this._series) {\n        if (this._series) {\n          this.component.series.removeValue(this._series);\n\n          this._series.dispose();\n        }\n\n        this._series = series;\n\n        this._disposers.push(series);\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\r\n   * Hides the Data Item and related visual elements.\r\n   *\r\n   * @param duration  Animation duration (ms)\r\n   * @param delay     Delay animation (ms)\r\n   * @param toValue   A value to set to `fields` when hiding\r\n   * @param fields    A list of data fields to set value to `toValue`\r\n   */\n\n  TreeMapDataItem.prototype.hide = function (duration, delay, toValue, fields) {\n    this.setWorkingValue(\"value\", 0);\n\n    if (this.children) {\n      this.children.each(function (child) {\n        child.hide(duration, delay, toValue, fields);\n      });\n    }\n\n    return _super.prototype.hide.call(this, duration, delay, toValue, fields);\n  };\n  /**\r\n   * Shows the Data Item and related visual elements.\r\n   *\r\n   * @param duration  Animation duration (ms)\r\n   * @param delay     Delay animation (ms)\r\n   * @param fields    A list of fields to set values of\r\n   */\n\n\n  TreeMapDataItem.prototype.show = function (duration, delay, fields) {\n    this.setWorkingValue(\"value\", this.values.value.value);\n\n    if (this.children) {\n      this.children.each(function (child) {\n        child.show(duration, delay, fields);\n      });\n    }\n\n    return _super.prototype.show.call(this, duration, delay, fields);\n  };\n\n  return TreeMapDataItem;\n}(XYChartDataItem);\n\nexport { TreeMapDataItem };\n/**\r\n * ============================================================================\r\n * MAIN CLASS\r\n * ============================================================================\r\n * @hidden\r\n */\n\n/**\r\n * Creates a TreeMap chart.\r\n *\r\n * @see {@link ITreeMapEvents} for a list of available Events\r\n * @see {@link ITreeMapAdapters} for a list of available Adapters\r\n * @see {@link https://www.amcharts.com/docs/v4/chart-types/treemap/} for documentation\r\n */\n\nvar TreeMap =\n/** @class */\nfunction (_super) {\n  tslib_1.__extends(TreeMap, _super);\n  /**\r\n   * Constructor\r\n   */\n\n\n  function TreeMap() {\n    var _this = // Init\n    _super.call(this) || this;\n    /**\r\n     * An algorithm used to divide area into squares based on their value.\r\n     *\r\n     * Available options: squarify (default), binaryTree, slice, dice, sliceDice.\r\n     *\r\n     * ```TypeScript\r\n     * chart.layoutAlgorithm = chart.sliceDice;\r\n     * ```\r\n     * ```JavaScript\r\n     * chart.layoutAlgorithm = chart.sliceDice;\r\n     * ```\r\n     * ```JSON\r\n     * {\r\n     *   // ...\r\n     *   \"layoutAlgorithm\": \"sliceDice\",\r\n     *   // ...\r\n     * }\r\n     * ```\r\n     *\r\n     * @see {@link https://www.amcharts.com/docs/v4/chart-types/treemap/#Area_division_methods} For more info and examples.\r\n     * @default squarify\r\n     */\n\n\n    _this.layoutAlgorithm = _this.squarify;\n    /**\r\n     * Is the chart zoomable?\r\n     *\r\n     * If the chart is `zoomable`, and items have sub-items, the chart will\r\n     * drill-down to sub-items when click on their parent item.\r\n     *\r\n     * @default true\r\n     */\n\n    _this.zoomable = true;\n    _this.className = \"TreeMap\";\n    _this._usesData = true;\n    _this.maxLevels = 2;\n    _this.currentLevel = 0;\n    _this.hideParentColumns = false;\n    _this.colors = new ColorSet();\n    _this.sorting = \"descending\"; // create two value axes for the chart\n\n    var xAxis = _this.xAxes.push(new ValueAxis());\n\n    xAxis.title.disabled = true;\n    xAxis.strictMinMax = true;\n    var xRenderer = xAxis.renderer;\n    xRenderer.inside = true;\n    xRenderer.labels.template.disabled = true;\n    xRenderer.ticks.template.disabled = true;\n    xRenderer.grid.template.disabled = true;\n    xRenderer.axisFills.template.disabled = true;\n    xRenderer.minGridDistance = 100;\n    xRenderer.line.disabled = true;\n    xRenderer.baseGrid.disabled = true; //xRenderer.inversed = true;\n\n    var yAxis = _this.yAxes.push(new ValueAxis());\n\n    yAxis.title.disabled = true;\n    yAxis.strictMinMax = true;\n    var yRenderer = yAxis.renderer;\n    yRenderer.inside = true;\n    yRenderer.labels.template.disabled = true;\n    yRenderer.ticks.template.disabled = true;\n    yRenderer.grid.template.disabled = true;\n    yRenderer.axisFills.template.disabled = true;\n    yRenderer.minGridDistance = 100;\n    yRenderer.line.disabled = true;\n    yRenderer.baseGrid.disabled = true;\n    yRenderer.inversed = true; // shortcuts\n\n    _this.xAxis = xAxis;\n    _this.yAxis = yAxis;\n    var template = new TreeMapSeries();\n    _this.seriesTemplates = new DictionaryTemplate(template);\n    template.virtualParent = _this;\n\n    _this._disposers.push(new DictionaryDisposer(_this.seriesTemplates));\n\n    _this._disposers.push(template);\n\n    _this.zoomOutButton.events.on(\"hit\", function () {\n      _this.zoomToChartDataItem(_this._homeDataItem);\n    }, undefined, false);\n\n    _this.seriesTemplates.events.on(\"insertKey\", function (event) {\n      event.newValue.isTemplate = true;\n    }, undefined, false); // Apply theme\n\n\n    _this.applyTheme();\n\n    return _this;\n  }\n\n  Object.defineProperty(TreeMap.prototype, \"navigationBar\", {\n    /**\r\n     * Returns navigationBar if it is added to a chart\r\n     */\n    get: function () {\n      return this._navigationBar;\n    },\n\n    /**\r\n     * A navigation bar used to show \"breadcrumb\" control, indicating current\r\n     * drill-down path.\r\n     */\n    set: function (navigationBar) {\n      var _this = this;\n\n      if (this._navigationBar != navigationBar) {\n        this._navigationBar = navigationBar;\n        navigationBar.parent = this;\n        navigationBar.toBack();\n        navigationBar.links.template.events.on(\"hit\", function (event) {\n          var dataItem = event.target.dataItem.dataContext;\n\n          if (!dataItem.isDisposed()) {\n            _this.zoomToChartDataItem(dataItem);\n\n            _this.createTreeSeries(dataItem);\n          }\n        }, undefined, true);\n\n        this._disposers.push(navigationBar);\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\r\n   * (Re)validates chart's data.\r\n   *\r\n   * @ignore Exclude from docs\r\n   */\n\n  TreeMap.prototype.validateData = function () {\n    this.series.clear();\n    this._tempSeries = [];\n\n    _super.prototype.validateData.call(this);\n\n    if (this._homeDataItem) {\n      this._homeDataItem.dispose();\n    }\n\n    var homeDataItem = this.dataItems.template.clone(); // cant' use createDataItem here!\n\n    this._homeDataItem = homeDataItem;\n    $iter.each(this.dataItems.iterator(), function (dataItem) {\n      dataItem.parent = homeDataItem;\n    });\n    homeDataItem.children = this.dataItems;\n    homeDataItem.x0 = 0;\n    homeDataItem.y0 = 0;\n    homeDataItem.name = this._homeText;\n    var maxX = 1000;\n    var maxY = Math.round(maxX * this.pixelHeight / this.pixelWidth / 10) * 10 || 1000;\n    homeDataItem.x1 = maxX;\n    homeDataItem.y1 = maxY;\n    this.xAxis.min = 0;\n    this.xAxis.max = maxX;\n    this.xAxis.getMinMax();\n    this.yAxis.min = 0;\n    this.yAxis.max = maxY;\n    this.yAxis.getMinMax();\n    this.layoutItems(homeDataItem);\n    this.createTreeSeries(homeDataItem);\n  };\n  /**\r\n   * Layouts and sizes all items according to their value and\r\n   * `layoutAlgorithm`.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param parent  Parent data item\r\n   */\n\n\n  TreeMap.prototype.layoutItems = function (parent, sorting) {\n    if (parent) {\n      var children = parent.children;\n\n      if (!sorting) {\n        sorting = this.sorting;\n      }\n\n      if (sorting == \"ascending\") {\n        children.values.sort(function (a, b) {\n          return a.value - b.value;\n        });\n      }\n\n      if (sorting == \"descending\") {\n        children.values.sort(function (a, b) {\n          return b.value - a.value;\n        });\n      }\n\n      this._updateDataItemIndexes(0);\n\n      this.layoutAlgorithm(parent);\n\n      for (var i = 0, len = children.length; i < len; i++) {\n        var node = children.getIndex(i);\n\n        if (node.children) {\n          this.layoutItems(node);\n        }\n      }\n    }\n  };\n  /**\r\n   * Creates and returns a new treemap series.\r\n   *\r\n   * @todo Description\r\n   * @param dataItem  Data item to create series out of\r\n   */\n\n\n  TreeMap.prototype.createTreeSeries = function (dataItem) {\n    var _this = this;\n\n    this._tempSeries = [];\n    var navigationData = [dataItem]; // create parent series and navigation data\n\n    var parentDataItem = dataItem.parent;\n\n    while (parentDataItem != undefined) {\n      this.initSeries(parentDataItem);\n      navigationData.push(parentDataItem);\n      parentDataItem = parentDataItem.parent;\n    }\n\n    navigationData.reverse();\n\n    if (this.navigationBar) {\n      this.navigationBar.data = navigationData;\n    } // create series and children series\n\n\n    this.createTreeSeriesReal(dataItem); // add those which are not in the list\n\n    $array.each(this._tempSeries, function (series) {\n      if (_this.series.indexOf(series) == -1) {\n        _this.series.push(series);\n      }\n\n      series.zIndex = series.level;\n    });\n  };\n  /**\r\n   * [createTreeSeriesReal description]\r\n   *\r\n   * @todo Description\r\n   * @param dataItem [description]\r\n   */\n\n\n  TreeMap.prototype.createTreeSeriesReal = function (dataItem) {\n    if (dataItem.children) {\n      var level = dataItem.level;\n\n      if (level < this.currentLevel + this.maxLevels) {\n        this.initSeries(dataItem);\n\n        for (var i = 0; i < dataItem.children.length; i++) {\n          var child = dataItem.children.getIndex(i);\n\n          if (child.children) {\n            this.createTreeSeriesReal(child);\n          }\n        }\n      }\n    }\n  };\n\n  TreeMap.prototype.setData = function (value) {\n    this.currentLevel = 0;\n    this.currentlyZoomed = undefined;\n    this.xAxis.start = 0;\n    this.xAxis.end = 1;\n    this.yAxis.start = 0;\n    this.yAxis.end = 1;\n\n    _super.prototype.setData.call(this, value);\n  };\n  /**\r\n   * @ignore\r\n   * Overriding, as tree map series are created on the fly all the time\r\n   */\n\n\n  TreeMap.prototype.seriesAppeared = function () {\n    return true;\n  };\n  /**\r\n   * Initializes the treemap series.\r\n   *\r\n   * @todo Description\r\n   * @param dataItem  Chart data item\r\n   */\n\n\n  TreeMap.prototype.initSeries = function (dataItem) {\n    var _this = this;\n\n    if (!dataItem.series) {\n      var series = void 0;\n      var template = this.seriesTemplates.getKey(dataItem.level.toString());\n\n      if (template) {\n        series = template.clone();\n      } else {\n        series = this.series.create();\n      } // for the legend to get {value}\n\n\n      series.dataItem.dataContext = dataItem;\n      series.name = dataItem.name;\n      series.parentDataItem = dataItem;\n      dataItem.series = series;\n      var level = dataItem.level;\n      series.level = level;\n      var dataContext = dataItem.dataContext;\n\n      if (dataContext) {\n        series.config = dataContext.config;\n      }\n\n      this.dataUsers.removeValue(series); // series do not use data directly, that's why we remove it\n\n      series.data = dataItem.children.values;\n      series.fill = dataItem.color;\n      series.columnsContainer.hide(0);\n      series.bulletsContainer.hide(0);\n      series.columns.template.adapter.add(\"fill\", function (fill, target) {\n        var dataItem = target.dataItem;\n\n        if (dataItem) {\n          var treeMapDataItem = dataItem.treeMapDataItem;\n\n          if (treeMapDataItem) {\n            target.fill = treeMapDataItem.color;\n            target.adapter.remove(\"fill\"); //@todo: make it possible adapters applied once?\n\n            return treeMapDataItem.color;\n          }\n        }\n      });\n\n      if (this.zoomable && (dataItem.level > this.currentLevel || dataItem.children && dataItem.children.length > 0)) {\n        series.columns.template.cursorOverStyle = MouseCursorStyle.pointer;\n\n        if (this.zoomable) {\n          series.columns.template.events.on(\"hit\", function (event) {\n            var seriesDataItem = event.target.dataItem;\n\n            if (dataItem.level > _this.currentLevel) {\n              _this.zoomToChartDataItem(seriesDataItem.treeMapDataItem.parent);\n            } else {\n              _this.zoomToSeriesDataItem(seriesDataItem);\n            }\n          }, this, undefined);\n        }\n      }\n    }\n\n    this._tempSeries.push(dataItem.series);\n  };\n  /**\r\n   * Toggles bullets so that labels that belong to current drill level are\r\n   * shown.\r\n   *\r\n   * @param duration  Animation duration (ms)\r\n   */\n\n\n  TreeMap.prototype.toggleBullets = function (duration) {\n    var _this = this; // hide all series which are not in tempSeries\n\n\n    $iter.each(this.series.iterator(), function (series) {\n      if (_this._tempSeries.indexOf(series) == -1) {\n        //series.hideReal(duration);\n        series.columnsContainer.hide();\n        series.bulletsContainer.hide(duration);\n      } else {\n        //series.showReal(duration);\n        series.columnsContainer.show();\n        series.bulletsContainer.show(duration);\n        series.dataItems.each(function (dataItem) {\n          dataItem.bullets.each(function (key, bullet) {\n            bullet.show();\n          });\n        });\n\n        if (series.level < _this.currentLevel) {\n          if (_this.hideParentColumns) {\n            series.columnsContainer.hide();\n          }\n\n          series.bulletsContainer.hide(duration);\n        } else if (series.level == _this.currentLevel) {\n          if (_this.maxLevels > 1) {\n            series.dataItems.each(function (dataItem) {\n              if (dataItem.treeMapDataItem.children) {\n                dataItem.bullets.each(function (key, bullet) {\n                  bullet.hide();\n                });\n              }\n            });\n          }\n        }\n      }\n    });\n  };\n  /**\r\n   * Zooms to particular item in series.\r\n   *\r\n   * @param dataItem  Data item\r\n   */\n\n\n  TreeMap.prototype.zoomToSeriesDataItem = function (dataItem) {\n    this.zoomToChartDataItem(dataItem.treeMapDataItem);\n  };\n  /**\r\n   * Zooms to particular item.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param dataItem  Data item\r\n   */\n\n\n  TreeMap.prototype.zoomToChartDataItem = function (dataItem) {\n    var _this = this;\n\n    var zoomOutButton = this.zoomOutButton; // this is needed because if there is only one fist level, it wont' be shown\n\n    if (zoomOutButton) {\n      if (dataItem != this._homeDataItem) {\n        zoomOutButton.show();\n      } else {\n        zoomOutButton.hide();\n      }\n    }\n\n    if (dataItem && dataItem.children) {\n      this.xAxis.zoomToValues(dataItem.x0, dataItem.x1);\n      this.yAxis.zoomToValues(dataItem.y0, dataItem.y1);\n      this.currentLevel = dataItem.level;\n      this.currentlyZoomed = dataItem;\n      this.createTreeSeries(dataItem);\n      var rangeChangeAnimation = this.xAxis.rangeChangeAnimation || this.yAxis.rangeChangeAnimation;\n\n      if (rangeChangeAnimation && !rangeChangeAnimation.isDisposed() && !rangeChangeAnimation.isFinished()) {\n        this._dataDisposers.push(rangeChangeAnimation);\n\n        rangeChangeAnimation.events.once(\"animationended\", function () {\n          _this.toggleBullets();\n        });\n      } else {\n        this.toggleBullets();\n      }\n    }\n  };\n  /**\r\n   * Sets defaults that instantiate some objects that rely on parent, so they\r\n   * cannot be set in constructor.\r\n   */\n\n\n  TreeMap.prototype.applyInternalDefaults = function () {\n    _super.prototype.applyInternalDefaults.call(this); // Add a default screen reader title for accessibility\n    // This will be overridden in screen reader if there are any `titles` set\n\n\n    if (!$type.hasValue(this.readerTitle)) {\n      this.readerTitle = this.language.translate(\"TreeMap chart\");\n    } //this.homeText = this.language.translate(\"Home\");\n\n  };\n  /**\r\n   * Returns a new/empty DataItem of the type appropriate for this object.\r\n   *\r\n   * @see {@link DataItem}\r\n   * @return Data Item\r\n   */\n\n\n  TreeMap.prototype.createDataItem = function () {\n    return new TreeMapDataItem();\n  };\n\n  Object.defineProperty(TreeMap.prototype, \"maxLevels\", {\n    /**\r\n     * @return Maximum drill-down level\r\n     */\n    get: function () {\n      return this.getPropertyValue(\"maxLevels\");\n    },\n\n    /**\r\n     * Maximum number of levels the chart will display initially.\r\n     *\r\n     * @default 2\r\n     * @param value  Maximum drill-down level\r\n     */\n    set: function (value) {\n      this.setPropertyValue(\"maxLevels\", value, true);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(TreeMap.prototype, \"currentLevel\", {\n    /**\r\n     * @return Current level\r\n     */\n    get: function () {\n      return this.getPropertyValue(\"currentLevel\");\n    },\n\n    /**\r\n     * Current drill-down level the chart is at.\r\n     *\r\n     * @param value  Current level\r\n     */\n    set: function (value) {\n      this.setPropertyValue(\"currentLevel\", value, true);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(TreeMap.prototype, \"hideParentColumns\", {\n    /**\r\n     * @return Hide?\r\n     */\n    get: function () {\n      return this.getPropertyValue(\"hideParentColumns\");\n    },\n\n    /**\r\n     * If set to `true`, columns of parent nodes will be hidden when user\r\n     * drills-down into deeper levels.\r\n     *\r\n     * @sice 4.7.4\r\n     * @default false\r\n     * @param  value  Hide?\r\n     */\n    set: function (value) {\n      this.setPropertyValue(\"hideParentColumns\", value);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(TreeMap.prototype, \"sorting\", {\n    get: function () {\n      return this.getPropertyValue(\"sorting\");\n    },\n\n    /**\r\n     * Sorting direction of treemap items.\r\n     *\r\n     * Available options: \"none\", \"ascending\", and \"descending\" (default).\r\n     *\r\n     * @default \"descending\"\r\n     * @param value [description]\r\n     */\n    set: function (value) {\n      this.setPropertyValue(\"sorting\", value, true);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\r\n   * Creates and returns a new series of the suitable type.\r\n   *\r\n   * @return new series\r\n   */\n\n  TreeMap.prototype.createSeries = function () {\n    return new TreeMapSeries();\n  };\n\n  Object.defineProperty(TreeMap.prototype, \"homeText\", {\n    /**\r\n     * @return Home text\r\n     */\n    get: function () {\n      return this._homeText;\n    },\n\n    /**\r\n     * A text displayed on the \"home\" button which is used to go back to level 0\r\n     * after drill into sub-items.\r\n     *\r\n     * @param value  Home text\r\n     */\n    set: function (value) {\n      this._homeText = value;\n\n      if (this._homeDataItem) {\n        this._homeDataItem.name = this._homeText;\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\r\n   * Processes JSON-based config before it is applied to the object.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param config  Config\r\n   */\n\n  TreeMap.prototype.processConfig = function (config) {\n    if (config) {\n      // Instantiate layout algorithm\n      if ($type.hasValue(config[\"layoutAlgorithm\"]) && $type.isString(config[\"layoutAlgorithm\"])) {\n        switch (config[\"layoutAlgorithm\"]) {\n          case \"squarify\":\n            config[\"layoutAlgorithm\"] = this.squarify;\n            break;\n\n          case \"binaryTree\":\n            config[\"layoutAlgorithm\"] = this.binaryTree;\n            break;\n\n          case \"slice\":\n            config[\"layoutAlgorithm\"] = this.slice;\n            break;\n\n          case \"dice\":\n            config[\"layoutAlgorithm\"] = this.dice;\n            break;\n\n          case \"sliceDice\":\n            config[\"layoutAlgorithm\"] = this.sliceDice;\n            break;\n\n          default:\n            delete config[\"layoutAlgorithm\"];\n            break;\n        }\n      } // Set type for navigation bar\n\n\n      if ($type.hasValue(config.navigationBar) && !$type.hasValue(config.navigationBar.type)) {\n        config.navigationBar.type = \"NavigationBar\";\n      }\n\n      _super.prototype.processConfig.call(this, config);\n    }\n  };\n  /**\r\n   * Measures the size of container and informs its children of how much size\r\n   * they can occupy, by setting their relative `maxWidth` and `maxHeight`\r\n   * properties.\r\n   *\r\n   * @ignore Exclude from docs\r\n   */\n\n\n  TreeMap.prototype.validateLayout = function () {\n    _super.prototype.validateLayout.call(this);\n\n    this.layoutItems(this.currentlyZoomed);\n  };\n  /**\r\n   * Validates (processes) data items.\r\n   *\r\n   * @ignore Exclude from docs\r\n   */\n\n\n  TreeMap.prototype.validateDataItems = function () {\n    _super.prototype.validateDataItems.call(this);\n\n    this.layoutItems(this._homeDataItem);\n    $iter.each(this.series.iterator(), function (series) {\n      series.validateRawData();\n    });\n    this.zoomToChartDataItem(this._homeDataItem);\n  };\n  /**\r\n   * ==========================================================================\r\n   * TREEMAP LAYOUT FUNCTIONS\r\n   * ==========================================================================\r\n   * @hidden\r\n   */\n\n  /**\r\n   * The functions below are from D3.js library (https://d3js.org/)\r\n   *\r\n   * --------------------------------------------------------------------------\r\n   * Copyright 2017 Mike Bostock\r\n   *\r\n   * Redistribution and use in source and binary forms, with or without\r\n   * modification, are permitted provided that the following conditions are met:\r\n   *\r\n   * 1. Redistributions of source code must retain the above copyright notice,\r\n   *    this list of conditions and the following disclaimer.\r\n   *\r\n   * 2. Redistributions in binary form must reproduce the above copyright\r\n   *    notice,this list of conditions and the following disclaimer in the\r\n   *    documentation and/or other materials provided with the distribution.\r\n   *\r\n   * 3. Neither the name of the copyright holder nor the names of its\r\n   *    contributors may be used to endorse or promote products derived from\r\n   *    this software without specific prior written permission.\r\n   *\r\n   * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\r\n   * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\r\n   * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\r\n   * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\r\n   * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\r\n   * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\r\n   * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\r\n   * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\r\n   * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\r\n   * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\r\n   * POSSIBILITY OF SUCH DAMAGE.\r\n   * --------------------------------------------------------------------------\r\n   * @hidden\r\n   */\n\n  /**\r\n   * Treemap layout algorithm: binaryTree.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param parent  Data item\r\n   */\n\n\n  TreeMap.prototype.binaryTree = function (parent) {\n    var nodes = parent.children,\n        i,\n        n = nodes.length,\n        sum,\n        sums = new Array(n + 1);\n\n    for (sums[0] = sum = i = 0; i < n; ++i) {\n      sums[i + 1] = sum += nodes.getIndex(i).value;\n    }\n\n    partition(0, n, parent.value, parent.x0, parent.y0, parent.x1, parent.y1);\n\n    function partition(i, j, value, x0, y0, x1, y1) {\n      if (i >= j - 1) {\n        var node = nodes.getIndex(i);\n        node.x0 = x0;\n        node.y0 = y0;\n        node.x1 = x1;\n        node.y1 = y1;\n        return;\n      }\n\n      var valueOffset = sums[i],\n          valueTarget = value / 2 + valueOffset,\n          k = i + 1,\n          hi = j - 1;\n\n      while (k < hi) {\n        var mid = k + hi >>> 1;\n\n        if (sums[mid] < valueTarget) {\n          k = mid + 1;\n        } else {\n          hi = mid;\n        }\n      }\n\n      if (valueTarget - sums[k - 1] < sums[k] - valueTarget && i + 1 < k) {\n        --k;\n      }\n\n      var valueLeft = sums[k] - valueOffset,\n          valueRight = value - valueLeft;\n\n      if (x1 - x0 > y1 - y0) {\n        var xk = (x0 * valueRight + x1 * valueLeft) / value;\n        partition(i, k, valueLeft, x0, y0, xk, y1);\n        partition(k, j, valueRight, xk, y0, x1, y1);\n      } else {\n        var yk = (y0 * valueRight + y1 * valueLeft) / value;\n        partition(i, k, valueLeft, x0, y0, x1, yk);\n        partition(k, j, valueRight, x0, yk, x1, y1);\n      }\n    }\n  };\n  /**\r\n   * Treemap layout algorithm: slice.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param parent  Data item\r\n   */\n\n\n  TreeMap.prototype.slice = function (parent) {\n    var x0 = parent.x0;\n    var x1 = parent.x1;\n    var y0 = parent.y0;\n    var y1 = parent.y1;\n    var nodes = parent.children;\n    var node;\n    var i = -1;\n    var n = nodes.length;\n    var k = parent.value && (y1 - y0) / parent.value;\n\n    while (++i < n) {\n      node = nodes.getIndex(i);\n      node.x0 = x0;\n      node.x1 = x1;\n      node.y0 = y0;\n      y0 += node.value * k;\n      node.y1 = y0;\n    }\n  };\n  /**\r\n   * Treemap layout algorithm: dice.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param parent  Data item\r\n   */\n\n\n  TreeMap.prototype.dice = function (parent) {\n    var x0 = parent.x0;\n    var x1 = parent.x1;\n    var y0 = parent.y0;\n    var y1 = parent.y1;\n    var nodes = parent.children,\n        node,\n        i = -1,\n        n = nodes.length,\n        k = parent.value && (x1 - x0) / parent.value;\n\n    while (++i < n) {\n      node = nodes.getIndex(i);\n      node.y0 = y0;\n      node.y1 = y1;\n      node.x0 = x0;\n      x0 += node.value * k;\n      node.x1 = x0;\n    }\n  };\n  /**\r\n   * Treemap layout algorithm: slideDice.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param parent  Data item\r\n   */\n\n\n  TreeMap.prototype.sliceDice = function (parent) {\n    if (parent.level & 1) {\n      this.slice(parent);\n    } else {\n      this.dice(parent);\n    }\n  };\n  /**\r\n   * Treemap layout algorithm: squarify.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param parent  Data item\r\n   */\n\n\n  TreeMap.prototype.squarify = function (parent) {\n    var ratio = (1 + Math.sqrt(5)) / 2;\n    var x0 = parent.x0;\n    var x1 = parent.x1;\n    var y0 = parent.y0;\n    var y1 = parent.y1;\n    var nodes = parent.children;\n    var nodeValue;\n    var i0 = 0;\n    var i1 = 0;\n    var n = nodes.length;\n    var dx;\n    var dy;\n    var value = parent.value;\n    var sumValue;\n    var minValue;\n    var maxValue;\n    var newRatio;\n    var minRatio;\n    var alpha;\n    var beta;\n\n    while (i0 < n) {\n      dx = x1 - x0;\n      dy = y1 - y0; // Find the next non-empty node.\n\n      do {\n        sumValue = nodes.getIndex(i1++).value;\n      } while (!sumValue && i1 < n);\n\n      minValue = maxValue = sumValue;\n      alpha = Math.max(dy / dx, dx / dy) / (value * ratio);\n      beta = sumValue * sumValue * alpha;\n      minRatio = Math.max(maxValue / beta, beta / minValue); // Keep adding nodes while the aspect ratio maintains or improves.\n\n      for (; i1 < n; ++i1) {\n        sumValue += nodeValue = nodes.getIndex(i1).value;\n\n        if (nodeValue < minValue) {\n          minValue = nodeValue;\n        }\n\n        if (nodeValue > maxValue) {\n          maxValue = nodeValue;\n        }\n\n        beta = sumValue * sumValue * alpha;\n        newRatio = Math.max(maxValue / beta, beta / minValue);\n\n        if (newRatio > minRatio) {\n          sumValue -= nodeValue;\n          break;\n        }\n\n        minRatio = newRatio;\n      } // Position and record the row orientation.\n\n\n      var row = this.dataItems.template.clone();\n      row.value = sumValue;\n      row.dice = dx < dy;\n      row.children = nodes.slice(i0, i1);\n      row.x0 = x0;\n      row.y0 = y0;\n      row.x1 = x1;\n      row.y1 = y1;\n\n      if (row.dice) {\n        row.y1 = value ? y0 += dy * sumValue / value : y1;\n        this.dice(row);\n      } else {\n        row.x1 = value ? x0 += dx * sumValue / value : x1;\n        this.slice(row);\n      }\n\n      value -= sumValue;\n      i0 = i1;\n    }\n  };\n\n  TreeMap.prototype.handleSeriesAdded2 = function () {// void\n  };\n  /**\r\n   * [handleDataItemValueChange description]\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @todo Description\r\n   */\n\n\n  TreeMap.prototype.handleDataItemValueChange = function (dataItem, name) {\n    if (name == \"value\") {\n      this.invalidateDataItems();\n    }\n  };\n\n  TreeMap.prototype.handleDataItemWorkingValueChange = function (dataItem, name) {\n    if (name == \"value\") {\n      this.invalidateDataItems();\n    }\n  };\n\n  TreeMap.prototype.getLegendLevel = function (dataItem) {\n    if (!dataItem) {\n      return;\n    }\n\n    if (!dataItem.children) {\n      return;\n    }\n\n    if (dataItem.children.length > 1) {\n      return dataItem;\n    } else if (dataItem.children.length == 1) {\n      return this.getLegendLevel(dataItem.children.getIndex(0));\n    } else {\n      return dataItem;\n    }\n  };\n  /**\r\n   * Setups the legend to use the chart's data.\r\n   * @ignore\r\n   */\n\n\n  TreeMap.prototype.feedLegend = function () {\n    var legend = this.legend;\n\n    if (legend) {\n      legend.dataFields.name = \"name\";\n      var legendParent = this.getLegendLevel(this._homeDataItem);\n\n      if (legendParent) {\n        var legendData_1 = [];\n        legendParent.children.each(function (dataItem) {\n          //if (!dataItem.hiddenInLegend) {\n          legendData_1.push(dataItem); //}\n        });\n        legend.data = legendData_1;\n      }\n    }\n  };\n  /**\r\n   * @ignore\r\n   */\n\n\n  TreeMap.prototype.disposeData = function () {\n    _super.prototype.disposeData.call(this);\n\n    this._homeDataItem = undefined;\n    this.series.clear();\n\n    if (this.navigationBar) {\n      this.navigationBar.disposeData();\n    }\n\n    this.xAxis.disposeData();\n    this.yAxis.disposeData();\n  };\n  /**\r\n   * Since this chart uses hierarchical data, we need to remove childrent\r\n   * dataField from export of non-hierarchical formats such as CSV and XSLX.\r\n   *\r\n   * @return Export\r\n   */\n\n\n  TreeMap.prototype.getExporting = function () {\n    var _this = this;\n\n    var exporting = _super.prototype.getExporting.call(this);\n\n    exporting.adapter.add(\"formatDataFields\", function (info) {\n      if (info.format == \"csv\" || info.format == \"xlsx\") {\n        if ($type.hasValue(_this.dataFields.children)) {\n          delete info.dataFields[_this.dataFields.children];\n        }\n      }\n\n      return info;\n    });\n    return exporting;\n  };\n\n  return TreeMap;\n}(XYChart);\n\nexport { TreeMap };\n/**\r\n * Register class, so that it can be instantiated using its name from\r\n * anywhere.\r\n *\r\n * @ignore\r\n */\n\nregistry.registeredClasses[\"TreeMap\"] = TreeMap;","map":null,"metadata":{},"sourceType":"module"}