{"ast":null,"code":"import * as tslib_1 from \"tslib\";\n/**\r\n * ============================================================================\r\n * IMPORTS\r\n * ============================================================================\r\n * @hidden\r\n */\n\nimport { dataLoader } from \"./DataLoader\";\nimport { JSONParser } from \"./JSONParser\";\nimport { CSVParser } from \"./CSVParser\";\nimport { BaseObjectEvents } from \"../Base\";\nimport { Adapter } from \"../utils/Adapter\";\nimport { Language } from \"../utils/Language\";\nimport { DateFormatter } from \"../formatters/DateFormatter\";\nimport { registry } from \"../Registry\";\nimport * as $type from \"../utils/Type\";\nimport * as $object from \"../utils/Object\";\n;\n;\n/**\r\n * ============================================================================\r\n * MAIN CLASS\r\n * ============================================================================\r\n * @hidden\r\n */\n\n/**\r\n * Represents a single data source - external file with all of its settings,\r\n * such as format, data parsing, etc.\r\n *\r\n * ```TypeScript\r\n * chart.dataSource.url = \"http://www.myweb.com/data.json\";\r\n * chart.dataSource.parser = am4core.JSONParser;\r\n * ```\r\n * ```JavaScript\r\n * chart.dataSource.url = \"http://www.myweb.com/data.json\";\r\n * chart.dataSource.parser = am4core.JSONParser;\r\n * ```\r\n * ```JSON\r\n * {\r\n *   // ...\r\n *   \"dataSource\": {\r\n *     \"url\": \"http://www.myweb.com/data.json\",\r\n *     \"parser\": \"JSONParser\"\r\n *   },\r\n *   // ...\r\n * }\r\n * ```\r\n *\r\n * @see {@link IDataSourceEvents} for a list of available events\r\n * @see {@link IDataSourceAdapters} for a list of available Adapters\r\n */\n\nvar DataSource =\n/** @class */\nfunction (_super) {\n  tslib_1.__extends(DataSource, _super);\n  /**\r\n   * Constructor\r\n   */\n\n\n  function DataSource(url, parser) {\n    var _this = // Init\n    _super.call(this) || this;\n    /**\r\n     * Adapter.\r\n     */\n\n\n    _this.adapter = new Adapter(_this);\n    /**\r\n     * Custom options for HTTP(S) request.\r\n     */\n\n    _this._requestOptions = {};\n    /**\r\n     * If set to `true`, any subsequent data loads will be considered incremental\r\n     * (containing only new data points that are supposed to be added to existing\r\n     * data).\r\n     *\r\n     * NOTE: this setting works only with element's `data` property. It won't\r\n     * work with any other externally-loadable data property.\r\n     *\r\n     * @default false\r\n     */\n\n    _this._incremental = false;\n    /**\r\n     * A collection of key/value pairs to attach to a data source URL when making\r\n     * an incremental request.\r\n     */\n\n    _this._incrementalParams = {};\n    /**\r\n     * This setting is used only when `incremental = true`. If set to `true`,\r\n     * it will try to retain the same number of data items across each load.\r\n     *\r\n     * E.g. if incremental load yeilded 5 new records, then 5 items from the\r\n     * beginning of data will be removed so that we end up with the same number\r\n     * of data items.\r\n     *\r\n     * @default false\r\n     */\n\n    _this._keepCount = false;\n    /**\r\n     * If set to `true`, each subsequent load will be treated as an update to\r\n     * currently loaded data, meaning that it will try to update values on\r\n     * existing data items, not overwrite the whole data.\r\n     *\r\n     * This will work faster than complete update, and also will animate the\r\n     * values to their new positions.\r\n     *\r\n     * Data sources across loads must contain the same number of data items.\r\n     *\r\n     * Loader will not truncate the data set if loaded data has fewer data items,\r\n     * and if it is longer, the excess data items will be ignored.\r\n     *\r\n     * @default false\r\n     * @since 4.5.5\r\n     */\n\n    _this._updateCurrentData = false;\n    /**\r\n     * Will show loading indicator when loading files.\r\n     */\n\n    _this.showPreloader = true;\n    _this.className = \"DataSource\"; // Set defaults\n\n    if (url) {\n      _this.url = url;\n    } // Set parser\n\n\n    if (parser) {\n      if (typeof parser == \"string\") {\n        _this.parser = dataLoader.getParserByType(parser);\n      } else {\n        _this.parser = parser;\n      }\n    }\n\n    return _this;\n  }\n  /**\r\n   * Processes the loaded data.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param data         Raw (unparsed) data\r\n   * @param contentType  Content type of the loaded data (optional)\r\n   */\n\n\n  DataSource.prototype.processData = function (data, contentType) {\n    // Parsing started\n    this.dispatchImmediately(\"parsestarted\"); // Check if parser is set\n\n    if (!this.parser) {\n      // Try to resolve from data\n      this.parser = dataLoader.getParserByData(data, contentType);\n\n      if (!this.parser) {\n        // We have a problem - nobody knows what to do with the data\n        // Raise error\n        if (this.events.isEnabled(\"parseerror\")) {\n          var event_1 = {\n            type: \"parseerror\",\n            message: this.language.translate(\"No parser available for file: %1\", null, this.url),\n            target: this\n          };\n          this.events.dispatchImmediately(\"parseerror\", event_1);\n        }\n\n        this.dispatchImmediately(\"parseended\");\n        return;\n      }\n    } // Apply options adapters\n\n\n    this.parser.options = this.adapter.apply(\"parserOptions\", this.parser.options);\n    this.parser.options.dateFields = this.adapter.apply(\"dateFields\", this.parser.options.dateFields || []);\n    this.parser.options.numberFields = this.adapter.apply(\"numberFields\", this.parser.options.numberFields || []); // Check if we need to pass in date formatter\n\n    if (this.parser.options.dateFields && !this.parser.options.dateFormatter) {\n      this.parser.options.dateFormatter = this.dateFormatter;\n    } // Parse\n\n\n    this.data = this.adapter.apply(\"parsedData\", this.parser.parse(this.adapter.apply(\"unparsedData\", data))); // Check for parsing errors\n\n    if (!$type.hasValue(this.data) && this.events.isEnabled(\"parseerror\")) {\n      var event_2 = {\n        type: \"parseerror\",\n        message: this.language.translate(\"Error parsing file: %1\", null, this.url),\n        target: this\n      };\n      this.events.dispatchImmediately(\"parseerror\", event_2);\n    } // Wrap up\n\n\n    this.dispatchImmediately(\"parseended\");\n\n    if ($type.hasValue(this.data)) {\n      this.dispatchImmediately(\"done\", {\n        \"data\": this.data\n      });\n    } // The component is responsible for updating its own data vtriggered via\n    // events.\n    // Update last data load\n\n\n    this.lastLoad = new Date();\n  };\n\n  Object.defineProperty(DataSource.prototype, \"url\", {\n    /**\r\n     * @return URL\r\n     */\n    get: function () {\n      // Get URL\n      var url = this.disableCache ? this.timestampUrl(this._url) : this._url; // Add incremental params\n\n      if (this.incremental && this.component.data.length) {\n        url = this.addUrlParams(url, this.incrementalParams);\n      }\n\n      return this.adapter.apply(\"url\", url);\n    },\n\n    /**\r\n     * URL of the data source.\r\n     *\r\n     * @param value  URL\r\n     */\n    set: function (value) {\n      this._url = value;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(DataSource.prototype, \"requestOptions\", {\n    /**\r\n     * @return Options\r\n     */\n    get: function () {\n      return this.adapter.apply(\"requestOptions\", this._requestOptions);\n    },\n\n    /**\r\n     * Custom options for HTTP(S) request.\r\n     *\r\n     * At this moment the only option supported is: `requestHeaders`, which holds\r\n     * an array of objects for custom request headers, e.g.:\r\n     *\r\n     * ```TypeScript\r\n     * chart.dataSource.requestOptions.requestHeaders = [{\r\n     *   \"key\": \"x-access-token\",\r\n     *   \"value\": \"123456789\"\r\n     * }];\r\n     * ``````JavaScript\r\n     * chart.dataSource.requestOptions.requestHeaders = [{\r\n     *   \"key\": \"x-access-token\",\r\n     *   \"value\": \"123456789\"\r\n     * }];\r\n     * ```\r\n     * ```JSON\r\n     * {\r\n     *   // ...\r\n     *   \"dataSource\": {\r\n     *     // ...\r\n     *     \"requestOptions\": {\r\n     *       \"requestHeaders\": [{\r\n     *         \"key\": \"x-access-token\",\r\n     *         \"value\": \"123456789\"\r\n     *       }]\r\n     *     }\r\n     *   }\r\n     * }\r\n     * ```\r\n     *\r\n     * NOTE: setting this options on an-already loaded DataSource will not\r\n     * trigger a reload.\r\n     *\r\n     * @param value  Options\r\n     */\n    set: function (value) {\n      this._requestOptions = value;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(DataSource.prototype, \"parser\", {\n    /**\r\n     * @return Data parser\r\n     */\n    get: function () {\n      if (!this._parser) {\n        this._parser = new JSONParser();\n      }\n\n      return this.adapter.apply(\"parser\", this._parser);\n    },\n\n    /**\r\n     * A parser to be used to parse data.\r\n     *\r\n     * ```TypeScript\r\n     * chart.dataSource.url = \"http://www.myweb.com/data.json\";\r\n     * chart.dataSource.parser = am4core.JSONParser;\r\n     * ```\r\n     * ```JavaScript\r\n     * chart.dataSource.url = \"http://www.myweb.com/data.json\";\r\n     * chart.dataSource.parser = am4core.JSONParser;\r\n     * ```\r\n     * ```JSON\r\n     * {\r\n     *   // ...\r\n     *   \"dataSource\": {\r\n     *     \"url\": \"http://www.myweb.com/data.json\",\r\n     *     \"parser\": \"JSONParser\"\r\n     *   },\r\n     *   // ...\r\n     * }\r\n     * ```\r\n     *\r\n     * @default JSONParser\r\n     * @param value  Data parser\r\n     */\n    set: function (value) {\n      this._parser = value;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(DataSource.prototype, \"reloadFrequency\", {\n    /**\r\n     * @return Reload frequency (ms)\r\n     */\n    get: function () {\n      return this.adapter.apply(\"reloadTimeout\", this._reloadFrequency);\n    },\n\n    /**\r\n     * Data source reload frequency.\r\n     *\r\n     * If set, it will reload the same URL every X milliseconds.\r\n     *\r\n     * @param value Reload frequency (ms)\r\n     */\n    set: function (value) {\n      var _this = this;\n\n      if (this._reloadFrequency != value) {\n        this._reloadFrequency = value; // Should we schedule a reload?\n\n        if (value) {\n          if (!$type.hasValue(this._reloadDisposer)) {\n            this._reloadDisposer = this.events.on(\"ended\", function (ev) {\n              _this._reloadTimeout = setTimeout(function () {\n                _this.load();\n              }, _this.reloadFrequency);\n            });\n          }\n        } else if ($type.hasValue(this._reloadDisposer)) {\n          this._reloadDisposer.dispose();\n\n          this._reloadDisposer = undefined;\n        }\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(DataSource.prototype, \"incremental\", {\n    /**\r\n     * @return Incremental load?\r\n     */\n    get: function () {\n      return this.adapter.apply(\"incremental\", this._incremental);\n    },\n\n    /**\r\n     * Should subsequent reloads be treated as incremental?\r\n     *\r\n     * Incremental loads will assume that they contain only new data items\r\n     * since the last load.\r\n     *\r\n     * If `incremental = false` the loader will replace all of the target's\r\n     * data with each load.\r\n     *\r\n     * This setting does not have any effect trhe first time data is loaded.\r\n     *\r\n     * NOTE: this setting works only with element's `data` property. It won't\r\n     * work with any other externally-loadable data property.\r\n     *\r\n     * @default false\r\n     * @param Incremental load?\r\n     */\n    set: function (value) {\n      this._incremental = value;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(DataSource.prototype, \"incrementalParams\", {\n    /**\r\n     * @return Incremental request parameters\r\n     */\n    get: function () {\n      return this.adapter.apply(\"incrementalParams\", this._incrementalParams);\n    },\n\n    /**\r\n     * An object consisting of key/value pairs to apply to an URL when data\r\n     * source is making an incremental request.\r\n     *\r\n     * @param value  Incremental request parameters\r\n     */\n    set: function (value) {\n      this._incrementalParams = value;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(DataSource.prototype, \"keepCount\", {\n    /**\r\n     * @return keepCount load?\r\n     */\n    get: function () {\n      return this.adapter.apply(\"keepCount\", this._keepCount);\n    },\n\n    /**\r\n     * This setting is used only when `incremental = true`. If set to `true`,\r\n     * it will try to retain the same number of data items across each load.\r\n     *\r\n     * E.g. if incremental load yeilded 5 new records, then 5 items from the\r\n     * beginning of data will be removed so that we end up with the same number\r\n     * of data items.\r\n     *\r\n     * @default false\r\n     * @param Keep record count?\r\n     */\n    set: function (value) {\n      this._keepCount = value;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(DataSource.prototype, \"updateCurrentData\", {\n    /**\r\n     * @return Update current data?\r\n     */\n    get: function () {\n      return this.adapter.apply(\"updateCurrentData\", this._updateCurrentData);\n    },\n\n    /**\r\n     * If set to `true`, each subsequent load will be treated as an update to\r\n     * currently loaded data, meaning that it will try to update values on\r\n     * existing data items, not overwrite the whole data.\r\n     *\r\n     * This will work faster than complete update, and also will animate the\r\n     * values to their new positions.\r\n     *\r\n     * Data sources across loads must contain the same number of data items.\r\n     *\r\n     * Loader will not truncate the data set if loaded data has fewer data items,\r\n     * and if it is longer, the excess data items will be ignored.\r\n     *\r\n     * NOTE: this setting is ignored if `incremental = true`.\r\n     *\r\n     * @default false\r\n     * @since 2.5.5\r\n     * @param Update current data?\r\n     */\n    set: function (value) {\n      this._updateCurrentData = value;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(DataSource.prototype, \"language\", {\n    /**\r\n     * @return A [[Language]] instance to be used\r\n     */\n    get: function () {\n      if (this._language) {\n        return this._language;\n      } else if (this.component) {\n        this._language = this.component.language;\n        return this._language;\n      }\n\n      this.language = new Language();\n      return this.language;\n    },\n\n    /**\r\n     * Language instance to use.\r\n     *\r\n     * Will inherit and use chart's language, if not set.\r\n     *\r\n     * @param value An instance of Language\r\n     */\n    set: function (value) {\n      this._language = value;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(DataSource.prototype, \"dateFormatter\", {\n    /**\r\n     * @return A [[DateFormatter]] instance to be used\r\n     */\n    get: function () {\n      if (this._dateFormatter) {\n        return this._dateFormatter;\n      } else if (this.component) {\n        this._dateFormatter = this.component.dateFormatter;\n        return this._dateFormatter;\n      }\n\n      this.dateFormatter = new DateFormatter();\n      return this.dateFormatter;\n    },\n\n    /**\r\n     * A [[DateFormatter]] to use when parsing dates from string formats.\r\n     *\r\n     * Will inherit and use chart's DateFormatter if not ser.\r\n     *\r\n     * @param value An instance of [[DateFormatter]]\r\n     */\n    set: function (value) {\n      this._dateFormatter = value;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\r\n   * Adds current timestamp to the URL.\r\n   *\r\n   * @param url  Source URL\r\n   * @return Timestamped URL\r\n   */\n\n  DataSource.prototype.timestampUrl = function (url) {\n    var tstamp = new Date().getTime().toString();\n    var params = {};\n    params[tstamp] = \"\";\n    return this.addUrlParams(url, params);\n  };\n  /**\r\n   * Disposes of this object.\r\n   */\n\n\n  DataSource.prototype.dispose = function () {\n    _super.prototype.dispose.call(this);\n\n    if (this._reloadTimeout) {\n      clearTimeout(this._reloadTimeout);\n    }\n\n    if ($type.hasValue(this._reloadDisposer)) {\n      this._reloadDisposer.dispose();\n\n      this._reloadDisposer = undefined;\n    }\n  };\n  /**\r\n   * Initiate the load.\r\n   *\r\n   * All loading in JavaScript is asynchronous. This function will trigger the\r\n   * load and will exit immediately.\r\n   *\r\n   * Use DataSource's events to watch for loaded data and errors.\r\n   */\n\n\n  DataSource.prototype.load = function () {\n    if (this.url) {\n      if (this._reloadTimeout) {\n        clearTimeout(this._reloadTimeout);\n      }\n\n      dataLoader.load(this);\n    }\n  };\n  /**\r\n   * Adds parameters to `url` as query strings. Will take care of proper\r\n   * separators.\r\n   *\r\n   * @param url     Source URL\r\n   * @param params  Parameters\r\n   * @return New URL\r\n   */\n\n\n  DataSource.prototype.addUrlParams = function (url, params) {\n    var join = url.match(/\\?/) ? \"&\" : \"?\";\n    var add = [];\n    $object.each(params, function (key, value) {\n      if (value != \"\") {\n        add.push(key + \"=\" + encodeURIComponent(value));\n      } else {\n        add.push(key);\n      }\n    });\n\n    if (add.length) {\n      return url + join + add.join(\"&\");\n    }\n\n    return url;\n  };\n  /**\r\n   * Processes JSON-based config before it is applied to the object.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param config  Config\r\n   */\n\n\n  DataSource.prototype.processConfig = function (config) {\n    registry.registeredClasses[\"json\"] = JSONParser;\n    registry.registeredClasses[\"JSONParser\"] = JSONParser;\n    registry.registeredClasses[\"csv\"] = CSVParser;\n    registry.registeredClasses[\"CSVParser\"] = CSVParser;\n\n    _super.prototype.processConfig.call(this, config);\n  };\n\n  return DataSource;\n}(BaseObjectEvents);\n\nexport { DataSource };","map":null,"metadata":{},"sourceType":"module"}