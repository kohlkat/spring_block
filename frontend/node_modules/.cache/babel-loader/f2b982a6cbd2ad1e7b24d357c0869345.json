{"ast":null,"code":"/**\r\n * Pattern module.\r\n */\nimport * as tslib_1 from \"tslib\";\n/**\r\n * ============================================================================\r\n * IMPORTS\r\n * ============================================================================\r\n * @hidden\r\n */\n\nimport { BaseObject } from \"../../Base\";\nimport { getGhostPaper } from \"../Paper\";\nimport { List, ListDisposer } from \"../../utils/List\";\nimport { Animation, AnimationDisposer } from \"../../utils/Animation\";\nimport { registry } from \"../../Registry\";\nimport { InterfaceColorSet } from \"../../utils/InterfaceColorSet\";\nimport * as $iter from \"../../utils/Iterator\";\nimport * as $object from \"../../utils/Object\";\nimport * as $type from \"../../utils/Type\";\n;\n/**\r\n * ============================================================================\r\n * MAIN CLASS\r\n * ============================================================================\r\n * @hidden\r\n */\n\n/**\r\n * Base class to define patterns.\r\n */\n\nvar Pattern =\n/** @class */\nfunction (_super) {\n  tslib_1.__extends(Pattern, _super); //public propertyValues = new Dictionary<PatternProperties, any>();\n\n  /**\r\n   * Constructor\r\n   */\n\n\n  function Pattern() {\n    var _this = // Init\n    _super.call(this) || this;\n    /**\r\n     * List of elements the pattern consists of.\r\n     */\n\n\n    _this._elements = new List();\n    /**\r\n     * A storage for Filter property/value pairs.\r\n     *\r\n     * @ignore Exclude from docs\r\n     * @see {@link PatternProperties}\r\n     */\n\n    _this.properties = {};\n    _this.className = \"Pattern\"; // Set defaults\n\n    _this.width = 10;\n    _this.height = 10;\n    _this.x = 0;\n    _this.y = 0;\n    _this.patternUnits = \"userSpaceOnUse\";\n    var interfaceColors = new InterfaceColorSet();\n    _this.backgroundFill = interfaceColors.getFor(\"background\");\n    _this.backgroundOpacity = 0;\n    _this.fillOpacity = 1;\n    _this.fill = interfaceColors.getFor(\"alternativeBackground\");\n    _this.stroke = interfaceColors.getFor(\"alternativeBackground\");\n    _this.strokeOpacity = 1;\n    _this.strokeWidth = 1;\n    _this.shapeRendering = \"crispEdges\";\n    _this.rotation = 0; // Create main group to store pattern elements inelements\n\n    _this.element = _this.paper.addGroup(\"pattern\");\n    _this.id = \"pattern-\" + registry.getUniqueId();\n\n    _this.element.attr({\n      \"id\": _this.id\n    });\n\n    _this._disposers.push(_this.element); // Make elements disposable\n\n\n    _this._disposers.push(new ListDisposer(_this._elements)); // Request again to trigger getter/setter code\n\n\n    _this.patternUnits = _this.patternUnits;\n    _this.width = _this.width;\n    _this.height = _this.height; // Apply theme\n\n    _this.applyTheme();\n\n    return _this;\n  }\n  /**\r\n   * Draws the pattern.\r\n   */\n\n\n  Pattern.prototype.draw = function () {\n    var _this = this;\n\n    var patternElement = this.element;\n\n    if (patternElement) {\n      patternElement.removeChildNodes();\n      var background = this.paper.add(\"rect\");\n      background.attr({\n        \"width\": this.width,\n        \"height\": this.height,\n        \"shape-rendering\": \"crispEdges\",\n        \"fill\": this.backgroundFill.hex,\n        \"fill-opacity\": this.backgroundOpacity,\n        \"stroke\": this.backgroundFill.hex,\n        \"stroke-opacity\": this.backgroundOpacity\n      });\n      patternElement.add(background);\n      patternElement.attr({\n        \"x\": this.x,\n        \"y\": this.y,\n        \"width\": this.width,\n        \"height\": this.height,\n        \"stroke\": this.stroke.hex,\n        \"fill\": this.fill.hex,\n        \"fill-opacity\": this.fillOpacity,\n        \"stroke-opacity\": this.strokeOpacity,\n        \"stroke-width\": this.strokeWidth,\n        \"shape-rendering\": this.shapeRendering,\n        \"patternUnits\": this.patternUnits,\n        \"stroke-dasharray\": this.strokeDasharray\n      });\n      $iter.each(this._elements.iterator(), function (element) {\n        element.rotation = _this.rotation;\n        element.rotationX = _this.properties[\"rotationX\"];\n        element.rotationY = _this.properties[\"rotationY\"];\n\n        _this.element.add(element);\n      });\n    }\n  };\n  /**\r\n   * Animate pattern properties.\r\n   *\r\n   * @see {@link Animation}\r\n   * @param animationOptions  Animation options\r\n   * @param duration          Duration (ms)\r\n   * @param easing            Easing function\r\n   * @return Animation instance\r\n   */\n\n\n  Pattern.prototype.animate = function (animationOptions, duration, easing) {\n    return new Animation(this, animationOptions, duration, easing).start();\n  };\n  /**\r\n   * Adds an element to the pattern.\r\n   *\r\n   * @param element  Element\r\n   */\n\n\n  Pattern.prototype.addElement = function (element) {\n    this._elements.push(element);\n\n    this._disposers.push(element);\n  };\n  /**\r\n   * Remove an element from the pattern.\r\n   *\r\n   * @param element  Element\r\n   */\n\n\n  Pattern.prototype.removeElement = function (element) {\n    this._elements.removeValue(element);\n\n    this.removeDispose(element);\n  };\n\n  Object.defineProperty(Pattern.prototype, \"elements\", {\n    /**\r\n     * Returns the list of SVG elements comprising the pattern.\r\n     *\r\n     * @return Pattern elements\r\n     */\n    get: function () {\n      return this._elements;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Pattern.prototype, \"fillOpacity\", {\n    /**\r\n     * @return Opacity (0-1)\r\n     */\n    get: function () {\n      return this.properties[\"fillOpacity\"];\n    },\n\n    /**\r\n     * Pattern fill opacity. (0-1)\r\n     *\r\n     * @param value  Opacity (0-1)\r\n     */\n    set: function (value) {\n      this.properties[\"fillOpacity\"] = value;\n      this.draw();\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Pattern.prototype, \"fill\", {\n    /**\r\n     * @return Fill color\r\n     */\n    get: function () {\n      return this.properties[\"fill\"];\n    },\n\n    /**\r\n     * Fill color of the pattern.\r\n     *\r\n     * @param value  Fill color\r\n     */\n    set: function (value) {\n      this.properties[\"fill\"] = value;\n      this.draw();\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Pattern.prototype, \"backgroundFill\", {\n    /**\r\n     * @return Background color\r\n     */\n    get: function () {\n      return this.properties[\"backgroundFill\"];\n    },\n\n    /**\r\n     * Pattern background fill color.\r\n     *\r\n     * @param value  Background color\r\n     */\n    set: function (value) {\n      this.properties[\"backgroundFill\"] = value;\n      this.draw();\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Pattern.prototype, \"backgroundOpacity\", {\n    /**\r\n     * @return Background opacity (0-1)\r\n     */\n    get: function () {\n      return this.properties[\"backgroundOpacity\"];\n    },\n\n    /**\r\n     * Pattern backgorund opacity. (0-1)\r\n     *\r\n     * @param value  Background opacity (0-1)\r\n     */\n    set: function (value) {\n      this.properties[\"backgroundOpacity\"] = value;\n      this.draw();\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Pattern.prototype, \"stroke\", {\n    /**\r\n     * @return Color\r\n     */\n    get: function () {\n      return this.properties[\"stroke\"];\n    },\n\n    /**\r\n     * Pattern stroke (border) color.\r\n     *\r\n     * @param value  Color\r\n     */\n    set: function (value) {\n      this.properties[\"stroke\"] = value;\n      this.draw();\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Pattern.prototype, \"strokeOpacity\", {\n    /**\r\n     * @return Opacity (0-1)\r\n     */\n    get: function () {\n      return this.properties[\"strokeOpacity\"];\n    },\n\n    /**\r\n     * Pattern stroke opacity. (0-1)\r\n     *\r\n     * @param value  Opacity (0-1)\r\n     */\n    set: function (value) {\n      this.properties[\"strokeOpacity\"] = value;\n      this.draw();\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Pattern.prototype, \"strokeWidth\", {\n    /**\r\n     * @return Stroke thickness (px)\r\n     */\n    get: function () {\n      return this.properties[\"strokeWidth\"];\n    },\n\n    /**\r\n     * Pattern stroke thickness in pixels.\r\n     *\r\n     * @param value  Stroke thickness (px)\r\n     */\n    set: function (value) {\n      this.properties[\"strokeWidth\"] = value;\n      this.draw();\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Pattern.prototype, \"shapeRendering\", {\n    get: function () {\n      return this.properties[\"shapeRendering\"];\n    },\n\n    /**\r\n     * Shape rendering\r\n     * @param value [description]\r\n     */\n    set: function (value) {\n      this.properties[\"shapeRendering\"] = value;\n      this.draw();\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Pattern.prototype, \"rotation\", {\n    /**\r\n     * @return Rotation\r\n     */\n    get: function () {\n      return this.properties[\"rotation\"];\n    },\n\n    /**\r\n     * Pattern rotation in degrees.\r\n     *\r\n     * @param value  Rotation\r\n     */\n    set: function (value) {\n      this.properties[\"rotation\"] = value;\n      this.draw();\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Pattern.prototype, \"patternUnits\", {\n    /**\r\n     * @return Units\r\n     */\n    get: function () {\n      return this.properties[\"patternUnits\"];\n    },\n\n    /**\r\n     * Pattern measuring units.\r\n     *\r\n     * Available options: \"userSpaceOnUse\" | \"objectBoundingBox\".\r\n     *\r\n     * @param value  Units\r\n     */\n    set: function (value) {\n      this.properties[\"patternUnits\"] = value;\n      this.draw();\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Pattern.prototype, \"width\", {\n    /**\r\n     * @return Width (px)\r\n     */\n    get: function () {\n      return this.properties[\"width\"];\n    },\n\n    /**\r\n     * Pattern width in pixels.\r\n     *\r\n     * @param value  Width (px)\r\n     */\n    set: function (value) {\n      this.properties[\"width\"] = value;\n      this.draw();\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Pattern.prototype, \"height\", {\n    /**\r\n     * @return Height (px)\r\n     */\n    get: function () {\n      return this.properties[\"height\"];\n    },\n\n    /**\r\n     * Pattern height in pixels.\r\n     *\r\n     * @param value Height (px)\r\n     */\n    set: function (value) {\n      this.properties[\"height\"] = value;\n      this.draw();\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Pattern.prototype, \"x\", {\n    /**\r\n     * @return X (px)\r\n     */\n    get: function () {\n      return this.properties[\"x\"];\n    },\n\n    /**\r\n     * X position. (pixels)\r\n     *\r\n     * @param value X (px)\r\n     */\n    set: function (value) {\n      this.properties[\"x\"] = value;\n      this.draw();\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Pattern.prototype, \"y\", {\n    /**\r\n     * @return Y (px)\r\n     */\n    get: function () {\n      return this.properties[\"y\"];\n    },\n\n    /**\r\n     * Y position (px).\r\n     *\r\n     * @param value Y (px)\r\n     */\n    set: function (value) {\n      this.properties[\"y\"] = value;\n      this.draw();\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Pattern.prototype, \"paper\", {\n    /**\r\n     * @ignore Exclude from docs\r\n     * @return Paper\r\n     */\n    get: function () {\n      if (this._paper) {\n        return this._paper;\n      }\n\n      return getGhostPaper();\n    },\n\n    /**\r\n     * [[Paper]] instance to draw pattern in.\r\n     *\r\n     * @ignore Exclude from docs\r\n     * @param paper  Paper\r\n     */\n    set: function (paper) {\n      if (this._paper != paper) {\n        this._paper = paper;\n        this.draw();\n        paper.appendDef(this.element);\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\r\n   * Copies properties from another Pattern instance.\r\n   *\r\n   * @param source  Source pattern\r\n   */\n\n  Pattern.prototype.copyFrom = function (source) {\n    var _this = this;\n\n    _super.prototype.copyFrom.call(this, source);\n\n    $object.each(source.properties, function (key, value) {\n      _this[key] = value;\n    });\n  };\n\n  Object.defineProperty(Pattern.prototype, \"animations\", {\n    /**\r\n     * A list of animations currently running on the patter.\r\n     *\r\n     * @ignore Exclude from docs\r\n     * @return Animation list\r\n     */\n    get: function () {\n      if (!this._animations) {\n        this._animations = [];\n\n        this._disposers.push(new AnimationDisposer(this._animations));\n      }\n\n      return this._animations;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Pattern.prototype, \"strokeDasharray\", {\n    /**\r\n     * @return `stroke-dasharray`\r\n     */\n    get: function () {\n      return this.properties[\"strokeDashArray\"];\n    },\n\n    /**\r\n     * A `stroke-dasharray` for the stroke (outline).\r\n     *\r\n     * \"Dasharray\" allows setting rules to make lines dashed, dotted, etc.\r\n     *\r\n     * @see {@link https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/stroke-dasharray} for more info on `stroke-dasharray`\r\n     * @param value  `stroke-dasharray`\r\n     */\n    set: function (value) {\n      this.properties[\"strokeDashArray\"] = value;\n      this.draw();\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\r\n   * Processes JSON-based config before it is applied to the object.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param config  Config\r\n   */\n\n  Pattern.prototype.processConfig = function (config) {\n    if (config) {\n      // Set up series\n      if ($type.hasValue(config.elements) && $type.isArray(config.elements)) {\n        for (var i = 0, len = config.elements.length; i < len; i++) {\n          var element = config.elements[i];\n\n          if ($type.hasValue(element[\"type\"])) {\n            var sprite = this.createEntryInstance(element);\n\n            if (sprite instanceof BaseObject) {\n              sprite.config = element;\n            }\n\n            this.addElement($type.hasValue(element[\"typeProperty\"]) ? sprite[element[\"typeProperty\"]] : sprite.element);\n          }\n        }\n      }\n    }\n\n    _super.prototype.processConfig.call(this, config);\n  };\n\n  return Pattern;\n}(BaseObject);\n\nexport { Pattern };\n/**\r\n * Register class in system, so that it can be instantiated using its name from\r\n * anywhere.\r\n *\r\n * @ignore\r\n */\n\nregistry.registeredClasses[\"Pattern\"] = Pattern;","map":null,"metadata":{},"sourceType":"module"}