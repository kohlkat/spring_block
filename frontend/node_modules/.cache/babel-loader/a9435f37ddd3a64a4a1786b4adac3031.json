{"ast":null,"code":"/**\r\n * Value Axis module\r\n */\nimport * as tslib_1 from \"tslib\";\n/**\r\n * ============================================================================\r\n * IMPORTS\r\n * ============================================================================\r\n * @hidden\r\n */\n\nimport { Axis, AxisDataItem } from \"./Axis\";\nimport { AxisRendererY } from \"./AxisRendererY\";\nimport { MultiDisposer } from \"../../core/utils/Disposer\";\nimport { registry } from \"../../core/Registry\";\nimport { ValueAxisBreak } from \"./ValueAxisBreak\";\nimport * as $math from \"../../core/utils/Math\";\nimport * as $iter from \"../../core/utils/Iterator\";\nimport * as $object from \"../../core/utils/Object\";\nimport * as $type from \"../../core/utils/Type\";\nimport * as $utils from \"../../core/utils/Utils\";\n/**\r\n * ============================================================================\r\n * DATA ITEM\r\n * ============================================================================\r\n * @hidden\r\n */\n\n/**\r\n * Defines a [[DataItem]] for [[ValueAxis]].\r\n *\r\n * @see {@link DataItem}\r\n */\n\nvar ValueAxisDataItem =\n/** @class */\nfunction (_super) {\n  tslib_1.__extends(ValueAxisDataItem, _super);\n  /**\r\n   * Constructor\r\n   */\n\n\n  function ValueAxisDataItem() {\n    var _this = _super.call(this) || this;\n\n    _this.className = \"ValueAxisDataItem\";\n    _this.values.value = {};\n    _this.values.endValue = {};\n\n    _this.applyTheme();\n\n    return _this;\n  }\n\n  Object.defineProperty(ValueAxisDataItem.prototype, \"value\", {\n    /**\r\n     * @return Value\r\n     */\n    get: function () {\n      return this.values[\"value\"].value;\n    },\n\n    /**\r\n     * A data point's numeric value.\r\n     *\r\n     * @param value  Value\r\n     */\n    set: function (value) {\n      this.setValue(\"value\", value);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(ValueAxisDataItem.prototype, \"endValue\", {\n    /**\r\n     * @return Value\r\n     */\n    get: function () {\n      return this.values[\"endValue\"].value;\n    },\n\n    /**\r\n     * Data point's numeric end value.\r\n     *\r\n     * @param value  End value\r\n     */\n    set: function (value) {\n      this.setValue(\"endValue\", value);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  return ValueAxisDataItem;\n}(AxisDataItem);\n\nexport { ValueAxisDataItem };\n/**\r\n * ============================================================================\r\n * MAIN CLASS\r\n * ============================================================================\r\n * @hidden\r\n */\n\n/**\r\n * Used to create a value axis for the chart.\r\n *\r\n * ```TypeScript\r\n * // Create the axis\r\n * let valueAxis = chart.yAxes.push(new am4charts.ValueAxis());\r\n *\r\n * // Set settings\r\n * valueAxis.title.text = \"Monthly Sales\";\r\n * ```\r\n * ```JavaScript\r\n * // Create the axis\r\n * var valueAxis = chart.yAxes.push(new am4charts.ValueAxis());\r\n *\r\n * // Set settings\r\n * valueAxis.title.text = \"Monthly Sales\";\r\n * ```\r\n * ```JSON\r\n * \"yAxes\": [{\r\n *   \"type\": \"ValueAxis\",\r\n *   \"title\": {\r\n *     \"text\": \"Monthly Sales\"\r\n *   }\r\n * }]\r\n * ```\r\n *\r\n * @see {@link IValueAxisEvents} for a list of available Events\r\n * @see {@link IValueAxisAdapters} for a list of available Adapters\r\n * @important\r\n */\n\nvar ValueAxis =\n/** @class */\nfunction (_super) {\n  tslib_1.__extends(ValueAxis, _super);\n  /**\r\n   * Constructor\r\n   */\n\n\n  function ValueAxis() {\n    var _this = // Init\n    _super.call(this) || this;\n    /**\r\n     * [_stepDecimalPlaces description]\r\n     *\r\n     * @todo Description\r\n     */\n\n\n    _this._stepDecimalPlaces = 0;\n    /**\r\n     * Base value for the axis.\r\n     */\n\n    _this._baseValue = 0;\n    /**\r\n     * Adjusted start in case we have breaks.\r\n     *\r\n     * @todo Description\r\n     */\n\n    _this._adjustedStart = 0;\n    /**\r\n     * Adjusted end in case we have breaks.\r\n     *\r\n     * @todo Description\r\n     */\n\n    _this._adjustedEnd = 1;\n    _this._extremesChanged = false;\n    _this._deltaMinMax = 1;\n    /**\r\n     * As calculating totals is expensive operation and not often needed, we\r\n     * don't do it by default.\r\n     *\r\n     * In case you use `totalPercent` or `total` in your charts, this must be set\r\n     * to `true`.\r\n     *\r\n     * @default false\r\n     * @see {@link https://www.amcharts.com/docs/v4/chart-types/xy-chart/#100_stacks} For using `calculateTotals` for 100% stacked series.\r\n     * @see {@link https://www.amcharts.com/docs/v4/concepts/formatters/formatting-strings/#Placeholders_for_numeric_values} For using `calculateTotals` in labels.\r\n     */\n\n    _this.calculateTotals = false;\n    _this.className = \"ValueAxis\"; // Set field name\n\n    _this.axisFieldName = \"value\"; // Set defaults\n\n    _this.setPropertyValue(\"maxZoomFactor\", 1000);\n\n    _this.setPropertyValue(\"extraMin\", 0);\n\n    _this.setPropertyValue(\"extraMax\", 0);\n\n    _this.setPropertyValue(\"strictMinMax\", false);\n\n    _this.setPropertyValue(\"maxPrecision\", Number.MAX_VALUE);\n\n    _this.keepSelection = false;\n    _this.includeRangesInMinMax = false; // Apply theme\n\n    _this.applyTheme();\n\n    return _this;\n  }\n  /**\r\n   * Holds reference to a function that accepts a DataItem as parameter.\r\n   *\r\n   * It can either return a fill opacity for a fill, or manipulate data item\r\n   * directly, to create various highlighting scenarios.\r\n   */\n\n\n  ValueAxis.prototype.fillRule = function (dataItem) {\n    var value = dataItem.value;\n    var axis = dataItem.component;\n\n    if (!dataItem.axisFill.disabled) {\n      // rounding in left to solve floating point number\n      if ($math.round(value / axis.step / 2, 5) == Math.round(value / axis.step / 2)) {\n        dataItem.axisFill.__disabled = true;\n      } else {\n        dataItem.axisFill.__disabled = false;\n      }\n    }\n  };\n  /**\r\n   * Returns a new/empty [[DataItem]] of the type appropriate for this object.\r\n   *\r\n   * @see {@link DataItem}\r\n   * @return Data Item\r\n   */\n\n\n  ValueAxis.prototype.createDataItem = function () {\n    return new ValueAxisDataItem();\n  };\n  /**\r\n   * Returns a new/empty [[AxisBreak]] of the appropriate type.\r\n   *\r\n   * @return Axis break\r\n   */\n\n\n  ValueAxis.prototype.createAxisBreak = function () {\n    return new ValueAxisBreak();\n  };\n  /**\r\n   * [dataChangeUpdate description]\r\n   *\r\n   * This is a placeholder to override for extending classes.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @todo Description\r\n   */\n\n\n  ValueAxis.prototype.dataChangeUpdate = function () {\n    if (!this.keepSelection) {\n      if (this._start != 0 || this._end != 1) {\n        this._start = 0;\n        this._end = 1;\n        this.dispatchImmediately(\"startendchanged\");\n      }\n    } else {\n      if (this._start != 0) {\n        this.dispatchImmediately(\"startchanged\");\n      }\n\n      if (this._end != 1) {\n        this.dispatchImmediately(\"endchanged\");\n      }\n\n      if (this._start != 0 || this._end != 1) {\n        this.dispatchImmediately(\"startendchanged\");\n      }\n    }\n\n    this._maxZoomed = this._maxDefined;\n    this._minZoomed = this._minDefined;\n    this._maxAdjusted = this._maxDefined;\n    this._minAdjusted = this._minDefined;\n  };\n  /**\r\n   * Processes data items of the related Series.\r\n   *\r\n   * @ignore Exclude from docs\r\n   */\n\n\n  ValueAxis.prototype.processSeriesDataItems = function () {\n    // @todo: add some boolean (maybe autodedect) if we need these calculations or not. this place uses a lot of cpu\n    if (this.calculateTotals) {\n      var series = this.series.getIndex(0);\n      var startIndex = series.startIndex;\n\n      if (series.dataItems.length > 0) {\n        if (startIndex > 0) {\n          startIndex--;\n        }\n\n        var endIndex = series.endIndex;\n\n        if (endIndex < series.dataItems.length) {\n          endIndex++;\n        }\n\n        var _loop_1 = function (i) {\n          // This has to be `var` in order to avoid garbage collection\n          var total = {};\n          this_1.series.each(function (series) {\n            if (!series.excludeFromTotal) {\n              var dataItem_1 = series.dataItems.getIndex(i);\n\n              if (dataItem_1) {\n                $object.each(dataItem_1.values, function (key) {\n                  var value = dataItem_1.values[key].workingValue; // can not use getWorkingValue here!\n\n                  if ($type.isNumber(value)) {\n                    if (!$type.isNumber(total[key])) {\n                      total[key] = Math.abs(value);\n                    } else {\n                      total[key] += Math.abs(value);\n                    }\n                  }\n                });\n              }\n            }\n          });\n          this_1.series.each(function (series) {\n            if (!series.excludeFromTotal) {\n              var dataItem_2 = series.dataItems.getIndex(i);\n\n              if (dataItem_2) {\n                $object.each(dataItem_2.values, function (key) {\n                  var value = dataItem_2.values[key].workingValue; // can not use getWorkingValue here!\n\n                  if ($type.isNumber(value)) {\n                    dataItem_2.setCalculatedValue(key, total[key], \"total\");\n                    dataItem_2.setCalculatedValue(key, 100 * value / total[key], \"totalPercent\");\n                  }\n                });\n              }\n            }\n          });\n        };\n\n        var this_1 = this; // This has to be `var` in order to avoid garbage collection\n\n        for (var i = startIndex; i < endIndex; ++i) {\n          _loop_1(i);\n        }\n      }\n    }\n  };\n  /**\r\n   * Validates the whole axis. Causes it to redraw.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @todo Description (review)\r\n   */\n\n\n  ValueAxis.prototype.validate = function () {\n    if (this.axisLength <= 0) {\n      return;\n    }\n\n    _super.prototype.validate.call(this);\n\n    this.getMinMax();\n    this.fixAxisBreaks();\n    this.calculateZoom();\n    this.validateAxisElements();\n    this.validateAxisRanges();\n    this.validateBreaks();\n    this.hideUnusedDataItems();\n    this.renderer.invalidateLayout(); // hide too close\n    //this.hideTooCloseDataItems();\n  };\n  /**\r\n   * Calculates all positions, related to axis as per current zoom.\r\n   *\r\n   * @ignore Exclude from docs\r\n   */\n\n\n  ValueAxis.prototype.calculateZoom = function () {\n    if ($type.isNumber(this.min) && $type.isNumber(this.max)) {\n      var min = this.positionToValue(this.start);\n      var max = this.positionToValue(this.end);\n      var differece = this.adjustDifference(min, max);\n      var minMaxStep = this.adjustMinMax(min, max, differece, this._gridCount, true);\n      min = minMaxStep.min;\n      max = minMaxStep.max;\n      this._adjustedStart = $math.round((min - this.min) / (this.max - this.min), 5);\n      this._adjustedEnd = $math.round((max - this.min) / (this.max - this.min), 5);\n      this._step = minMaxStep.step;\n      this._stepDecimalPlaces = $utils.decimalPlaces(this._step);\n\n      if (this._minZoomed != min || this._maxZoomed != max) {\n        this._minZoomed = min;\n        this._maxZoomed = max;\n        this.dispatchImmediately(\"selectionextremeschanged\");\n      }\n    } else {\n      this._adjustedStart = this.start;\n      this._adjustedEnd = this.end;\n    }\n  };\n  /**\r\n   * Validates Axis elements.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @todo Description\r\n   */\n\n\n  ValueAxis.prototype.validateAxisElements = function () {\n    var _this = this;\n\n    if ($type.isNumber(this.max) && $type.isNumber(this.min)) {\n      // first regular items\n      var value_1 = this.minZoomed - this._step * 2;\n\n      if (!this.logarithmic) {\n        value_1 = Math.floor(value_1 / this._step) * this._step;\n      } else {\n        var differencePower = Math.log(this.max) * Math.LOG10E - Math.log(this.min) * Math.LOG10E;\n\n        if (differencePower > 1) {\n          value_1 = Math.pow(10, Math.log(this.min) * Math.LOG10E);\n        } else {\n          value_1 = Math.floor(this.minZoomed / this._step) * this._step;\n\n          if (value_1 == 0) {\n            value_1 = this.minZoomed;\n          }\n        }\n      }\n\n      var maxZoomed = this._maxZoomed + this._step;\n      this.resetIterators();\n      var dataItemsIterator_1 = this._dataItemsIterator;\n      var i = 0;\n\n      while (value_1 <= maxZoomed) {\n        var axisBreak = this.isInBreak(value_1);\n\n        if (!axisBreak) {\n          var dataItem = dataItemsIterator_1.find(function (x) {\n            return x.value === value_1;\n          });\n\n          if (dataItem.__disabled) {\n            dataItem.__disabled = false;\n          } //this.processDataItem(dataItem);\n\n\n          this.appendDataItem(dataItem);\n          dataItem.axisBreak = undefined;\n\n          if (dataItem.value != value_1) {\n            dataItem.value = value_1;\n            dataItem.text = this.formatLabel(value_1);\n\n            if (dataItem.label && dataItem.label.invalid) {\n              dataItem.label.validate();\n            }\n\n            if (dataItem.value >= this.min && dataItem.value <= this.max) {\n              if (dataItem.label) {\n                if (this.axisLetter == \"Y\" && dataItem.label.measuredWidth > this.ghostLabel.measuredWidth || this.axisLetter == \"X\" && dataItem.label.measuredHeight > this.ghostLabel.measuredHeight) {\n                  this.ghostLabel.text = dataItem.label.currentText;\n                  this.ghostLabel.validate();\n                }\n              }\n            }\n          }\n\n          this.validateDataElement(dataItem);\n        }\n\n        i++;\n\n        if (!this.logarithmic) {\n          value_1 += this._step;\n        } else {\n          var differencePower = Math.log(this.max) * Math.LOG10E - Math.log(this.min) * Math.LOG10E;\n\n          if (differencePower > 1) {\n            value_1 = Math.pow(10, Math.log(this.min) * Math.LOG10E + i);\n          } else {\n            value_1 += this._step;\n          }\n        }\n\n        var stepPower = Math.pow(10, Math.floor(Math.log(Math.abs(this._step)) * Math.LOG10E));\n\n        if (stepPower < 1) {\n          // exponent is less then 1 too. Count decimals of exponent\n          var decCount = Math.round(Math.abs(Math.log(Math.abs(stepPower)) * Math.LOG10E)) + 2; // round value to avoid floating point issues\n\n          value_1 = $math.round(value_1, decCount);\n        }\n      }\n\n      var axisBreaks = this._axisBreaks;\n\n      if (axisBreaks) {\n        // breaks later\n        var renderer_1 = this.renderer;\n        $iter.each(axisBreaks.iterator(), function (axisBreak) {\n          if (axisBreak.breakSize > 0) {\n            // only add grid if gap is bigger then minGridDistance\n            if ($math.getDistance(axisBreak.startPoint, axisBreak.endPoint) > renderer_1.minGridDistance) {\n              var breakValue_1 = axisBreak.adjustedMin;\n\n              while (breakValue_1 <= axisBreak.adjustedMax) {\n                if (breakValue_1 >= axisBreak.adjustedStartValue && breakValue_1 <= axisBreak.adjustedEndValue) {\n                  var dataItem = dataItemsIterator_1.find(function (x) {\n                    return x.value === breakValue_1;\n                  });\n\n                  if (dataItem.__disabled) {\n                    dataItem.__disabled = false;\n                  } //this.processDataItem(dataItem);\n\n\n                  _this.appendDataItem(dataItem);\n\n                  dataItem.axisBreak = axisBreak;\n\n                  if (dataItem.value != breakValue_1) {\n                    dataItem.value = breakValue_1;\n                    dataItem.text = _this.formatLabel(breakValue_1);\n\n                    if (dataItem.label && dataItem.label.invalid) {\n                      dataItem.label.validate();\n                    }\n                  }\n\n                  _this.validateDataElement(dataItem);\n                }\n\n                breakValue_1 += axisBreak.adjustedStep;\n              }\n            }\n          }\n        });\n      }\n    }\n  };\n  /**\r\n   * Validates axis data item.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @todo Description\r\n   * @param dataItem  Data item\r\n   */\n\n\n  ValueAxis.prototype.validateDataElement = function (dataItem) {\n    _super.prototype.validateDataElement.call(this, dataItem); //dataItem.__disabled = false;\n\n\n    dataItem.itemIndex = this._axisItemCount;\n    this._axisItemCount++;\n    var renderer = this.renderer;\n    var value = dataItem.value;\n    var endValue = dataItem.endValue;\n    var position = this.valueToPosition(value);\n    dataItem.position = position;\n    var endPosition = position;\n    var fillEndPosition = this.valueToPosition(value + this._step);\n\n    if ($type.isNumber(endValue)) {\n      endPosition = this.valueToPosition(endValue);\n      fillEndPosition = endPosition;\n    } // this point is needed to calculate distance to satisfy minGridDistance\n\n\n    dataItem.point = renderer.positionToPoint(position);\n    var tick = dataItem.tick;\n\n    if (tick && !tick.disabled) {\n      renderer.updateTickElement(tick, position, endPosition);\n    }\n\n    var grid = dataItem.grid;\n\n    if (grid && !grid.disabled) {\n      renderer.updateGridElement(grid, position, endPosition);\n    }\n\n    var label = dataItem.label;\n\n    if (label && !label.disabled) {\n      renderer.updateLabelElement(label, position, endPosition);\n    }\n\n    var fill = dataItem.axisFill;\n\n    if (fill && !fill.disabled) {\n      renderer.updateFillElement(fill, position, fillEndPosition);\n\n      if (!dataItem.isRange) {\n        this.fillRule(dataItem);\n      }\n    }\n\n    if (dataItem.bullet) {\n      renderer.updateBullet(dataItem.bullet, position, endPosition);\n    }\n\n    var mask = dataItem.mask;\n\n    if (mask) {\n      renderer.updateFillElement(mask, position, fillEndPosition);\n    }\n  };\n  /**\r\n   * Formats the value according to axis' own [[NumberFormatter]].\r\n   *\r\n   * @param value  Source value\r\n   * @return Formatted value\r\n   */\n\n\n  ValueAxis.prototype.formatLabel = function (value) {\n    return this.numberFormatter.format(value);\n  };\n\n  Object.defineProperty(ValueAxis.prototype, \"basePoint\", {\n    /**\r\n     * Coordinates of the actual axis start.\r\n     *\r\n     * @ignore Exclude from docs\r\n     * @return Base point\r\n     */\n    get: function () {\n      var baseValue = this.baseValue;\n      var position = this.valueToPosition(baseValue);\n      var basePoint = this.renderer.positionToPoint(position);\n      return basePoint;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(ValueAxis.prototype, \"baseValue\", {\n    /**\r\n     * @return base value\r\n     */\n    get: function () {\n      if (this.logarithmic) {\n        return this.min;\n      } else {\n        return this._baseValue;\n      }\n    },\n\n    /**\r\n     * A base value.\r\n     *\r\n     * This is a threshold value that will divide \"positive\" and \"negative\"\r\n     * value ranges.\r\n     *\r\n     * Other scale-related functionality also depend on base value. E.g. stacks,\r\n     * value-dependent coloring, etc.\r\n     *\r\n     * @param value Base value\r\n     */\n    set: function (value) {\n      this._baseValue = value;\n      this.invalidateLayout();\n      this.invalidateSeries();\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\r\n   * Converts a numeric value to relative position on axis\r\n   *\r\n   * An alias to `valueToPosition()`.\r\n   *\r\n   * @param value  Value\r\n   * @return Position\r\n   */\n\n  ValueAxis.prototype.anyToPosition = function (value) {\n    return this.valueToPosition(value);\n  };\n  /**\r\n   * Converts a numeric value to orientation point (x, y, angle) on axis\r\n   *\r\n   * @param value  Value\r\n   * @return Orientation point\r\n   */\n\n\n  ValueAxis.prototype.valueToPoint = function (value) {\n    var position = this.valueToPosition(value);\n    var point = this.renderer.positionToPoint(position);\n    var angle = this.renderer.positionToAngle(position);\n    return {\n      x: point.x,\n      y: point.y,\n      angle: angle\n    };\n  };\n  /**\r\n   * Converts a numeric value to orientation (x, y, angle) point on axis\r\n   *\r\n   * @param value  Value\r\n   * @return Orientation point\r\n   */\n\n\n  ValueAxis.prototype.anyToPoint = function (value) {\n    return this.valueToPoint(value);\n  };\n  /**\r\n   * Converts a numeric value to relative position on axis.\r\n   *\r\n   * @param value  Value\r\n   * @return relative position\r\n   */\n\n\n  ValueAxis.prototype.valueToPosition = function (value) {\n    if ($type.isNumber(value)) {\n      // todo: think if possible to take previous value and do not go through all previous breaks\n      var min_1 = this.min;\n      var max_1 = this.max;\n\n      if ($type.isNumber(min_1) && $type.isNumber(max_1)) {\n        var difference = this._difference;\n        var axisBreaks = this._axisBreaks;\n\n        if (axisBreaks && axisBreaks.length > 0) {\n          $iter.eachContinue(axisBreaks.iterator(), function (axisBreak) {\n            var startValue = axisBreak.adjustedStartValue;\n            var endValue = axisBreak.adjustedEndValue;\n\n            if ($type.isNumber(startValue) && $type.isNumber(endValue)) {\n              if (value < startValue) {\n                return false;\n              }\n\n              if ($math.intersect({\n                start: startValue,\n                end: endValue\n              }, {\n                start: min_1,\n                end: max_1\n              })) {\n                // todo: check this once and set some flag in axisBreak\n                startValue = Math.max(startValue, min_1);\n                endValue = Math.min(endValue, max_1);\n                var breakSize = axisBreak.breakSize; // value to the right of break end\n\n                if (value > endValue) {\n                  min_1 += (endValue - startValue) * (1 - breakSize); // todo: maybe this can be done differently?\n                } // value to the left of break start\n                else if (value < startValue) {} // value within break\n                  else {\n                      value = startValue + (value - startValue) * breakSize;\n                    }\n              }\n            }\n\n            return true;\n          });\n        }\n\n        var position = void 0;\n\n        if (!this.logarithmic) {\n          position = (value - min_1) / difference;\n        } else {\n          position = (Math.log(value) * Math.LOG10E - Math.log(this.min) * Math.LOG10E) / (Math.log(this.max) * Math.LOG10E - Math.log(this.min) * Math.LOG10E);\n        } //position = $math.round(position, 10);\n\n\n        return position;\n      }\n    }\n\n    return 0;\n  };\n  /**\r\n   * Converts an relative position to a corresponding value within\r\n   * axis' scale.\r\n   *\r\n   * @param position  Position (px)\r\n   * @return Value\r\n   */\n\n\n  ValueAxis.prototype.positionToValue = function (position) {\n    position = $math.round(position, 10);\n    var min = this.min;\n    var max = this.max;\n\n    if ($type.isNumber(min) && $type.isNumber(max)) {\n      var difference_1 = max - min; //no need to adjust!\n\n      var value_2 = null;\n      var axisBreaks = this._axisBreaks;\n\n      if (axisBreaks) {\n        // in case we have some axis breaks\n        if (axisBreaks.length > 0) {\n          $iter.eachContinue(axisBreaks.iterator(), function (axisBreak) {\n            var breakStartPosition = axisBreak.startPosition;\n            var breakEndPosition = axisBreak.endPosition;\n            var breakStartValue = axisBreak.adjustedStartValue;\n            var breakEndValue = axisBreak.adjustedEndValue;\n\n            if ($type.isNumber(breakStartValue) && $type.isNumber(breakEndValue)) {\n              if (breakStartValue > max) {\n                return false;\n              }\n\n              if ($math.intersect({\n                start: breakStartValue,\n                end: breakEndValue\n              }, {\n                start: min,\n                end: max\n              })) {\n                breakStartValue = $math.max(breakStartValue, min);\n                breakEndValue = $math.min(breakEndValue, max);\n                var breakSize = axisBreak.breakSize;\n                difference_1 -= (breakEndValue - breakStartValue) * (1 - breakSize); // position to the right of break end\n\n                if (position > breakEndPosition) {\n                  min += (breakEndValue - breakStartValue) * (1 - breakSize);\n                } // position to the left of break start\n                else if (position < breakStartPosition) {} // value within break\n                  else {\n                      var breakPosition = (position - breakStartPosition) / (breakEndPosition - breakStartPosition);\n                      value_2 = breakStartValue + breakPosition * (breakEndValue - breakStartValue);\n                      return false;\n                    }\n              }\n\n              return true;\n            }\n          });\n        }\n      }\n\n      if (!$type.isNumber(value_2)) {\n        if (this.logarithmic) {\n          value_2 = Math.pow(Math.E, (position * (Math.log(this.max) * Math.LOG10E - Math.log(this.min) * Math.LOG10E) + Math.log(this.min) * Math.LOG10E) / Math.LOG10E);\n        } else {\n          value_2 = position * difference_1 + min;\n        }\n      }\n\n      return value_2;\n    } //}\n\n  };\n  /**\r\n   * Converts an X coordinate to a relative value in axis' scale.\r\n   *\r\n   * @param x  X (px)\r\n   * @return Value\r\n   */\n\n\n  ValueAxis.prototype.xToValue = function (x) {\n    return this.positionToValue(this.pointToPosition({\n      x: x,\n      y: 0\n    }));\n  };\n  /**\r\n   * Converts an Y coordinate to a relative value in axis' scale.\r\n   *\r\n   * @param y  Y (px)\r\n   * @return Value\r\n   */\n\n\n  ValueAxis.prototype.yToValue = function (y) {\n    return this.positionToValue(this.pointToPosition({\n      x: 0,\n      y: y\n    }));\n  };\n  /**\r\n   * Converts pixel coordinates to a relative position. (0-1)\r\n   *\r\n   * @param point  Coorinates (px)\r\n   * @return Position (0-1)\r\n   */\n\n\n  ValueAxis.prototype.pointToPosition = function (point) {\n    if (this.renderer instanceof AxisRendererY) {\n      return 1 - this.renderer.pointToPosition(point);\n    } else {\n      return this.renderer.pointToPosition(point);\n    }\n  };\n  /**\r\n   * @ignore\r\n   */\n\n\n  ValueAxis.prototype.animateMinMax = function (min, max) {\n    return this.animate([{\n      property: \"_minAdjusted\",\n      from: this._minAdjusted,\n      to: min\n    }, {\n      property: \"_maxAdjusted\",\n      from: this._maxAdjusted,\n      to: max\n    }], this.rangeChangeDuration, this.rangeChangeEasing);\n  };\n  /**\r\n   * Calculates smallest and biggest value for the axis scale.\r\n   * @ignore\r\n   * @todo Description (review)\r\n   */\n\n\n  ValueAxis.prototype.getMinMax = function () {\n    var _this = this;\n\n    this.updateGridCount();\n    var min = Number.POSITIVE_INFINITY;\n    var max = Number.NEGATIVE_INFINITY; // only if min and max are not set from outside, we go through min and max influencers\n\n    if (!$type.isNumber(this._minDefined) || !$type.isNumber(this._maxDefined)) {\n      this.series.each(function (series) {\n        if (!series.ignoreMinMax) {\n          // check min\n          var seriesMin = series.min(_this);\n\n          if ($type.isNumber(seriesMin) && seriesMin < min) {\n            min = seriesMin;\n          } // check max\n\n\n          var seriesMax = series.max(_this);\n\n          if ($type.isNumber(seriesMax) && seriesMax > max) {\n            max = seriesMax;\n          }\n        }\n      });\n\n      if (this.includeRangesInMinMax) {\n        this.axisRanges.each(function (range) {\n          if (!range.ignoreMinMax) {\n            var minValue = $math.min(range.value, range.endValue);\n            var maxValue = $math.max(range.value, range.endValue);\n\n            if (minValue < min || !$type.isNumber(min)) {\n              min = minValue;\n            }\n\n            if (maxValue > max || !$type.isNumber(max)) {\n              max = maxValue;\n            }\n          }\n        });\n      }\n    }\n\n    if (this.logarithmic) {\n      if (min <= 0) {\n        throw Error(\"Logarithmic value axis can not have vales <= 0.\");\n      }\n    }\n\n    if (min == 0 && max == 0) {\n      max = 0.9;\n      min = -0.9;\n    } // if defined from outside\n\n\n    if ($type.isNumber(this._minDefined)) {\n      min = this._minDefined;\n    }\n\n    if ($type.isNumber(this._maxDefined)) {\n      max = this._maxDefined;\n    }\n\n    if (!$type.isNumber(min) || !$type.isNumber(max)) {\n      return;\n    }\n\n    this._minReal = min;\n    this._maxReal = max;\n\n    if (min == Number.POSITIVE_INFINITY) {\n      min = undefined;\n    }\n\n    if (max == Number.NEGATIVE_INFINITY) {\n      max = undefined;\n    }\n\n    var dif = this.adjustDifference(min, max); // previously it was max-min, but not worked well\n\n    min = this.fixMin(min);\n    max = this.fixMax(max); // this happens if starLocation and endLocation are 0.5 and DateAxis has only one date\n\n    if (max - min <= 1 / Math.pow(10, 15)) {\n      if (max - min != 0) {\n        this._deltaMinMax = (max - min) / 2;\n      } else {\n        // the number by which we need to raise 10 to get difference\n        var exponent = Math.log(Math.abs(max)) * Math.LOG10E; // here we find a number which is power of 10 and has the same count of numbers as difference has\n\n        var power = Math.pow(10, Math.floor(exponent)); // reduce this number by 10 times\n\n        power = power / 10;\n        this._deltaMinMax = power;\n      }\n\n      min -= this._deltaMinMax;\n      max += this._deltaMinMax;\n    }\n\n    min -= (max - min) * this.extraMin;\n    max += (max - min) * this.extraMax;\n    var strict = this.strictMinMax;\n\n    if ($type.isNumber(this._maxDefined)) {\n      strict = true;\n    }\n\n    var minMaxStep = this.adjustMinMax(min, max, dif, this._gridCount, strict);\n    min = minMaxStep.min;\n    max = minMaxStep.max;\n    dif = max - min; //new\n    // do it for the second time (importat!)\n\n    minMaxStep = this.adjustMinMax(min, max, max - min, this._gridCount, true);\n    min = minMaxStep.min;\n    max = minMaxStep.max; // return min max if strict\n\n    if (this.strictMinMax) {\n      if ($type.isNumber(this._minDefined)) {\n        min = this._minDefined;\n      } else {\n        min = this._minReal;\n      }\n\n      if ($type.isNumber(this._maxDefined)) {\n        max = this._maxDefined;\n      } else {\n        max = this._maxReal;\n      }\n\n      if (max - min <= 0.00000001) {\n        min -= this._deltaMinMax;\n        max += this._deltaMinMax;\n      }\n\n      min -= (max - min) * this.extraMin;\n      max += (max - min) * this.extraMax;\n    } // checking isNumber is good when all series are hidden\n\n\n    if ((this._minAdjusted != min || this._maxAdjusted != max) && $type.isNumber(min) && $type.isNumber(max)) {\n      var animation = this._minMaxAnimation;\n\n      if (this._extremesChanged && $type.isNumber(this._minAdjusted) && $type.isNumber(this._maxAdjusted) && this.inited) {\n        if (animation && !animation.isFinished() && this._finalMax == max && this._finalMin == min) {\n          return;\n        } else {\n          this._finalMin = min;\n          this._finalMax = max;\n          animation = this.animateMinMax(min, max);\n\n          if (animation && !animation.isFinished()) {\n            animation.events.on(\"animationprogress\", this.validateDataItems, this);\n            animation.events.on(\"animationended\", function () {\n              //this.validateDataItems();\n              _this.series.each(function (series) {\n                series.validate();\n              });\n\n              _this.validateDataItems();\n\n              _this.handleSelectionExtremesChange();\n            });\n            this._minMaxAnimation = animation;\n          } else {\n            this.series.each(function (series) {\n              series.validate();\n            });\n          }\n\n          this.validateDataItems();\n          this.dispatchImmediately(\"extremeschanged\");\n          this.handleSelectionExtremesChange();\n        }\n      } else {\n        if (animation && !animation.isFinished() && this._finalMax == max && this._finalMin == min) {\n          return;\n        } else {\n          this._minAdjusted = min;\n          this._maxAdjusted = max;\n          this._finalMin = min;\n          this._finalMax = max;\n          this.invalidateDataItems();\n          this.dispatchImmediately(\"extremeschanged\");\n        }\n      }\n    }\n\n    this._extremesChanged = false;\n    this._difference = this.adjustDifference(min, max);\n  };\n  /**\r\n   * Adjusts the minimum value.\r\n   *\r\n   * This is a placeholder method for extending classes to override.\r\n   *\r\n   * For numeric values this does nothing, however for more complex types, like\r\n   * dates, it may be necessary to adjust.\r\n   *\r\n   * @param value  Value\r\n   * @return Adjusted value\r\n   */\n\n\n  ValueAxis.prototype.fixMin = function (value) {\n    return value;\n  };\n  /**\r\n   * Adjusts the maximum value.\r\n   *\r\n   * This is a placeholder method for extending classes to override.\r\n   *\r\n   * For numeric values this does nothing, however for more complex types, like\r\n   * dates, it may be necessary to adjust.\r\n   *\r\n   * @param value  Value\r\n   * @return Adjusted value\r\n   */\n\n\n  ValueAxis.prototype.fixMax = function (value) {\n    return value;\n  };\n  /**\r\n   * Adjusts actual min and max scale values so that the axis starts and ends\r\n   * at \"nice\" values, unless `strictMinMax` is set.\r\n   *\r\n   * The `difference` can be something else than `max - min`, because of the\r\n   * axis breaks.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @todo Description\r\n   * @param min        [description]\r\n   * @param max        [description]\r\n   * @param difference [description]\r\n   * @param gridCount  [description]\r\n   * @param strictMode [description]\r\n   * @return [description]\r\n   */\n\n\n  ValueAxis.prototype.adjustMinMax = function (min, max, difference, gridCount, strictMode) {\n    // will fail if 0\n    if (gridCount <= 1) {\n      gridCount = 1;\n    }\n\n    gridCount = Math.round(gridCount);\n    var initialMin = min;\n    var initialMax = max; // in case min and max is the same, use max\n\n    if (difference === 0) {\n      difference = Math.abs(max);\n    } // the number by which we need to raise 10 to get difference\n\n\n    var exponent = Math.log(Math.abs(difference)) * Math.LOG10E; // here we find a number which is power of 10 and has the same count of numbers as difference has\n\n    var power = Math.pow(10, Math.floor(exponent)); // reduce this number by 10 times\n\n    power = power / 10;\n    var extra = power;\n\n    if (strictMode) {\n      extra = 0;\n    }\n\n    if (!this.logarithmic) {\n      // round down min\n      if (strictMode) {\n        min = Math.floor(min / power) * power; // round up max\n\n        max = Math.ceil(max / power) * power;\n      } else {\n        min = Math.ceil(min / power) * power - extra; // round up max\n\n        max = Math.floor(max / power) * power + extra;\n      } // don't let min go below 0 if real min is >= 0\n\n\n      if (min < 0 && initialMin >= 0) {\n        min = 0;\n      } // don't let max go above 0 if real max is <= 0\n\n\n      if (max > 0 && initialMax <= 0) {\n        max = 0;\n      }\n    } else {\n      if (min <= 0) {\n        //throw Error(\"Logarithmic value axis can not have vales <= 0.\");\n        min = this.baseValue;\n      } // @todo: think of a better way or to restrict zooming when no series are selected\n\n\n      if (min == Infinity) {\n        min = 1;\n      }\n\n      if (max == -Infinity) {\n        max = 10;\n      }\n\n      min = Math.pow(10, Math.floor(Math.log(Math.abs(min)) * Math.LOG10E));\n      max = Math.pow(10, Math.ceil(Math.log(Math.abs(max)) * Math.LOG10E));\n    } // repeat diff, exponent and power again with rounded values\n    //difference = this.adjustDifference(min, max);\n\n    /*\r\n              if(min > initialMin){\r\n                min = initialMin;\r\n            }\r\n              if(max < initialMax){\r\n                max = initialMax;\r\n            }\r\n    */\n\n\n    exponent = Math.log(Math.abs(difference)) * Math.LOG10E;\n    power = Math.pow(10, Math.floor(exponent));\n    power = power / 10; // approximate difference between two grid lines\n\n    var step = Math.ceil(difference / gridCount / power) * power;\n    var stepPower = Math.pow(10, Math.floor(Math.log(Math.abs(step)) * Math.LOG10E)); // TODO: in v3 I had fixStepE here, ommiting it for a while, need to think about other solution\n    // the step should divide by  2, 5, and 10.\n\n    var stepDivisor = Math.ceil(step / stepPower); // number 0 - 10\n\n    if (stepDivisor > 5) {\n      stepDivisor = 10;\n    } else if (stepDivisor <= 5 && stepDivisor > 2) {\n      stepDivisor = 5;\n    } // now get real step\n\n\n    step = Math.ceil(step / (stepPower * stepDivisor)) * stepPower * stepDivisor;\n\n    if (this.maxPrecision < Number.MAX_VALUE && step != $math.ceil(step, this.maxPrecision)) {\n      step = $math.ceil(step, this.maxPrecision);\n    }\n\n    var decCount = 0; // in case numbers are smaller than 1\n\n    if (stepPower < 1) {\n      // exponent is less then 1 too. Count decimals of exponent\n      decCount = Math.round(Math.abs(Math.log(Math.abs(stepPower)) * Math.LOG10E)) + 1; // round step\n\n      step = $math.round(step, decCount);\n    }\n\n    if (!this.logarithmic) {\n      // final min and max\n      var minCount = Math.floor(min / step);\n      min = $math.round(step * minCount, decCount);\n      var maxCount = void 0;\n\n      if (!strictMode) {\n        maxCount = Math.ceil(max / step);\n      } else {\n        maxCount = Math.floor(max / step);\n      }\n\n      if (maxCount == minCount) {\n        maxCount++;\n      }\n\n      max = $math.round(step * maxCount, decCount);\n\n      if (max < initialMax) {\n        max = max + step;\n      }\n\n      if (min > initialMin) {\n        min = min - step;\n      }\n    }\n\n    return {\n      min: min,\n      max: max,\n      step: step\n    };\n  };\n\n  Object.defineProperty(ValueAxis.prototype, \"min\", {\n    /**\r\n     * @return Min value\r\n     */\n    get: function () {\n      var min = this._minAdjusted;\n\n      if (!$type.isNumber(min)) {\n        min = this._minDefined;\n      }\n\n      return min;\n    },\n\n    /**\r\n     * A minimum value for the axis scale.\r\n     *\r\n     * This value might be auto-adjusted by the Axis in order to accomodate the\r\n     * grid nicely, i.e. plot area is divided by grid in nice equal cells.\r\n     *\r\n     * The above might be overridden by `strictMinMax` which will force exact\r\n     * user-defined min and max values to be used for scale.\r\n     *\r\n     * @param value  Min value\r\n     */\n    set: function (value) {\n      if (this._minDefined != value) {\n        this._minDefined = value;\n        this.invalidate();\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(ValueAxis.prototype, \"minDefined\", {\n    /**\r\n     * Min value as defined by user's code, not auto-calculated.\r\n     *\r\n     * @readonly\r\n     * @return Min value\r\n     */\n    get: function () {\n      return this._minDefined;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(ValueAxis.prototype, \"maxDefined\", {\n    /**\r\n     * Max value as defined by user's code, not auto-calculated.\r\n     *\r\n     * @readonly\r\n     * @return Man value\r\n     */\n    get: function () {\n      return this._maxDefined;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(ValueAxis.prototype, \"extraMin\", {\n    /**\r\n     * @return {number}\r\n     */\n    get: function () {\n      return this.getPropertyValue(\"extraMin\");\n    },\n\n    /**\r\n     * Allows relatively adjusting minimum value of the axis' scale.\r\n     *\r\n     * The value is relative to the actual range of values currently displayed\r\n     * on the axis.\r\n     *\r\n     * E.g.: 0.5 will mean half of the current range. If we have axis displaying\r\n     * from 100 to 200, we will now have axis displaying from 50 to 200 because\r\n     * we asked to expand minimum value by 50% (0.5).\r\n     *\r\n     * @param {number}\r\n     */\n    set: function (value) {\n      if (this.setPropertyValue(\"extraMin\", value)) {\n        this.invalidateDataItems();\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(ValueAxis.prototype, \"extraMax\", {\n    /**\r\n     * @return Min multiplier\r\n     */\n    get: function () {\n      return this.getPropertyValue(\"extraMax\");\n    },\n\n    /**\r\n     * Allows relatively adjusting maximum value of the axis' scale.\r\n     *\r\n     * The value is relative to the actual range of values currently displayed\r\n     * on the axis.\r\n     *\r\n     * E.g.: 0.5 will mean half of the current range. If we have axis displaying\r\n     * from 100 to 200, we will now have axis displaying from 100 to 250 because\r\n     * we asked to expand maximum value by 50% (0.5).\r\n     *\r\n     * @param {number}\r\n     */\n    set: function (value) {\n      if (this.setPropertyValue(\"extraMax\", value)) {\n        this.invalidateDataItems();\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(ValueAxis.prototype, \"step\", {\n    /**\r\n     * Current calculated delta in values between two adjacent grid lines (step).\r\n     *\r\n     * This is a read-only value and cannot be used to set actual step.\r\n     *\r\n     * @readonly\r\n     * @see {@link https://www.amcharts.com/docs/v4/concepts/axes/positioning-axis-elements/#Setting_the_density_of_the_the_grid_labels} For more information about modifying density of labels\r\n     * @return [description]\r\n     */\n    get: function () {\n      return this._step;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(ValueAxis.prototype, \"max\", {\n    /**\r\n     * @return Max value\r\n     */\n    get: function () {\n      var max = this._maxAdjusted;\n\n      if (!$type.isNumber(max)) {\n        max = this._maxDefined;\n      }\n\n      return max;\n    },\n\n    /**\r\n     * A maximum value for the axis scale.\r\n     *\r\n     * This value might be auto-adjusted by the Axis in order to accomodate the\r\n     * grid nicely, i.e. plot area is divided by grid in nice equal cells.\r\n     *\r\n     * The above might be overridden by `strictMinMax` which will force exact\r\n     * user-defined min and max values to be used for scale.\r\n     *\r\n     * @param value  Max value\r\n     */\n    set: function (value) {\n      if (this._maxDefined != value) {\n        this._maxDefined = value;\n        this.invalidate();\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\r\n   * Used for the Series to register itself as the user of this Axis.\r\n   *\r\n   * This will also decorate both the Series and Axis with event handlers, used\r\n   * to redraw on Axis position/zoom change.\r\n   *\r\n   * A disposer for those events is returned, so that they can be disposed\r\n   * together with Series.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param series  Series\r\n   * @return Disposer for events\r\n   */\n\n  ValueAxis.prototype.registerSeries = function (series) {\n    return new MultiDisposer([_super.prototype.registerSeries.call(this, series), series.events.on(\"extremeschanged\", this.handleExtremesChange, this, false), series.events.on(\"selectionextremeschanged\", this.handleSelectionExtremesChange, this, false), this.events.on(\"extremeschanged\", series.invalidate, series, false)]);\n  };\n  /**\r\n   * Perform tasks after Axis zoom.\r\n   */\n\n\n  ValueAxis.prototype.handleSelectionExtremesChange = function () {\n    var _this = this;\n\n    var selectionMin;\n    var selectionMax;\n    var allHidden = true;\n    $iter.each(this.series.iterator(), function (series) {\n      if (!series.ignoreMinMax && !series.isHidden) {\n        if (series.visible && !series.isHiding) {\n          allHidden = false;\n        }\n\n        var seriesSelectionMin = series.selectionMin(_this);\n        var seriesSelectionMax = series.selectionMax(_this);\n\n        if ($type.isNumber(seriesSelectionMin)) {\n          if (!$type.isNumber(selectionMin) || seriesSelectionMin < selectionMin) {\n            selectionMin = seriesSelectionMin;\n          }\n        } // check max\n\n\n        if ($type.isNumber(seriesSelectionMax)) {\n          if (!$type.isNumber(selectionMax) || seriesSelectionMax > selectionMax) {\n            selectionMax = seriesSelectionMax;\n          }\n        }\n      }\n    });\n\n    if (this.includeRangesInMinMax) {\n      this.axisRanges.each(function (range) {\n        if (!range.ignoreMinMax) {\n          var minValue = $math.min(range.value, range.endValue);\n          var maxValue = $math.max(range.value, range.endValue);\n\n          if (minValue < selectionMax) {\n            selectionMax = minValue;\n          }\n\n          if (maxValue > selectionMax) {\n            selectionMax = maxValue;\n          }\n        }\n      });\n    } // this is not good, as if date axis is initially zoomed, selection of y axis is reset to 0, 1 at the end of this method\n    //$iter.each(this.series.iterator(), (series) => {\n    //\tif (!series.appeared) {\n    //\t\tallHidden = true;\n    //\t}\n    //})\n\n\n    if ($type.isNumber(this._minDefined)) {\n      if (this.strictMinMax) {\n        selectionMin = this._minDefined;\n      } else {\n        selectionMin = this.min;\n      }\n    } else if (this.strictMinMax) {\n      selectionMin = this._minReal;\n    }\n\n    if ($type.isNumber(this._maxDefined)) {\n      if (this.strictMinMax) {\n        selectionMax = this._maxDefined;\n      } else {\n        selectionMax = this.max;\n      }\n    } else if (this.strictMinMax) {\n      selectionMax = this._maxReal;\n    }\n\n    if (selectionMin == selectionMax) {\n      selectionMin -= this._deltaMinMax;\n      selectionMax += this._deltaMinMax;\n      var minMaxStep2 = this.adjustMinMax(selectionMin, selectionMax, 0, this._gridCount, this.strictMinMax);\n      selectionMin = minMaxStep2.min;\n      selectionMax = minMaxStep2.max;\n    }\n\n    var dif = this.adjustDifference(selectionMin, selectionMax);\n    var minMaxStep = this.adjustMinMax(selectionMin, selectionMax, dif, this._gridCount);\n    selectionMin = minMaxStep.min;\n    selectionMax = minMaxStep.max;\n    selectionMin -= (selectionMax - selectionMin) * this.extraMin;\n    selectionMax += (selectionMax - selectionMin) * this.extraMax;\n    selectionMin = $math.fitToRange(selectionMin, this.min, this.max);\n    selectionMax = $math.fitToRange(selectionMax, this.min, this.max); // do it for the second time !important\n\n    dif = this.adjustDifference(selectionMin, selectionMax);\n    minMaxStep = this.adjustMinMax(selectionMin, selectionMax, dif, this._gridCount, true);\n    selectionMin = minMaxStep.min;\n    selectionMax = minMaxStep.max;\n\n    if (this.strictMinMax) {\n      selectionMin = $math.max(selectionMin, this._minDefined);\n      selectionMax = $math.min(selectionMax, this._maxDefined);\n    }\n\n    this._minZoomed = selectionMin;\n    this._maxZoomed = selectionMax;\n    this._step = minMaxStep.step;\n    var start = this.valueToPosition(selectionMin);\n    var end = this.valueToPosition(selectionMax); // in case all series are hidden or hiding, full zoomout\n\n    if (allHidden) {\n      start = 0;\n      end = 1;\n    }\n\n    if (!this.keepSelection) {\n      this.zoom({\n        start: start,\n        end: end\n      }, false, false, 0);\n    }\n  };\n\n  Object.defineProperty(ValueAxis.prototype, \"strictMinMax\", {\n    /**\r\n     * @return Use exact values?\r\n     */\n    get: function () {\n      return this.getPropertyValue(\"strictMinMax\");\n    },\n\n    /**\r\n     * Indicates whether to blindly use exact `min` and `max` values set by user\r\n     * when generating Axis scale.\r\n     *\r\n     * If not set, the Axis might slightly adjust those values to accomodate a\r\n     * better looking grid.\r\n     *\r\n     * NOTE: if `min` and `max` are not set, setting `strictMinMax` to `true`\r\n     * will result in fixing the scale of the axis to actual lowest and highest\r\n     * values in the series within currently selected scope.\r\n     *\r\n     * @default false\r\n     * @param value Use exact values?\r\n     */\n    set: function (value) {\n      if (this.setPropertyValue(\"strictMinMax\", value)) {\n        this.invalidate();\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(ValueAxis.prototype, \"logarithmic\", {\n    /**\r\n     * @return Logarithmic scale?\r\n     */\n    get: function () {\n      return this.getPropertyValue(\"logarithmic\");\n    },\n\n    /**\r\n     * Indicates if this axis should use a logarithmic scale.\r\n     *\r\n     * Please note that logarithmic axis can **only** accommodate values bigger\r\n     * than zero.\r\n     *\r\n     * Having zero or negative values will result in error and failure of the\r\n     * whole chart.\r\n     *\r\n     * @param value Logarithmic scale?\r\n     */\n    set: function (value) {\n      if (this.setPropertyValue(\"logarithmic\", value)) {\n        this.invalidate();\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(ValueAxis.prototype, \"keepSelection\", {\n    /**\r\n     * @return Preseve zoom after data update?\r\n     */\n    get: function () {\n      return this.getPropertyValue(\"keepSelection\");\n    },\n\n    /**\r\n     * Indicates if a current selection (zoom) should be kept across data updates.\r\n     *\r\n     * If your axis is zoomed while chart's data is updated, the axis will try\r\n     * to retain the same start and end values.\r\n     *\r\n     * You can also use this to initially pre-zoom axis:\r\n     *\r\n     * ```TypeScript\r\n     * axis.keepSelection = true;\r\n     * axis.start = 0.5;\r\n     * axis.end = 0.7;\r\n     * ```\r\n     * ```JavaScript\r\n     * axis.keepSelection = true;\r\n     * axis.start = 0.5;\r\n     * axis.end = 0.7;\r\n     * ```\r\n     * ```JSON\r\n     * {\r\n     *   \"xAxes\": [{\r\n     *     // ...\r\n     *     \"keepSelection\": true,\r\n     *     \"start\": 0.5,\r\n     *     \"end\": 0.7\r\n     *   }]\r\n     * }\r\n     * ```\r\n     *\r\n     * The above will start the chart zoomed from the middle of the actual scope\r\n     * to 70%.\r\n     *\r\n     * @since 4.1.1\r\n     * @default flase\r\n     * @param  value  Preseve zoom after data update?\r\n     */\n    set: function (value) {\n      this.setPropertyValue(\"keepSelection\", value);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(ValueAxis.prototype, \"includeRangesInMinMax\", {\n    /**\r\n     * @return Include ranges?\r\n     */\n    get: function () {\n      return this.getPropertyValue(\"includeRangesInMinMax\");\n    },\n\n    /**\r\n     * If set to `true`, values of axis ranges will be included when calculating\r\n     * range of values / scale of the [[ValueAxis]].\r\n     *\r\n     * @default false\r\n     * @since 4.4.9\r\n     * @param  value  Include ranges?\r\n     */\n    set: function (value) {\n      this.setPropertyValue(\"includeRangesInMinMax\", value);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(ValueAxis.prototype, \"maxPrecision\", {\n    /**\r\n     * @return max precision\r\n     */\n    get: function () {\n      return this.getPropertyValue(\"maxPrecision\");\n    },\n\n    /**\r\n     * Maximum number of decimals to allow when placing grid lines and labels\r\n     * on axis.\r\n     *\r\n     * Set it to `0` (zero) to force integer-only axis labels.\r\n     *\r\n     * @param {number}\r\n     */\n    set: function (value) {\n      if (this.setPropertyValue(\"maxPrecision\", value)) {\n        this.invalidate();\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\r\n   * Invalidates axis data items when series extremes change\r\n   */\n\n  ValueAxis.prototype.handleExtremesChange = function () {\n    var _this = this;\n\n    this._extremesChanged = true;\n    this.getMinMax();\n\n    if (this.ghostLabel) {\n      var mw_1 = 0;\n      this.dataItems.each(function (dataItem) {\n        if (dataItem.label && dataItem.label.pixelWidth > mw_1) {\n          _this.ghostLabel.text = dataItem.label.currentText;\n        }\n      });\n    }\n  };\n  /**\r\n   * Returns relative position on axis for series' data item's value.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @todo Description (review)\r\n   * @param dataItem  Data item\r\n   * @param key       Data field to get value from\r\n   * @param location  Location (0-1)\r\n   * @param stackKey  ?\r\n   * @return X coordinate (px)\r\n   */\n\n\n  ValueAxis.prototype.getX = function (dataItem, key, location, stackKey, range) {\n    return this.renderer.positionToPoint(this.getPositionX(dataItem, key, location, stackKey, range)).x;\n  };\n  /**\r\n   * Returns the X coordinate for series' data item's value.\r\n   *\r\n   * @since 4.5.14\r\n   * @param  dataItem  Data item\r\n   * @param  key       Data field to get value from\r\n   * @param  location  Location (0-1)\r\n   * @param  stackKey  ?\r\n   * @return           Relative position\r\n   */\n\n\n  ValueAxis.prototype.getPositionX = function (dataItem, key, location, stackKey, range) {\n    var value = dataItem.getWorkingValue(key);\n\n    if (!$type.hasValue(stackKey)) {\n      stackKey = \"valueX\";\n    }\n\n    var stack = dataItem.getValue(stackKey, \"stack\");\n\n    if (!$type.isNumber(value)) {\n      value = this.baseValue;\n\n      if (this.logarithmic) {\n        if (stack > 0) {\n          value = 0;\n        }\n      }\n    }\n\n    var position = this.valueToPosition(value + stack);\n\n    if (range) {\n      position = $math.fitToRange(position, range.start, range.end);\n    }\n\n    return position;\n  };\n  /**\r\n   * Returns the Y coordinate for series' data item's value.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @todo Description (review)\r\n   * @param dataItem  Data item\r\n   * @param key       Data field to get value from\r\n   * @param location  Location (0-1)\r\n   * @param stackKey  Stack ID\r\n   * @return Y coordinate (px)\r\n   */\n\n\n  ValueAxis.prototype.getY = function (dataItem, key, location, stackKey, range) {\n    return this.renderer.positionToPoint(this.getPositionY(dataItem, key, location, stackKey, range)).y;\n  };\n  /**\r\n   * Returns relative position on axis for series' data item's value.\r\n   *\r\n   * @since 4.5.14\r\n   * @param  dataItem  Data item\r\n   * @param  key       Data field to get value from\r\n   * @param  location  Location (0-1)\r\n   * @param  stackKey  Stack ID\r\n   * @return           Relative position\r\n   */\n\n\n  ValueAxis.prototype.getPositionY = function (dataItem, key, location, stackKey, range) {\n    var value = dataItem.getWorkingValue(key);\n\n    if (!$type.hasValue(stackKey)) {\n      stackKey = \"valueY\";\n    }\n\n    var stack = dataItem.getValue(stackKey, \"stack\");\n\n    if (!$type.isNumber(value)) {\n      value = this.baseValue;\n\n      if (this.logarithmic) {\n        if (stack > 0) {\n          value = 0;\n        }\n      }\n    }\n\n    var position = this.valueToPosition(value + stack);\n\n    if (range) {\n      position = $math.fitToRange(position, range.start, range.end);\n    }\n\n    return position;\n  };\n  /**\r\n   * Returns an angle for series data item.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @todo Description (review)\r\n   * @param dataItem  Data item\r\n   * @param key       Data field to get value from\r\n   * @param location  Location (0-1)\r\n   * @param stackKey  Stack ID\r\n   * @param range Range to fit in\r\n   * @return Angle\r\n   */\n\n\n  ValueAxis.prototype.getAngle = function (dataItem, key, location, stackKey, range) {\n    var value = dataItem.getWorkingValue(key);\n    var stack = dataItem.getValue(stackKey, \"stack\");\n\n    if (!$type.isNumber(value)) {\n      value = this.baseValue;\n    }\n\n    var position = this.valueToPosition(value + stack);\n\n    if (range) {\n      position = $math.fitToRange(position, range.start, range.end);\n    }\n\n    return this.positionToAngle(position);\n  };\n  /**\r\n   * [getAnyRangePath description]\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @todo Description\r\n   * @param start     [description]\r\n   * @param end       [description]\r\n   * @param location  [description]\r\n   * @return [description]\r\n   */\n\n\n  ValueAxis.prototype.getAnyRangePath = function (start, end, location) {\n    var startPosition = this.valueToPosition(start);\n    var endPosition = this.valueToPosition(end);\n    return this.getPositionRangePath(startPosition, endPosition); // Base class (Axis) gets range shape from AxisRenderer\n  };\n  /**\r\n   * Returns text to show in a axis tooltip, based on specific position within\r\n   * axis.\r\n   *\r\n   * The label will be formatted as per [[NumberFormatter]] set for the whole\r\n   * chart, or explicitly for this Axis.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param position  Position (px)\r\n   * @return Label (numeric value)\r\n   */\n\n\n  ValueAxis.prototype.getTooltipText = function (position) {\n    var value = $math.round(this.positionToValue(position), this._stepDecimalPlaces);\n    var valueStr = this.tooltip.numberFormatter.format(value);\n\n    if (!this._adapterO) {\n      return valueStr;\n    } else {\n      return this._adapterO.apply(\"getTooltipText\", valueStr);\n    }\n  };\n  /**\r\n   * Zooms axis to specific values.\r\n   *\r\n   * @param startValue      Start value\r\n   * @param endValue        End value\r\n   * @param skipRangeEvent  Do not invoke events\r\n   * @param instantly       Do not play zoom animations\r\n   */\n\n\n  ValueAxis.prototype.zoomToValues = function (startValue, endValue, skipRangeEvent, instantly) {\n    var start = (startValue - this.min) / (this.max - this.min);\n    var end = (endValue - this.min) / (this.max - this.min);\n    this.zoom({\n      start: start,\n      end: end\n    }, skipRangeEvent, instantly);\n  };\n\n  Object.defineProperty(ValueAxis.prototype, \"minZoomed\", {\n    /**\r\n     * A smallest value in axis scale within current zoom.\r\n     *\r\n     * @return Min zoom value\r\n     */\n    get: function () {\n      return $math.max(this.min, this._minZoomed);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(ValueAxis.prototype, \"maxZoomed\", {\n    /**\r\n     * A biggest value in axis scale within current zoom.\r\n     * @return [description]\r\n     */\n    get: function () {\n      return $math.min(this.max, this._maxZoomed);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\r\n   * Updates positioning of Axis breaks after something changes.\r\n   *\r\n   * @ignore Exclude from docs\r\n   */\n\n  ValueAxis.prototype.fixAxisBreaks = function () {\n    var _this = this;\n\n    _super.prototype.fixAxisBreaks.call(this);\n\n    var axisBreaks = this._axisBreaks;\n\n    if (axisBreaks && axisBreaks.length > 0) {\n      // process breaks\n      axisBreaks.each(function (axisBreak) {\n        var startValue = axisBreak.adjustedStartValue;\n        var endValue = axisBreak.adjustedEndValue; // break difference\n\n        var axisBreakDif = endValue - startValue;\n\n        var axisBreakGridCount = Math.ceil(axisBreakDif * axisBreak.breakSize) * _this._gridCount / (_this.max - _this.min); // calculate min, max and step for axis break\n\n\n        var breakMinMaxStep = _this.adjustMinMax(startValue, endValue, axisBreakDif, axisBreakGridCount, true);\n\n        axisBreak.adjustedStep = breakMinMaxStep.step;\n        axisBreak.adjustedMin = breakMinMaxStep.min;\n        axisBreak.adjustedMax = breakMinMaxStep.max;\n      });\n    }\n\n    this._difference = this.adjustDifference(this.min, this.max);\n  };\n  /**\r\n   * Returns value based on position.\r\n   *\r\n   * Please note that `position` represents position within axis which may be\r\n   * zoomed and not correspond to Cursor's `position`.\r\n   *\r\n   * To convert Cursor's `position` to Axis' `position` use `toAxisPosition()` method.\r\n   *\r\n   * @see {@link https://www.amcharts.com/docs/v4/tutorials/tracking-cursors-position-via-api/#Tracking_Cursor_s_position} For more information about cursor tracking.\r\n   * @param position  Relative position on axis (0-1)\r\n   * @return Position label\r\n   */\n\n\n  ValueAxis.prototype.getPositionLabel = function (position) {\n    var value = this.positionToValue(position);\n    return this.numberFormatter.format(value);\n  };\n  /**\r\n   * Shows Axis tooltip at specific value\r\n   *\r\n   * @param value Value\r\n   */\n\n\n  ValueAxis.prototype.showTooltipAt = function (value) {\n    this.showTooltipAtPosition(this.valueToPosition(value));\n  };\n  /**\r\n   * Copies all properties and related data from a different instance of Axis.\r\n   *\r\n   * @param source Source Axis\r\n   */\n\n\n  ValueAxis.prototype.copyFrom = function (source) {\n    _super.prototype.copyFrom.call(this, source);\n\n    this.min = source.min;\n    this.max = source.max;\n    this.calculateTotals = source.calculateTotals;\n    this._baseValue = source.baseValue;\n  };\n\n  return ValueAxis;\n}(Axis);\n\nexport { ValueAxis };\n/**\r\n * Register class in system, so that it can be instantiated using its name from\r\n * anywhere.\r\n *\r\n * @ignore\r\n */\n\nregistry.registeredClasses[\"ValueAxis\"] = ValueAxis;\nregistry.registeredClasses[\"ValueAxisDataItem\"] = ValueAxisDataItem;","map":null,"metadata":{},"sourceType":"module"}